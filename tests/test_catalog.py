"""
Tests the IBM PAIRS API wrapper features.

Copyright 2019-2021 Physical Analytics, IBM Research All Rights Reserved.

SPDX-License-Identifier: BSD-3-Clause
"""
# fold: Import Python Standard Library {{{
# Python Standard Library:
import json
#}}}
# fold: Import ibmpairs Modules {{{
# ibmpairs Modules:
from ibmpairs.logger import logger
import ibmpairs.authentication as authentication
import ibmpairs.catalog as catalog
import ibmpairs.client as cl
#}}}
# fold: Import Third Party Libraries {{{
# Third Party Libraries:
import responses
import unittest
from unittest import mock
import pandas as pd
#}}}

data_set_requests_get_success_dict = {
    "id": "string",
    "name": "string",
    "key": "string",
    "category": {
        "id": "1",
        "name": "Satellite"
    },
    "level": 0,
    "crs": "string",
    "dsourceHLink": "string",
    "dsourceDesc": "string",
    "status": "Production",
    "dataOrigin": "string",
    "maxLayers": "30",
    "name_alternate": "ESA Sentinel 2 Level-2A",
    "rating": "4.0",
    "description_short": "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.",
    "description_long": "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.",
    "description_links": [
        "https://sentinel.esa.int/web/sentinel/missions",
        "https://sentinel.esa.int/documents/247904/685211/Sentinel-2_User_Handbook",
        "https://sentinel.esa.int/web/sentinel/missions/sentinel-2/data-products",
        "https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi"
    ],
    "data_source_name": "European Space Agency Sentinel-2",
    "data_source_attribution": "'Copernicus Sentinel data [Year]' for Sentinel data; see https://lta.cr.usgs.gov/sites/default/files/Sentinel_Data_Terms_and_Conditions.pdf",
    "data_source_description": "'Level-2A is generated by the Payload Data Ground Segment using the Sen2Cor processor. Level-2A products are made available to users via the Copernicus Open Access Hub: https://scihub.copernicus.eu/dhus/#/home",
    "data_source_links": [
        "https://sentinel.esa.int/web/sentinel/sentinel-data-access"
    ],
    "update_interval_max": "1 day",
    "update_interval_description": "Uploads are run daily. However, note the temporal resolution.",
    "lag_horizon": "5 days",
    "lag_horizon_description": "Data is available within 24 hours.",
    "temporal_resolution": "5 days",
    "temporal_resolution_description": "string",
    "spatial_resolution_of_raw_data": "100m",
    "interpolation": "near",
    "dimensions_description": "The sole dimension is called \"horizon\" and refers to the forecast horizon in hours. (Only integer horizons are allowed.)",
    "permanence": "true",
    "permanence_description": "Data with timestamp into the future will be update, but remain constant past current timestamp (except for error corrrection).",
    "known_issues": "Updates are irregular.",
    "responsible_organization": "<Your Organization>",
    "properties": {
        "Sector": [
            "Animals/livestock",
            "Transportation/infrastructure",
            "Vegetation/crops",
            "Weather/climate"
        ],
        "Application": [
            "Agriculture"
        ],
        "Domain": [
            "Land surface"
        ],
        "Type": [
            "Data product"
        ],
        "Source": [
            "Satellite",
            "Survey"
        ]
    },
    "spatial_coverage": {
        "Country": [
            "Belgium",
            "Bolivia",
            "France",
            "Germany",
            "India",
            "Indonesia",
            "Luxembourg",
            "Netherlands",
            "Switzerland",
            "Thailand",
            "United Kingdom",
            "United States of America"
        ]
    },
    "latitude_min": "-90",
    "longitude_min": "-180",
    "latitude_max": "90",
    "longitude_max": "180",
    "temporal_min": "2016-03-12T00:00:01.000Z",
    "temporal_max": "2019-07-30T00:00:01.000Z",
    "offering_status": ""
}

# test_data_set_get
def mocked_data_set_requests_get(*args, **kwargs):
        
    identifier = None
    
    if kwargs.get("url") is not None:
        url = kwargs["url"]
    
    class MockResponse:
        def __init__(self, json_data, status_code):
            self.json_data = json_data
            self.status_code = status_code

        def json(self):
            return self.json_data
            
    if (url == "https://pairs.res.ibm.com/v2/datasets/1"):
        
        return MockResponse(data_set_requests_get_success_dict, 200)
    elif (url == "https://pairs.res.ibm.com/v2/datasets/2"):
        return_dict = {}
        return_dict["message"] = "Error: 404 Not Found"
            
        return MockResponse(return_dict, 404)
    else:
        # This is intended to mock a 'server error' init of MockResponse has no attribute status.
        return MockResponse(status = "abc")

# test_data_set_create
def mocked_data_set_requests_post(*args, **kwargs):

    if kwargs.get("url") is not None:
        url = kwargs["url"]
    
    if kwargs.get("body") is not None:
        if isinstance(kwargs.get("body"), str):
            j = json.loads(kwargs.get("body"))
            name = j["name"]
    
    class MockResponse:
        def __init__(self, json_data, status_code):
            self.json_data = json_data
            self.status_code = status_code

        def json(self):
            return self.json_data

    if (url == "https://pairs.res.ibm.com/v2/datasets/" and name == "High res imagery (ESA Sentinel 2)"):
        return_dict = {}
        return_dict["datasetId"] = 0
        return_dict["status"] = 0
        return_dict["message"] = "string"
        return MockResponse(return_dict, 200)
    elif (url == "https://pairs.res.ibm.com/v2/datasets/" and name == "string2"):
        return_dict = {}
        return_dict["message"] = "Error: 404 Not Found"

        return MockResponse(return_dict, 404)
    else:
        # This is intended to mock a 'server error' init of MockResponse has no attribute status.
        return MockResponse(status = "abc")
        
# test_data_set_update
def mocked_data_set_requests_put(*args, **kwargs):

    if kwargs.get("url") is not None:
        url = kwargs["url"]
    
    if kwargs.get("body") is not None:
        if isinstance(kwargs.get("body"), str):
            j = json.loads(kwargs.get("body"))
            name = j["name"]
    
    class MockResponse:
        def __init__(self, json_data, status_code):
            self.json_data = json_data
            self.status_code = status_code

        def json(self):
            return self.json_data

    if (url == "https://pairs.res.ibm.com/v2/datasets/1" and name == "High res imagery (ESA Sentinel 2)"):
        return_dict = {}
        return_dict["datasetId"] = 0
        return_dict["status"] = 0
        return_dict["message"] = "string"
        return MockResponse(return_dict, 200)
    elif (url == "https://pairs.res.ibm.com/v2/datasets/2" and name == "string2"):
        return_dict = {}
        return_dict["message"] = "Error: 404 Not Found"

        return MockResponse(return_dict, 404)
    else:
        # This is intended to mock a 'server error' init of MockResponse has no attribute status.
        return MockResponse(status = "abc")

# test_data_set_delete
def mocked_data_set_requests_delete(*args, **kwargs):

    if kwargs.get("url") is not None:
        url = kwargs["url"]
    
    class MockResponse:
        def __init__(self, json_data, status_code):
            self.json_data = json_data
            self.status_code = status_code

        def json(self):
            return self.json_data

    if (url == "https://pairs.res.ibm.com/v2/datasets/1"):
        return_dict = {}
        return_dict["datasetId"] = 1
        return_dict["status"] = 0
        return_dict["message"] = "string"
        return MockResponse(return_dict, 200)
    elif (url == "https://pairs.res.ibm.com/v2/datasets/2?hard_delete=true&force=true"):
        return_dict = {}
        return_dict["datasetId"] = 2
        return_dict["status"] = 0
        return_dict["message"] = "string"
        return MockResponse(return_dict, 200)
    elif (url == "https://pairs.res.ibm.com/v2/datasets/3"):
        return_dict = {}
        return_dict["message"] = "Error: 404 Not Found"

        return MockResponse(return_dict, 404)
    else:
        # This is intended to mock a 'server error' init of MockResponse has no attribute status.
        return MockResponse(status = "abc")

ds_gets_tracker = 0

# test_data_sets_get
def mocked_data_sets_requests_get(*args, **kwargs):
    
    global ds_gets_tracker
    
    if kwargs.get("url") is not None:
        url = kwargs["url"]
    
    class MockResponse:
        def __init__(self, json_data, status_code):
            self.json_data = json_data
            self.status_code = status_code

        def json(self):
            return self.json_data
            
    if (url == "https://pairs.res.ibm.com/v2/datasets/full" and ds_gets_tracker == 0):
        ds_gets_tracker = ds_gets_tracker + 1
        return MockResponse(data_sets_dict, 200)
    if (url == "https://pairs.res.ibm.com/v2/datasets/full" and ds_gets_tracker == 1):
        return_dict = {}
        ds_gets_tracker = ds_gets_tracker + 1
        return MockResponse(return_dict, 404)
    else:
        # This is intended to mock a 'server error' init of MockResponse has no attribute status.
        ds_gets_tracker = 0
        return MockResponse(status = "abc")

data_layer_requests_get_success_dict = {
    "id": "string",
    "name": "string",
    "description": "string",
    "dataset": {
        "id": "string",
        "name": "string",
        "key": "string",
        "category": {
            "id": "1",
            "name": "Satellite"
        },
        "level": 0,
        "crs": "string",
        "license_information": "string",
        "offering_status": "string",
        "description_short": "string"
    },
    "units": "string",
    "datatype": "sh",
    "level": "22",
    "crs": "string",
    "colorTable": {
        "id": "32451"
    },
    "name_alternate": "ESA Sentinel 2 Level-2A",
    "rating": "4.0",
    "description_short": "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.",
    "description_long": "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.",
    "description_links": [
        "https://sentinel.esa.int/web/sentinel/missions",
        "https://sentinel.esa.int/documents/247904/685211/Sentinel-2_User_Handbook",
        "https://sentinel.esa.int/web/sentinel/missions/sentinel-2/data-products",
        "https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi"
    ],
    "data_source_name": "European Space Agency Sentinel-2",
    "data_source_attribution": "'Copernicus Sentinel data [Year]' for Sentinel data; see https://lta.cr.usgs.gov/sites/default/files/Sentinel_Data_Terms_and_Conditions.pdf",
    "data_source_description": "'Level-2A is generated by the Payload Data Ground Segment using the Sen2Cor processor. Level-2A products are made available to users via the Copernicus Open Access Hub: https://scihub.copernicus.eu/dhus/#/home",
    "data_source_links": [
        "https://sentinel.esa.int/web/sentinel/sentinel-data-access"
    ],
    "update_interval_max": "1 day",
    "update_interval_description": "Uploads are run daily. However, note the temporal resolution.",
    "lag_horizon": "5 days",
    "lag_horizon_description": "Data is available within 24 hours.",
    "temporal_resolution": "5 days",
    "temporal_resolution_description": "string",
    "spatial_resolution_of_raw_data": "100m",
    "interpolation": "near",
    "interpolation_upload": "near",
    "dimensions_description": "The sole dimension is called \"horizon\" and refers to the forecast horizon in hours. (Only integer horizons are allowed.)",
    "permanence": "true",
    "permanence_description": "Data with timestamp into the future will be update, but remain constant past current timestamp (except for error corrrection).",
    "known_issues": "Updates are irregular.",
    "properties": {
        "Sector": [
            "Animals/livestock",
            "Transportation/infrastructure",
            "Vegetation/crops",
            "Weather/climate"
        ],
        "Application": [
            "Agriculture"
        ],
        "Domain": [
            "Land surface"
        ],
        "Type": [
            "Data product"
        ],
        "Source": [
            "Satellite",
            "Survey"
        ]
    },
    "spatial_coverage": {
        "Country": [
            "Belgium",
            "Bolivia",
            "France",
            "Germany",
            "India",
            "Indonesia",
            "Luxembourg",
            "Netherlands",
            "Switzerland",
            "Thailand",
            "United Kingdom",
            "United States of America"
        ]
    },
    "latitude_min": "-90",
    "longitude_min": "-180",
    "latitude_max": "90",
    "longitude_max": "180",
    "temporal_min": "2016-03-12T00:00:01.000Z",
    "temporal_max": "2019-07-30T00:00:01.000Z",
    "measurement_interval": "6 hours",
    "measurement_interval_description": "Data is recorded instanteneously.",
    "meaning_of_timestamp": "Begining",
    "meaning_of_spatial_descriptor": "Average"
}

# test_data_layer_get
def mocked_data_layer_requests_get(*args, **kwargs):
        
    identifier = None
    
    if kwargs.get("url") is not None:
        url = kwargs["url"]
    
    class MockResponse:
        def __init__(self, json_data, status_code):
            self.json_data = json_data
            self.status_code = status_code

        def json(self):
            return self.json_data
            
    if (url == "https://pairs.res.ibm.com/v2/datalayers/1"):
        
        return MockResponse(data_layer_requests_get_success_dict, 200)
    elif (url == "https://pairs.res.ibm.com/v2/datalayers/2"):
        return_dict = {}
        return_dict["message"] = "Error: 404 Not Found"
            
        return MockResponse(return_dict, 404)
    else:
        # This is intended to mock a 'server error' init of MockResponse has no attribute status.
        return MockResponse(status = "abc")

# test_data_layer_create
def mocked_data_layer_requests_post(*args, **kwargs):

    if kwargs.get("url") is not None:
        url = kwargs["url"]
    
    #if kwargs.get("body") is not None:
    #    if isinstance(kwargs.get("body"), str):
    #        j = json.loads(kwargs.get("body"))
    #        name = j["name"]
    
    class MockResponse:
        def __init__(self, json_data, status_code):
            self.json_data = json_data
            self.status_code = status_code

        def json(self):
            return self.json_data

    if (url == "https://pairs.res.ibm.com/v2/datasets/1/datalayers"):
        return_dict = {}
        return_dict["datalayerIds"] = [1]
        return_dict["status"] = 200
        return_dict["message"] = "Datalayer(s) created successfully"
        return MockResponse(return_dict, 200)
    elif (url == "https://pairs.res.ibm.com/v2/datasets/2/datalayers"):
        return_dict = {}
        return_dict["message"] = "Error: 404 Not Found"

        return MockResponse(return_dict, 404)
    elif (url == "https://pairs.res.ibm.com/v2/datasets/998/datalayers"):
        return_dict = {}
        return_dict["datalayerIds"] = ["P001C0001","P001C0002"]
        return_dict["status"] = 200
        return_dict["message"] = "Datalayer(s) created successfully"

        return MockResponse(return_dict, 200)
    else:
        # This is intended to mock a 'server error' init of MockResponse has no attribute status.
        return MockResponse(status = "abc")
        
# test_data_layer_update
def mocked_data_layer_requests_put(*args, **kwargs):

    if kwargs.get("url") is not None:
        url = kwargs["url"]
    
    #if kwargs.get("body") is not None:
    #    if isinstance(kwargs.get("body"), str):
    #        j = json.loads(kwargs.get("body"))
    #        name = j["name"]
    
    class MockResponse:
        def __init__(self, json_data, status_code):
            self.json_data = json_data
            self.status_code = status_code

        def json(self):
            return self.json_data

    if (url == "https://pairs.res.ibm.com/v2/datalayers/1"):
        return_dict = {}
        return_dict["datalayerIds"] = [87234,87235,872346]
        return_dict["status"] = 200
        return_dict["message"] = "Datalayer(s) created successfully"
        return MockResponse(return_dict, 200)
    elif (url == "https://pairs.res.ibm.com/v2/datalayers/2"):
        return_dict = {}
        return_dict["message"] = "Error: 404 Not Found"

        return MockResponse(return_dict, 404)
    else:
        # This is intended to mock a 'server error' init of MockResponse has no attribute status.
        return MockResponse(status = "abc")

# test_data_layer_delete
def mocked_data_layer_requests_delete(*args, **kwargs):

    if kwargs.get("url") is not None:
        url = kwargs["url"]
    
    class MockResponse:
        def __init__(self, json_data, status_code):
            self.json_data = json_data
            self.status_code = status_code

        def json(self):
            return self.json_data

    if (url == "https://pairs.res.ibm.com/v2/datalayers/1"):
        return_dict = {}
        return_dict["id"] = 1
        return MockResponse(return_dict, 200)
    elif (url == "https://pairs.res.ibm.com/v2/datalayers/2?hard_delete=true&force=true"):
        return_dict = {}
        return_dict["id"] = 2
        return MockResponse(return_dict, 200)
    elif (url == "https://pairs.res.ibm.com/v2/datalayers/3"):
        return_dict = {}
        return_dict["message"] = "Error: 404 Not Found"

        return MockResponse(return_dict, 404)
    else:
        # This is intended to mock a 'server error' init of MockResponse has no attribute status.
        return MockResponse(status = "abc")

data_layer_create_get_dict = [
    {
        "id": "1",
        "name": "string",
        "dataset": {
            "id": "string",
            "name": "string",
            "key": "string",
            "category": {
                "id": "1",
                "name": "Satellite"
            },
            "level": 0,
            "crs": "string",
            "license_information": "string",
            "offering_status": "string",
            "description_short": "string"
        },
        "unit": "string",
        "datatype": "sh",
        "description_short": "string"
    }
]

data_layer_get_999_dict = [
    {
        "id": "string",
        "name": "string",
        "dataset": {
            "id": "999",
            "name": "string",
            "key": "string",
            "category": {
                "id": "1",
                "name": "Satellite"
            },
            "level": 0,
            "crs": "string",
            "license_information": "string",
            "offering_status": "string",
            "description_short": "string"
        },
        "unit": "string",
        "datatype": "sh",
        "description_short": "string"
    },
    {
        "id": "string2",
        "name": "string2",
        "dataset": {
            "id": "999",
            "name": "string",
            "key": "string",
            "category": {
                "id": "1",
                "name": "Satellite"
            },
            "level": 0,
            "crs": "string",
            "license_information": "string",
            "offering_status": "string",
            "description_short": "string"
        },
        "unit": "string",
        "datatype": "sh",
        "description_short": "string"
    }
]

data_layers_create_get_dict = [
    {
        "name": "string",
        "description": "string",
        "dataset": {
            "id": "string",
            "name": "string",
            "key": "string",
            "category": {
                "id": "1",
                "name": "Satellite"
            },
            "level": 0,
            "crs": "string",
            "license_information": "string",
            "offering_status": "string",
            "description_short": "string"
        },
        "units": "string",
        "datatype": "sh",
        "level": "22",
        "crs": "string"
    },
    {
        "name": "string",
        "description": "string",
        "dataset": {
            "id": "string",
            "name": "string",
            "key": "string",
            "category": {
                "id": "1",
                "name": "Satellite"
            },
            "level": 0,
            "crs": "string",
            "license_information": "string",
            "offering_status": "string",
            "description_short": "string"
        },
        "units": "string",
        "datatype": "sh",
        "level": "22",
        "crs": "string"
    }
]

dl_gets_tracker = 0

# test_data_layers_get
def mocked_data_layers_requests_get(*args, **kwargs):
    
    global dl_gets_tracker
    
    if kwargs.get("url") is not None:
        url = kwargs["url"]
    
    class MockResponse:
        def __init__(self, json_data, status_code):
            self.json_data = json_data
            self.status_code = status_code

        def json(self):
            return self.json_data
            
    if (url == "https://pairs.res.ibm.com/v2/datalayers/full" and dl_gets_tracker == 0):
        dl_gets_tracker = dl_gets_tracker + 1
        return MockResponse(data_layers_dict, 200)
    elif (url == "https://pairs.res.ibm.com/v2/datalayers/full" and dl_gets_tracker == 1):
        return_dict = {}
        dl_gets_tracker = dl_gets_tracker + 1
        return MockResponse(return_dict, 404)
    elif (url == 'https://pairs.res.ibm.com/v2/datasets/1/datalayers'):
        return MockResponse(data_layer_create_get_dict, 200)
    elif (url == 'https://pairs.res.ibm.com/v2/datasets/998/datalayers'):
        return_dict = data_layers_create_get_dict
        return_dict[0]["id"] = "P001C0001"
        return_dict[1]["id"] = "P001C0002"
        return MockResponse(return_dict, 200)
    elif (url == 'https://pairs.res.ibm.com/v2/datasets/999/datalayers'):
        return MockResponse(data_layer_get_999_dict, 200)
    else:
        # This is intended to mock a 'server error' init of MockResponse has no attribute status.
        dl_gets_tracker = 0
        return MockResponse(status = "abc")

data_layer_dimension_requests_get_success_dict = {
    "id": 0,
    "order": 0,
    "fullName": "string",
    "shortName": "string",
    "type": "string",
    "identifier": "string",
    "unit": "string"
}

# test_data_layer_dimension_get
def mocked_data_layer_dimension_requests_get(*args, **kwargs):
        
    identifier = None
    
    if kwargs.get("url") is not None:
        url = kwargs["url"]
    
    class MockResponse:
        def __init__(self, json_data, status_code):
            self.json_data = json_data
            self.status_code = status_code

        def json(self):
            return self.json_data
            
    if (url == "https://pairs.res.ibm.com/v2/datalayer_dimensions/1"):
        
        return MockResponse(data_layer_dimension_requests_get_success_dict, 200)
    elif (url == "https://pairs.res.ibm.com/v2/datalayer_dimensions/2"):
        return_dict = {}
        return_dict["message"] = "Error: 404 Not Found"
            
        return MockResponse(return_dict, 404)
    else:
        # This is intended to mock a 'server error' init of MockResponse has no attribute status.
        return MockResponse(status = "abc")
        
# test_data_layer_dimension_create
def mocked_data_layer_dimension_requests_post(*args, **kwargs):

    if kwargs.get("url") is not None:
        url = kwargs["url"]

    class MockResponse:
        def __init__(self, json_data, status_code):
            self.json_data = json_data
            self.status_code = status_code

        def json(self):
            return self.json_data

    if (url == "https://pairs.res.ibm.com/v2/datalayers/1/datalayer_dimensions"):
        return_dict = {}
        return_dict["datalayerDimensionId"] = 100
        return_dict["status"] = 200
        return_dict["message"] = "Datalayer dimension created successfully"
        return MockResponse(return_dict, 200)
    elif (url == "https://pairs.res.ibm.com/v2/datalayers/2/datalayer_dimensions"):
        return_dict = {}
        return_dict["message"] = "Error: 404 Not Found"

        return MockResponse(return_dict, 404)
    else:
        # This is intended to mock a 'server error' init of MockResponse has no attribute status.
        return MockResponse(status = "abc")


# test_data_layer_dimensions_get
def mocked_data_layer_dimensions_requests_get(*args, **kwargs):
    
    if kwargs.get("url") is not None:
        url = kwargs["url"]
    
    class MockResponse:
        def __init__(self, json_data, status_code):
            self.json_data = json_data
            self.status_code = status_code

        def json(self):
            return self.json_data
            
    if (url == "https://pairs.res.ibm.com/v2/datalayers/1/datalayer_dimensions"):

        return MockResponse(data_layer_dimensions_dict, 200)
    elif (url == "https://pairs.res.ibm.com/v2/datalayers/2/datalayer_dimensions"):
        return_dict = {}

        return MockResponse(return_dict, 404)
    else:
        # This is intended to mock a 'server error' init of MockResponse has no attribute status.
        return MockResponse(status = "abc")

data_layer_property_requests_get_success_dict = {
    "id": 0,
    "order": 0,
    "fullName": "string",
    "shortName": "string",
    "type": "string",
    "identifier": "string"
}

# test_data_layer_property_get
def mocked_data_layer_property_requests_get(*args, **kwargs):
        
    identifier = None
    
    if kwargs.get("url") is not None:
        url = kwargs["url"]
    
    class MockResponse:
        def __init__(self, json_data, status_code):
            self.json_data = json_data
            self.status_code = status_code

        def json(self):
            return self.json_data
            
    if (url == "https://pairs.res.ibm.com/v2/datalayer_properties/1"):
        
        return MockResponse(data_layer_property_requests_get_success_dict, 200)
    elif (url == "https://pairs.res.ibm.com/v2/datalayer_properties/2"):
        return_dict = {}
        return_dict["message"] = "Error: 404 Not Found"
            
        return MockResponse(return_dict, 404)
    else:
        # This is intended to mock a 'server error' init of MockResponse has no attribute status.
        return MockResponse(status = "abc")

# test_data_layer_property_create
def mocked_data_layer_property_requests_post(*args, **kwargs):

    if kwargs.get("url") is not None:
        url = kwargs["url"]

    class MockResponse:
        def __init__(self, json_data, status_code):
            self.json_data = json_data
            self.status_code = status_code

        def json(self):
            return self.json_data

    if (url == "https://pairs.res.ibm.com/v2/datalayers/1/datalayer_properties"):
        return_dict = {}
        return_dict["datalayerPropertyId"] = 101
        return_dict["status"] = 200
        return_dict["message"] = "Datalayer property created successfully"
        return MockResponse(return_dict, 200)
    elif (url == "https://pairs.res.ibm.com/v2/datalayers/2/datalayer_properties"):
        return_dict = {}
        return_dict["message"] = "Error: 404 Not Found"

        return MockResponse(return_dict, 404)
    else:
        # This is intended to mock a 'server error' init of MockResponse has no attribute status.
        return MockResponse(status = "abc")


category_dict = {
    "id": "1",
    "name": "Satellite"
}

category_str = r'''{
    "id": "1",
    "name": "Satellite"
}'''

#
class CategoryUnitTest(unittest.TestCase):
    
    #
    def setUp(self):
        self.logger = logger
        self.logger.info('setup')
    
    #
    def tearDown(self):
        self.logger.info('teardown')

    #    
    def test_category_from_dict(self):
        
        self.logger.info('test_category_from_dict')
        
        category = catalog.Category

        category_from_dict = None
            
        got_exception = False

        try:
            category_from_dict = category.from_dict(category_dict)
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        self.assertEqual(category_from_dict.id, 1)
        self.assertEqual(category_from_dict.name, "Satellite")
        
    #    
    def test_category_to_dict(self):
        
        self.logger.info('test_category_to_dict')
        
        category = catalog.Category

        category_from_dict = None
        category_to_dict   = None
                
        got_exception = False

        try:
            category_from_dict = category.from_dict(category_dict)
            category_to_dict = category_from_dict.to_dict()
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        self.assertIsInstance(category_to_dict, dict)
        self.assertEqual(category_to_dict["id"], 1)
        self.assertEqual(category_to_dict["name"], "Satellite")
        
    #
    def test_category_from_json(self):
        
        self.logger.info('test_category_from_json')

        got_exception = False

        try:
            category_from_json = catalog.category_from_json(category_str)
        except Exception as ex:
            self.logger.info(ex)
            got_exception = True

        self.assertFalse(got_exception)
        self.assertEqual(category_from_json.id, 1)
        self.assertEqual(category_from_json.name, "Satellite")
 
    #
    def test_category_to_json(self):
        
        self.logger.info('test_category_to_json')

        got_exception = False
        
        try:
            category_from_json = catalog.category_from_json(category_str)
            category_to_json = catalog.category_to_json(category_from_json)
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        
properties_dict = {
    "Sector": [
        "Animals/livestock",
        "Transportation/infrastructure",
        "Vegetation/crops",
        "Weather/climate"
    ],
    "Application": [
        "Agriculture"
    ],
    "Domain": [
        "Land surface"
    ],
    "Type": [
        "Data product"
    ],
    "Source": [
        "Satellite",
        "Survey"
    ]
}

properties_str = r'''{
    "Sector": [
        "Animals/livestock",
        "Transportation/infrastructure",
        "Vegetation/crops",
        "Weather/climate"
    ],
    "Application": [
        "Agriculture"
    ],
    "Domain": [
        "Land surface"
    ],
    "Type": [
        "Data product"
    ],
    "Source": [
        "Satellite",
        "Survey"
    ]
}'''

#
class PropertiesUnitTest(unittest.TestCase):
    
    #
    def setUp(self):
        self.logger = logger
        self.logger.info('setup')
    
    #
    def tearDown(self):
        self.logger.info('teardown')

    #    
    def test_properties_from_dict(self):
        
        self.logger.info('test_properties_from_dict')
        
        properties = catalog.Properties

        properties_from_dict = None
            
        got_exception = False

        try:
            properties_from_dict = properties.from_dict(properties_dict)
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        self.assertEqual(properties_from_dict.sector[0], "Animals/livestock")
        self.assertEqual(properties_from_dict.sector[1], "Transportation/infrastructure")
        self.assertEqual(properties_from_dict.sector[2], "Vegetation/crops")
        self.assertEqual(properties_from_dict.sector[3], "Weather/climate")
        self.assertEqual(properties_from_dict.application[0], "Agriculture")
        self.assertEqual(properties_from_dict.domain[0], "Land surface")
        self.assertEqual(properties_from_dict.type[0], "Data product")
        self.assertEqual(properties_from_dict.source[0], "Satellite")
        self.assertEqual(properties_from_dict.source[1], "Survey")
        
    #    
    def test_properties_to_dict(self):
        
        self.logger.info('test_properties_to_dict')
        
        properties = catalog.Properties

        properties_from_dict = None
        properties_to_dict   = None
                
        got_exception = False

        try:
            properties_from_dict = properties.from_dict(properties_dict)
            properties_to_dict = properties_from_dict.to_dict()
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        self.assertIsInstance(properties_to_dict, dict)
        self.assertEqual(properties_to_dict["sector"][0], "Animals/livestock")
        self.assertEqual(properties_to_dict["sector"][1], "Transportation/infrastructure")
        self.assertEqual(properties_to_dict["sector"][2], "Vegetation/crops")
        self.assertEqual(properties_to_dict["sector"][3], "Weather/climate")
        self.assertEqual(properties_to_dict["application"][0], "Agriculture")
        self.assertEqual(properties_to_dict["domain"][0], "Land surface")
        self.assertEqual(properties_to_dict["type"][0], "Data product")
        self.assertEqual(properties_to_dict["source"][0], "Satellite")
        self.assertEqual(properties_to_dict["source"][1], "Survey")

    #
    def test_properties_from_json(self):
        
        self.logger.info('test_properties_from_json')

        got_exception = False

        try:
            properties_from_json = catalog.properties_from_json(properties_str)
        except Exception as ex:
            self.logger.info(ex)
            got_exception = True

        self.assertFalse(got_exception)
        self.assertEqual(properties_from_json.sector[0], "Animals/livestock")
        self.assertEqual(properties_from_json.sector[1], "Transportation/infrastructure")
        self.assertEqual(properties_from_json.sector[2], "Vegetation/crops")
        self.assertEqual(properties_from_json.sector[3], "Weather/climate")
        self.assertEqual(properties_from_json.application[0], "Agriculture")
        self.assertEqual(properties_from_json.domain[0], "Land surface")
        self.assertEqual(properties_from_json.type[0], "Data product")
        self.assertEqual(properties_from_json.source[0], "Satellite")
        self.assertEqual(properties_from_json.source[1], "Survey")
 
    #
    def test_properties_to_json(self):
        
        self.logger.info('test_properties_to_json')

        got_exception = False
        
        try:
            properties_from_json = catalog.properties_from_json(properties_str)
            properties_to_json = catalog.properties_to_json(properties_from_json)
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)

spatial_coverage_dict = {
    "Country": [
        "Belgium",
        "Bolivia",
        "France",
        "Germany",
        "India",
        "Indonesia",
        "Luxembourg",
        "Netherlands",
        "Switzerland",
        "Thailand",
        "United Kingdom",
        "United States of America"
    ]
}

spatial_coverage_str = r'''{
    "Country": [
        "Belgium",
        "Bolivia",
        "France",
        "Germany",
        "India",
        "Indonesia",
        "Luxembourg",
        "Netherlands",
        "Switzerland",
        "Thailand",
        "United Kingdom",
        "United States of America"
    ]
}'''

#
class SpatialCoverageUnitTest(unittest.TestCase):
    
    #
    def setUp(self):
        self.logger = logger
        self.logger.info('setup')
    
    #
    def tearDown(self):
        self.logger.info('teardown')

    #    
    def test_spatial_coverage_from_dict(self):
        
        self.logger.info('test_spatial_coverage_from_dict')
        
        spatial_coverage = catalog.SpatialCoverage

        spatial_coverage_from_dict = None
            
        got_exception = False

        try:
            spatial_coverage_from_dict = spatial_coverage.from_dict(spatial_coverage_dict)
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)        
        self.assertEqual(spatial_coverage_from_dict.country[0], "Belgium")
        self.assertEqual(spatial_coverage_from_dict.country[1], "Bolivia")
        self.assertEqual(spatial_coverage_from_dict.country[2], "France")
        self.assertEqual(spatial_coverage_from_dict.country[3], "Germany")
        self.assertEqual(spatial_coverage_from_dict.country[4], "India")
        self.assertEqual(spatial_coverage_from_dict.country[5], "Indonesia")
        self.assertEqual(spatial_coverage_from_dict.country[6], "Luxembourg")
        self.assertEqual(spatial_coverage_from_dict.country[7], "Netherlands")
        self.assertEqual(spatial_coverage_from_dict.country[8], "Switzerland")
        self.assertEqual(spatial_coverage_from_dict.country[9], "Thailand")
        self.assertEqual(spatial_coverage_from_dict.country[10], "United Kingdom")
        self.assertEqual(spatial_coverage_from_dict.country[11], "United States of America")
        
    #    
    def test_spatial_coverage_to_dict(self):
        
        self.logger.info('test_spatial_coverage_to_dict')
        
        spatial_coverage = catalog.SpatialCoverage

        spatial_coverage_from_dict = None
        spatial_coverage_to_dict   = None
                
        got_exception = False

        try:
            spatial_coverage_from_dict = spatial_coverage.from_dict(spatial_coverage_dict)
            spatial_coverage_to_dict = spatial_coverage_from_dict.to_dict()
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        self.assertIsInstance(spatial_coverage_to_dict, dict)
        self.assertEqual(spatial_coverage_to_dict["country"][0], "Belgium")
        self.assertEqual(spatial_coverage_to_dict["country"][1], "Bolivia")
        self.assertEqual(spatial_coverage_to_dict["country"][2], "France")
        self.assertEqual(spatial_coverage_to_dict["country"][3], "Germany")
        self.assertEqual(spatial_coverage_to_dict["country"][4], "India")
        self.assertEqual(spatial_coverage_to_dict["country"][5], "Indonesia")
        self.assertEqual(spatial_coverage_to_dict["country"][6], "Luxembourg")
        self.assertEqual(spatial_coverage_to_dict["country"][7], "Netherlands")
        self.assertEqual(spatial_coverage_to_dict["country"][8], "Switzerland")
        self.assertEqual(spatial_coverage_to_dict["country"][9], "Thailand")
        self.assertEqual(spatial_coverage_to_dict["country"][10], "United Kingdom")
        self.assertEqual(spatial_coverage_to_dict["country"][11], "United States of America")

    #
    def test_spatial_coverage_from_json(self):
        
        self.logger.info('test_spatial_coverage_from_json')

        got_exception = False

        try:
            spatial_coverage_from_json = catalog.spatial_coverage_from_json(spatial_coverage_str)
        except Exception as ex:
            self.logger.info(ex)
            got_exception = True

        self.assertFalse(got_exception)
        self.assertEqual(spatial_coverage_from_json.country[0], "Belgium")
        self.assertEqual(spatial_coverage_from_json.country[1], "Bolivia")
        self.assertEqual(spatial_coverage_from_json.country[2], "France")
        self.assertEqual(spatial_coverage_from_json.country[3], "Germany")
        self.assertEqual(spatial_coverage_from_json.country[4], "India")
        self.assertEqual(spatial_coverage_from_json.country[5], "Indonesia")
        self.assertEqual(spatial_coverage_from_json.country[6], "Luxembourg")
        self.assertEqual(spatial_coverage_from_json.country[7], "Netherlands")
        self.assertEqual(spatial_coverage_from_json.country[8], "Switzerland")
        self.assertEqual(spatial_coverage_from_json.country[9], "Thailand")
        self.assertEqual(spatial_coverage_from_json.country[10], "United Kingdom")
        self.assertEqual(spatial_coverage_from_json.country[11], "United States of America")
 
    #
    def test_spatial_coverage_to_json(self):
        
        self.logger.info('test_spatial_coverage_to_json')

        got_exception = False
        
        try:
            spatial_coverage_from_json = catalog.spatial_coverage_from_json(spatial_coverage_str)
            spatial_coverage_to_json = catalog.spatial_coverage_to_json(spatial_coverage_from_json)
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)

data_set_dict = {
    "id": "string",
    "name": "string",
    "key": "string",
    "category": {
        "id": "1",
        "name": "Satellite"
    },
    "level": 0,
    "crs": "string",
    "dsourceHLink": "string",
    "dsourceDesc": "string",
    "status": "Production",
    "dataOrigin": "string",
    "maxLayers": "30",
    "name_alternate": "ESA Sentinel 2 Level-2A",
    "rating": "4.0",
    "description_short": "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.",
    "description_long": "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.",
    "description_links": [
        "https://sentinel.esa.int/web/sentinel/missions",
        "https://sentinel.esa.int/documents/247904/685211/Sentinel-2_User_Handbook",
        "https://sentinel.esa.int/web/sentinel/missions/sentinel-2/data-products",
        "https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi"
    ],
    "data_source_name": "European Space Agency Sentinel-2",
    "data_source_attribution": "'Copernicus Sentinel data [Year]' for Sentinel data; see https://lta.cr.usgs.gov/sites/default/files/Sentinel_Data_Terms_and_Conditions.pdf",
    "data_source_description": "'Level-2A is generated by the Payload Data Ground Segment using the Sen2Cor processor. Level-2A products are made available to users via the Copernicus Open Access Hub: https://scihub.copernicus.eu/dhus/#/home",
    "data_source_links": [
        "https://sentinel.esa.int/web/sentinel/sentinel-data-access"
    ],
    "update_interval_max": "1 day",
    "update_interval_description": "Uploads are run daily. However, note the temporal resolution.",
    "lag_horizon": "5 days",
    "lag_horizon_description": "Data is available within 24 hours.",
    "temporal_resolution": "5 days",
    "temporal_resolution_description": "string",
    "spatial_resolution_of_raw_data": "100m",
    "interpolation": "near",
    "dimensions_description": "The sole dimension is called \"horizon\" and refers to the forecast horizon in hours. (Only integer horizons are allowed.)",
    "permanence": "true",
    "permanence_description": "Data with timestamp into the future will be update, but remain constant past current timestamp (except for error corrrection).",
    "known_issues": "Updates are irregular.",
    "responsible_organization": "<Your Organization>",
    "properties": {
        "Sector": [
            "Animals/livestock",
            "Transportation/infrastructure",
            "Vegetation/crops",
            "Weather/climate"
        ],
        "Application": [
            "Agriculture"
        ],
        "Domain": [
            "Land surface"
        ],
        "Type": [
            "Data product"
        ],
        "Source": [
            "Satellite",
            "Survey"
        ]
    },
    "spatial_coverage": {
        "Country": [
            "Belgium",
            "Bolivia",
            "France",
            "Germany",
            "India",
            "Indonesia",
            "Luxembourg",
            "Netherlands",
            "Switzerland",
            "Thailand",
            "United Kingdom",
            "United States of America"
        ]
    },
    "latitude_min": "-90",
    "longitude_min": "-180",
    "latitude_max": "90",
    "longitude_max": "180",
    "temporal_min": "2016-03-12T00:00:01.000Z",
    "temporal_max": "2019-07-30T00:00:01.000Z",
    "offering_status": "",
    "contact_person": "John Smith <john.smith@ibm.com>",
    "description_internal": "This data set is not for public dissemination.",
    "description_internal_links": [
            "http://www.ftp.ncep.noaa.gov/data/nccf/com/gfs/prod/"
        ],
    "data_storage_mid_term": "pairsdata.pok.ibm.com:/data/datasets/sentinel2",
    "data_storage_long_term": "Tape",
    "elt_scripts_links": [
            "https://some-place-where-your-code-is-stored.com"
        ],
    "license_information": "Approved"
}

data_set_str = r'''{
    "id": "string",
    "name": "string",
    "key": "string",
    "category": {
        "id": "1",
        "name": "Satellite"
    },
    "level": 0,
    "crs": "string",
    "dsourceHLink": "string",
    "dsourceDesc": "string",
    "status": "Production",
    "dataOrigin": "string",
    "maxLayers": "30",
    "name_alternate": "ESA Sentinel 2 Level-2A",
    "rating": "4.0",
    "description_short": "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.",
    "description_long": "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.",
    "description_links": [
        "https://sentinel.esa.int/web/sentinel/missions",
        "https://sentinel.esa.int/documents/247904/685211/Sentinel-2_User_Handbook",
        "https://sentinel.esa.int/web/sentinel/missions/sentinel-2/data-products",
        "https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi"
    ],
    "data_source_name": "European Space Agency Sentinel-2",
    "data_source_attribution": "'Copernicus Sentinel data [Year]' for Sentinel data; see https://lta.cr.usgs.gov/sites/default/files/Sentinel_Data_Terms_and_Conditions.pdf",
    "data_source_description": "'Level-2A is generated by the Payload Data Ground Segment using the Sen2Cor processor. Level-2A products are made available to users via the Copernicus Open Access Hub: https://scihub.copernicus.eu/dhus/#/home",
    "data_source_links": [
        "https://sentinel.esa.int/web/sentinel/sentinel-data-access"
    ],
    "update_interval_max": "1 day",
    "update_interval_description": "Uploads are run daily. However, note the temporal resolution.",
    "lag_horizon": "5 days",
    "lag_horizon_description": "Data is available within 24 hours.",
    "temporal_resolution": "5 days",
    "temporal_resolution_description": "string",
    "spatial_resolution_of_raw_data": "100m",
    "interpolation": "near",
    "dimensions_description": "The sole dimension is called \"horizon\" and refers to the forecast horizon in hours. (Only integer horizons are allowed.)",
    "permanence": "true",
    "permanence_description": "Data with timestamp into the future will be update, but remain constant past current timestamp (except for error corrrection).",
    "known_issues": "Updates are irregular.",
    "responsible_organization": "<Your Organization>",
    "properties": {
        "Sector": [
            "Animals/livestock",
            "Transportation/infrastructure",
            "Vegetation/crops",
            "Weather/climate"
        ],
        "Application": [
            "Agriculture"
        ],
        "Domain": [
            "Land surface"
        ],
        "Type": [
            "Data product"
        ],
        "Source": [
            "Satellite",
            "Survey"
        ]
    },
    "spatial_coverage": {
        "Country": [
            "Belgium",
            "Bolivia",
            "France",
            "Germany",
            "India",
            "Indonesia",
            "Luxembourg",
            "Netherlands",
            "Switzerland",
            "Thailand",
            "United Kingdom",
            "United States of America"
        ]
    },
    "latitude_min": "-90",
    "longitude_min": "-180",
    "latitude_max": "90",
    "longitude_max": "180",
    "temporal_min": "2016-03-12T00:00:01.000Z",
    "temporal_max": "2019-07-30T00:00:01.000Z",
    "offering_status": "",
    "contact_person": "John Smith <john.smith@ibm.com>",
    "description_internal": "This data set is not for public dissemination.",
    "description_internal_links": [
            "http://www.ftp.ncep.noaa.gov/data/nccf/com/gfs/prod/"
        ],
    "data_storage_mid_term": "pairsdata.pok.ibm.com:/data/datasets/sentinel2",
    "data_storage_long_term": "Tape",
    "elt_scripts_links": [
            "https://some-place-where-your-code-is-stored.com"
        ],
    "license_information": "Approved"
}'''

data_set_requests_post_success_dict = {
    "name": "High res imagery (ESA Sentinel 2)",
    "category": {
        "id": "1"
    },
    "level": "23",
    "crs": "EPSG:4326",
    "maxLayers": "30",
    "contact_person": "John Smith <john.smith@ibm.com>",
    "name_alternate": "ESA Sentinel 2 Level-2A",
    "rating": "4.0",
    "description_short": "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.",
    "description_long": "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.",
    "description_links": [
        "https://sentinel.esa.int/web/sentinel/missions",
        "https://sentinel.esa.int/documents/247904/685211/Sentinel-2_User_Handbook",
        "https://sentinel.esa.int/web/sentinel/missions/sentinel-2/data-products",
        "https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi"
    ],
    "data_source_name": "European Space Agency Sentinel-2",
    "data_source_attribution": "'Copernicus Sentinel data [Year]' for Sentinel data; see https://lta.cr.usgs.gov/sites/default/files/Sentinel_Data_Terms_and_Conditions.pdf",
    "data_source_description": "'Level-2A is generated by the Payload Data Ground Segment using the Sen2Cor processor. Level-2A products are made available to users via the Copernicus Open Access Hub: https://scihub.copernicus.eu/dhus/#/home",
    "data_source_links": [
        "https://sentinel.esa.int/web/sentinel/sentinel-data-access"
    ],
    "update_interval_max": "1 day",
    "update_interval_description": "Uploads are run daily. However, note the temporal resolution.",
    "lag_horizon": "5 days",
    "lag_horizon_description": "Data is available within 24 hours.",
    "temporal_resolution": "5 days",
    "temporal_resolution_description": "string",
    "spatial_resolution_of_raw_data": "100m",
    "interpolation": "near",
    "dimensions_description": "The sole dimension is called \"horizon\" and refers to the forecast horizon in hours. (Only integer horizons are allowed.)",
    "permanence": "true",
    "permanence_description": "Data with timestamp into the future will be update, but remain constant past current timestamp (except for error corrrection).",
    "known_issues": "Updates are irregular.",
    "responsible_organization": "<Your Organization>",
    "description_internal": "This data set is not for public dissemination.",
    "description_internal_links": [
        "http://www.ftp.ncep.noaa.gov/data/nccf/com/gfs/prod/"
    ],
    "data_storage_mid_term": "pairsdata.pok.ibm.com:/data/datasets/sentinel2",
    "data_storage_long_term": "Tape",
    "elt_scripts_links": [
        "https://some-place-where-your-code-is-stored.com"
    ],
    "license_information": "Approved",
    "properties": {
        "Sector": [
            "Animals/livestock",
            "Transportation/infrastructure",
            "Vegetation/crops",
            "Weather/climate"
        ],
        "Application": [
            "Agriculture"
        ],
        "Domain": [
            "Land surface"
        ],
        "Type": [
            "Data product"
        ],
        "Source": [
            "Satellite",
            "Survey"
        ]
    },
    "spatial_coverage": {
        "Country": [
            "Belgium",
            "Bolivia",
            "France",
            "Germany",
            "India",
            "Indonesia",
            "Luxembourg",
            "Netherlands",
            "Switzerland",
            "Thailand",
            "United Kingdom",
            "United States of America"
        ]
    },
    "latitude_min": "-90",
    "longitude_min": "-180",
    "latitude_max": "90",
    "longitude_max": "180",
    "temporal_min": "2016-03-12T00:00:01.000Z",
    "temporal_max": "2019-07-30T00:00:01.000Z",
    "offering_status": ""
}

#
class DataSetUnitTest(unittest.TestCase):
    
    #
    def setUp(self):
        self.logger = logger
        self.logger.info('setup')
        
        client = cl.Client()
    
    #
    def tearDown(self):
        self.logger.info('teardown')

    #    
    def test_data_set_from_dict(self):
        
        self.logger.info('test_data_set_from_dict')
        
        data_set = catalog.DataSet

        data_set_from_dict = None
            
        got_exception = False

        try:
            data_set_from_dict = data_set.from_dict(data_set_dict)
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)    
        
        self.assertEqual(data_set_from_dict.id, "string")
        self.assertEqual(data_set_from_dict.name, "string")
        self.assertEqual(data_set_from_dict.key, "string")
        self.assertEqual(data_set_from_dict.category.id, 1)
        self.assertEqual(data_set_from_dict.category.name, "Satellite")
        self.assertEqual(data_set_from_dict.level, 0)
        self.assertEqual(data_set_from_dict.crs, "string")
        self.assertEqual(data_set_from_dict.dsource_h_link, "string")
        self.assertEqual(data_set_from_dict.dsource_desc, "string")
        self.assertEqual(data_set_from_dict.status, "Production")
        self.assertEqual(data_set_from_dict.data_origin, "string")
        self.assertEqual(data_set_from_dict.max_layers, 30)
        self.assertEqual(data_set_from_dict.name_alternate, "ESA Sentinel 2 Level-2A")
        self.assertEqual(data_set_from_dict.rating, 4.0)
        self.assertEqual(data_set_from_dict.description_short, "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.")
        self.assertEqual(data_set_from_dict.description_long, "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.")
        self.assertEqual(data_set_from_dict.description_links[0], "https://sentinel.esa.int/web/sentinel/missions")
        self.assertEqual(data_set_from_dict.description_links[1], "https://sentinel.esa.int/documents/247904/685211/Sentinel-2_User_Handbook")
        self.assertEqual(data_set_from_dict.description_links[2], "https://sentinel.esa.int/web/sentinel/missions/sentinel-2/data-products")
        self.assertEqual(data_set_from_dict.description_links[3], "https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi")
        self.assertEqual(data_set_from_dict.data_source_name, "European Space Agency Sentinel-2")
        self.assertEqual(data_set_from_dict.data_source_attribution, "'Copernicus Sentinel data [Year]' for Sentinel data; see https://lta.cr.usgs.gov/sites/default/files/Sentinel_Data_Terms_and_Conditions.pdf")
        self.assertEqual(data_set_from_dict.data_source_description, "'Level-2A is generated by the Payload Data Ground Segment using the Sen2Cor processor. Level-2A products are made available to users via the Copernicus Open Access Hub: https://scihub.copernicus.eu/dhus/#/home")
        self.assertEqual(data_set_from_dict.data_source_links[0], "https://sentinel.esa.int/web/sentinel/sentinel-data-access")
        self.assertEqual(data_set_from_dict.update_interval_max, "1 day")
        self.assertEqual(data_set_from_dict.update_interval_description, "Uploads are run daily. However, note the temporal resolution.")
        self.assertEqual(data_set_from_dict.lag_horizon, "5 days")
        self.assertEqual(data_set_from_dict.lag_horizon_description, "Data is available within 24 hours.")
        self.assertEqual(data_set_from_dict.temporal_resolution, "5 days")
        self.assertEqual(data_set_from_dict.temporal_resolution_description, "string")
        self.assertEqual(data_set_from_dict.spatial_resolution_of_raw_data, "100m")
        self.assertEqual(data_set_from_dict.interpolation, "near")
        self.assertEqual(data_set_from_dict.dimensions_description, "The sole dimension is called \"horizon\" and refers to the forecast horizon in hours. (Only integer horizons are allowed.)")
        self.assertEqual(data_set_from_dict.permanence, True)
        self.assertEqual(data_set_from_dict.permanence_description, "Data with timestamp into the future will be update, but remain constant past current timestamp (except for error corrrection).")
        self.assertEqual(data_set_from_dict.known_issues, "Updates are irregular.")
        self.assertEqual(data_set_from_dict.responsible_organization, "<Your Organization>")
        self.assertEqual(data_set_from_dict.properties.sector[0], "Animals/livestock")
        self.assertEqual(data_set_from_dict.properties.sector[1], "Transportation/infrastructure")
        self.assertEqual(data_set_from_dict.properties.sector[2], "Vegetation/crops")
        self.assertEqual(data_set_from_dict.properties.sector[3], "Weather/climate")
        self.assertEqual(data_set_from_dict.properties.application[0], "Agriculture")
        self.assertEqual(data_set_from_dict.properties.domain[0], "Land surface")
        self.assertEqual(data_set_from_dict.properties.type[0], "Data product")
        self.assertEqual(data_set_from_dict.properties.source[0], "Satellite")
        self.assertEqual(data_set_from_dict.properties.source[1], "Survey")
        self.assertEqual(data_set_from_dict.spatial_coverage.country[0], "Belgium")
        self.assertEqual(data_set_from_dict.spatial_coverage.country[1], "Bolivia")
        self.assertEqual(data_set_from_dict.spatial_coverage.country[2], "France")
        self.assertEqual(data_set_from_dict.spatial_coverage.country[3], "Germany")
        self.assertEqual(data_set_from_dict.spatial_coverage.country[4], "India")
        self.assertEqual(data_set_from_dict.spatial_coverage.country[5], "Indonesia")
        self.assertEqual(data_set_from_dict.spatial_coverage.country[6], "Luxembourg")
        self.assertEqual(data_set_from_dict.spatial_coverage.country[7], "Netherlands")
        self.assertEqual(data_set_from_dict.spatial_coverage.country[8], "Switzerland")
        self.assertEqual(data_set_from_dict.spatial_coverage.country[9], "Thailand")
        self.assertEqual(data_set_from_dict.spatial_coverage.country[10], "United Kingdom")
        self.assertEqual(data_set_from_dict.spatial_coverage.country[11], "United States of America")
        self.assertEqual(data_set_from_dict.latitude_min, -90)
        self.assertEqual(data_set_from_dict.longitude_min, -180)
        self.assertEqual(data_set_from_dict.latitude_max, 90)
        self.assertEqual(data_set_from_dict.longitude_max, 180)
        self.assertEqual(data_set_from_dict.temporal_min, "2016-03-12T00:00:01.000Z")
        self.assertEqual(data_set_from_dict.temporal_max, "2019-07-30T00:00:01.000Z")
        self.assertEqual(data_set_from_dict.offering_status, "")
        self.assertEqual(data_set_from_dict.contact_person, "John Smith <john.smith@ibm.com>")
        self.assertEqual(data_set_from_dict.description_internal, "This data set is not for public dissemination.")
        self.assertEqual(data_set_from_dict.description_internal_links[0], "http://www.ftp.ncep.noaa.gov/data/nccf/com/gfs/prod/")
        self.assertEqual(data_set_from_dict.data_storage_mid_term, "pairsdata.pok.ibm.com:/data/datasets/sentinel2")
        self.assertEqual(data_set_from_dict.data_storage_long_term, "Tape")
        self.assertEqual(data_set_from_dict.elt_scripts_links[0], "https://some-place-where-your-code-is-stored.com")
        self.assertEqual(data_set_from_dict.license_information, "Approved")
        
    #    
    def test_data_set_to_dict(self):
        
        self.logger.info('test_data_set_to_dict')
        
        data_set = catalog.DataSet

        data_set_from_dict = None
        data_set_to_dict   = None
                
        got_exception = False

        try:
            data_set_from_dict = data_set.from_dict(data_set_dict)
            data_set_to_dict = data_set_from_dict.to_dict()
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        self.assertEqual(data_set_to_dict["id"], "string")
        self.assertEqual(data_set_to_dict["name"], "string")
        self.assertEqual(data_set_to_dict["key"], "string")
        self.assertEqual(data_set_to_dict["category"]["id"], 1)
        self.assertEqual(data_set_to_dict["category"]["name"], "Satellite")
        self.assertEqual(data_set_to_dict["level"], 0)
        self.assertEqual(data_set_to_dict["crs"], "string")
        self.assertEqual(data_set_to_dict["dsource_h_link"], "string")
        self.assertEqual(data_set_to_dict["dsource_desc"], "string")
        self.assertEqual(data_set_to_dict["status"], "Production")
        self.assertEqual(data_set_to_dict["data_origin"], "string")
        self.assertEqual(data_set_to_dict["max_layers"], 30)
        self.assertEqual(data_set_to_dict["name_alternate"], "ESA Sentinel 2 Level-2A")
        self.assertEqual(data_set_to_dict["rating"], 4.0)
        self.assertEqual(data_set_to_dict["description_short"], "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.")
        self.assertEqual(data_set_to_dict["description_long"], "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.")
        self.assertEqual(data_set_to_dict["description_links"][0], "https://sentinel.esa.int/web/sentinel/missions")
        self.assertEqual(data_set_to_dict["description_links"][1], "https://sentinel.esa.int/documents/247904/685211/Sentinel-2_User_Handbook")
        self.assertEqual(data_set_to_dict["description_links"][2], "https://sentinel.esa.int/web/sentinel/missions/sentinel-2/data-products")
        self.assertEqual(data_set_to_dict["description_links"][3], "https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi")
        self.assertEqual(data_set_to_dict["data_source_name"], "European Space Agency Sentinel-2")
        self.assertEqual(data_set_to_dict["data_source_attribution"], "'Copernicus Sentinel data [Year]' for Sentinel data; see https://lta.cr.usgs.gov/sites/default/files/Sentinel_Data_Terms_and_Conditions.pdf")
        self.assertEqual(data_set_to_dict["data_source_description"], "'Level-2A is generated by the Payload Data Ground Segment using the Sen2Cor processor. Level-2A products are made available to users via the Copernicus Open Access Hub: https://scihub.copernicus.eu/dhus/#/home")
        self.assertEqual(data_set_to_dict["data_source_links"][0], "https://sentinel.esa.int/web/sentinel/sentinel-data-access")
        self.assertEqual(data_set_to_dict["update_interval_max"], "1 day")
        self.assertEqual(data_set_to_dict["update_interval_description"], "Uploads are run daily. However, note the temporal resolution.")
        self.assertEqual(data_set_to_dict["lag_horizon"], "5 days")
        self.assertEqual(data_set_to_dict["lag_horizon_description"], "Data is available within 24 hours.")
        self.assertEqual(data_set_to_dict["temporal_resolution"], "5 days")
        self.assertEqual(data_set_to_dict["temporal_resolution_description"], "string")
        self.assertEqual(data_set_to_dict["spatial_resolution_of_raw_data"], "100m")
        self.assertEqual(data_set_to_dict["interpolation"], "near")
        self.assertEqual(data_set_to_dict["dimensions_description"], "The sole dimension is called \"horizon\" and refers to the forecast horizon in hours. (Only integer horizons are allowed.)")
        self.assertEqual(data_set_to_dict["permanence"], True)
        self.assertEqual(data_set_to_dict["permanence_description"], "Data with timestamp into the future will be update, but remain constant past current timestamp (except for error corrrection).")
        self.assertEqual(data_set_to_dict["known_issues"], "Updates are irregular.")
        self.assertEqual(data_set_to_dict["responsible_organization"], "<Your Organization>")
        self.assertEqual(data_set_to_dict["properties"]["sector"][0], "Animals/livestock")
        self.assertEqual(data_set_to_dict["properties"]["sector"][1], "Transportation/infrastructure")
        self.assertEqual(data_set_to_dict["properties"]["sector"][2], "Vegetation/crops")
        self.assertEqual(data_set_to_dict["properties"]["sector"][3], "Weather/climate")
        self.assertEqual(data_set_to_dict["properties"]["application"][0], "Agriculture")
        self.assertEqual(data_set_to_dict["properties"]["domain"][0], "Land surface")
        self.assertEqual(data_set_to_dict["properties"]["type"][0], "Data product")
        self.assertEqual(data_set_to_dict["properties"]["source"][0], "Satellite")
        self.assertEqual(data_set_to_dict["properties"]["source"][1], "Survey")
        self.assertEqual(data_set_to_dict["spatial_coverage"]["country"][0], "Belgium")
        self.assertEqual(data_set_to_dict["spatial_coverage"]["country"][1], "Bolivia")
        self.assertEqual(data_set_to_dict["spatial_coverage"]["country"][2], "France")
        self.assertEqual(data_set_to_dict["spatial_coverage"]["country"][3], "Germany")
        self.assertEqual(data_set_to_dict["spatial_coverage"]["country"][4], "India")
        self.assertEqual(data_set_to_dict["spatial_coverage"]["country"][5], "Indonesia")
        self.assertEqual(data_set_to_dict["spatial_coverage"]["country"][6], "Luxembourg")
        self.assertEqual(data_set_to_dict["spatial_coverage"]["country"][7], "Netherlands")
        self.assertEqual(data_set_to_dict["spatial_coverage"]["country"][8], "Switzerland")
        self.assertEqual(data_set_to_dict["spatial_coverage"]["country"][9], "Thailand")
        self.assertEqual(data_set_to_dict["spatial_coverage"]["country"][10], "United Kingdom")
        self.assertEqual(data_set_to_dict["spatial_coverage"]["country"][11], "United States of America")
        self.assertEqual(data_set_to_dict["latitude_min"], -90)
        self.assertEqual(data_set_to_dict["longitude_min"], -180)
        self.assertEqual(data_set_to_dict["latitude_max"], 90)
        self.assertEqual(data_set_to_dict["longitude_max"], 180)
        self.assertEqual(data_set_to_dict["temporal_min"], "2016-03-12T00:00:01.000Z")
        self.assertEqual(data_set_to_dict["temporal_max"], "2019-07-30T00:00:01.000Z")
        self.assertEqual(data_set_to_dict["offering_status"], "")
        self.assertEqual(data_set_to_dict["contact_person"], "John Smith <john.smith@ibm.com>")
        self.assertEqual(data_set_to_dict["description_internal"], "This data set is not for public dissemination.")
        self.assertEqual(data_set_to_dict["description_internal_links"][0], "http://www.ftp.ncep.noaa.gov/data/nccf/com/gfs/prod/")
        self.assertEqual(data_set_to_dict["data_storage_mid_term"], "pairsdata.pok.ibm.com:/data/datasets/sentinel2")
        self.assertEqual(data_set_to_dict["data_storage_long_term"], "Tape")
        self.assertEqual(data_set_to_dict["elt_scripts_links"][0], "https://some-place-where-your-code-is-stored.com")
        self.assertEqual(data_set_to_dict["license_information"], "Approved")
        
    #    
    def test_data_set_to_dict_data_set_post(self):
        
        self.logger.info('test_data_set_to_dict_data_set_post')
        
        data_set = catalog.DataSet

        data_set_from_dict2 = None
        data_set_to_dict_data_set_post   = None
                
        got_exception = False

        try:
            data_set_from_dict2 = data_set.from_dict(data_set_dict)
            data_set_to_dict_data_set_post = data_set_from_dict2.to_dict_data_set_post()
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        
        self.assertEqual(data_set_to_dict_data_set_post["name"], "string")
        self.assertEqual(data_set_to_dict_data_set_post["category"]["id"], 1)
        self.assertEqual(data_set_to_dict_data_set_post["category"]["name"], "Satellite")
        self.assertEqual(data_set_to_dict_data_set_post["maxLayers"], 30)
        self.assertEqual(data_set_to_dict_data_set_post["name_alternate"], "ESA Sentinel 2 Level-2A")
        self.assertEqual(data_set_to_dict_data_set_post["rating"], 4.0)
        self.assertEqual(data_set_to_dict_data_set_post["description_short"], "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.")
        self.assertEqual(data_set_to_dict_data_set_post["description_long"], "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.")
        self.assertEqual(data_set_to_dict_data_set_post["description_links"][0], "https://sentinel.esa.int/web/sentinel/missions")
        self.assertEqual(data_set_to_dict_data_set_post["description_links"][1], "https://sentinel.esa.int/documents/247904/685211/Sentinel-2_User_Handbook")
        self.assertEqual(data_set_to_dict_data_set_post["description_links"][2], "https://sentinel.esa.int/web/sentinel/missions/sentinel-2/data-products")
        self.assertEqual(data_set_to_dict_data_set_post["description_links"][3], "https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi")
        self.assertEqual(data_set_to_dict_data_set_post["data_source_name"], "European Space Agency Sentinel-2")
        self.assertEqual(data_set_to_dict_data_set_post["data_source_attribution"], "'Copernicus Sentinel data [Year]' for Sentinel data; see https://lta.cr.usgs.gov/sites/default/files/Sentinel_Data_Terms_and_Conditions.pdf")
        self.assertEqual(data_set_to_dict_data_set_post["data_source_description"], "'Level-2A is generated by the Payload Data Ground Segment using the Sen2Cor processor. Level-2A products are made available to users via the Copernicus Open Access Hub: https://scihub.copernicus.eu/dhus/#/home")
        self.assertEqual(data_set_to_dict_data_set_post["data_source_links"][0], "https://sentinel.esa.int/web/sentinel/sentinel-data-access")
        self.assertEqual(data_set_to_dict_data_set_post["update_interval_max"], "1 day")
        self.assertEqual(data_set_to_dict_data_set_post["update_interval_description"], "Uploads are run daily. However, note the temporal resolution.")
        self.assertEqual(data_set_to_dict_data_set_post["lag_horizon"], "5 days")
        self.assertEqual(data_set_to_dict_data_set_post["lag_horizon_description"], "Data is available within 24 hours.")
        self.assertEqual(data_set_to_dict_data_set_post["temporal_resolution"], "5 days")
        self.assertEqual(data_set_to_dict_data_set_post["temporal_resolution_description"], "string")
        self.assertEqual(data_set_to_dict_data_set_post["spatial_resolution_of_raw_data"], "100m")
        self.assertEqual(data_set_to_dict_data_set_post["interpolation"], "near")
        self.assertEqual(data_set_to_dict_data_set_post["dimensions_description"], "The sole dimension is called \"horizon\" and refers to the forecast horizon in hours. (Only integer horizons are allowed.)")
        self.assertEqual(data_set_to_dict_data_set_post["permanence"], True)
        self.assertEqual(data_set_to_dict_data_set_post["permanence_description"], "Data with timestamp into the future will be update, but remain constant past current timestamp (except for error corrrection).")
        self.assertEqual(data_set_to_dict_data_set_post["known_issues"], "Updates are irregular.")
        self.assertEqual(data_set_to_dict_data_set_post["responsible_organization"], "<Your Organization>")
        self.assertEqual(data_set_to_dict_data_set_post["properties"]["sector"][0], "Animals/livestock")
        self.assertEqual(data_set_to_dict_data_set_post["properties"]["sector"][1], "Transportation/infrastructure")
        self.assertEqual(data_set_to_dict_data_set_post["properties"]["sector"][2], "Vegetation/crops")
        self.assertEqual(data_set_to_dict_data_set_post["properties"]["sector"][3], "Weather/climate")
        self.assertEqual(data_set_to_dict_data_set_post["properties"]["application"][0], "Agriculture")
        self.assertEqual(data_set_to_dict_data_set_post["properties"]["domain"][0], "Land surface")
        self.assertEqual(data_set_to_dict_data_set_post["properties"]["type"][0], "Data product")
        self.assertEqual(data_set_to_dict_data_set_post["properties"]["source"][0], "Satellite")
        self.assertEqual(data_set_to_dict_data_set_post["properties"]["source"][1], "Survey")
        self.assertEqual(data_set_to_dict_data_set_post["spatial_coverage"]["country"][0], "Belgium")
        self.assertEqual(data_set_to_dict_data_set_post["spatial_coverage"]["country"][1], "Bolivia")
        self.assertEqual(data_set_to_dict_data_set_post["spatial_coverage"]["country"][2], "France")
        self.assertEqual(data_set_to_dict_data_set_post["spatial_coverage"]["country"][3], "Germany")
        self.assertEqual(data_set_to_dict_data_set_post["spatial_coverage"]["country"][4], "India")
        self.assertEqual(data_set_to_dict_data_set_post["spatial_coverage"]["country"][5], "Indonesia")
        self.assertEqual(data_set_to_dict_data_set_post["spatial_coverage"]["country"][6], "Luxembourg")
        self.assertEqual(data_set_to_dict_data_set_post["spatial_coverage"]["country"][7], "Netherlands")
        self.assertEqual(data_set_to_dict_data_set_post["spatial_coverage"]["country"][8], "Switzerland")
        self.assertEqual(data_set_to_dict_data_set_post["spatial_coverage"]["country"][9], "Thailand")
        self.assertEqual(data_set_to_dict_data_set_post["spatial_coverage"]["country"][10], "United Kingdom")
        self.assertEqual(data_set_to_dict_data_set_post["spatial_coverage"]["country"][11], "United States of America")
        self.assertEqual(data_set_to_dict_data_set_post["latitude_min"], -90)
        self.assertEqual(data_set_to_dict_data_set_post["longitude_min"], -180)
        self.assertEqual(data_set_to_dict_data_set_post["latitude_max"], 90)
        self.assertEqual(data_set_to_dict_data_set_post["longitude_max"], 180)
        self.assertEqual(data_set_to_dict_data_set_post["temporal_min"], "2016-03-12T00:00:01.000Z")
        self.assertEqual(data_set_to_dict_data_set_post["temporal_max"], "2019-07-30T00:00:01.000Z")
        self.assertEqual(data_set_to_dict_data_set_post["level"], 0)
        self.assertEqual(data_set_to_dict_data_set_post["crs"], "string")
        self.assertEqual(data_set_to_dict_data_set_post["offering_status"], "")
    
    #    
    def test_data_set_to_dict_data_set_put(self):
        
        self.logger.info('test_data_set_to_dict_data_set_put')
        
        data_set = catalog.DataSet

        data_set_from_dict3 = None
        data_set_to_dict_data_set_put   = None
                
        got_exception = False

        try:
            data_set_from_dict3 = data_set.from_dict(data_set_dict)
            data_set_to_dict_data_set_put = data_set_from_dict3.to_dict_data_set_put()
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        
        self.assertEqual(data_set_to_dict_data_set_put["name"], "string")
        self.assertEqual(data_set_to_dict_data_set_put["category"]["id"], 1)
        self.assertEqual(data_set_to_dict_data_set_put["category"]["name"], "Satellite")
        self.assertEqual(data_set_to_dict_data_set_put["maxLayers"], 30)
        self.assertEqual(data_set_to_dict_data_set_put["name_alternate"], "ESA Sentinel 2 Level-2A")
        self.assertEqual(data_set_to_dict_data_set_put["rating"], 4.0)
        self.assertEqual(data_set_to_dict_data_set_put["description_short"], "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.")
        self.assertEqual(data_set_to_dict_data_set_put["description_long"], "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.")
        self.assertEqual(data_set_to_dict_data_set_put["description_links"][0], "https://sentinel.esa.int/web/sentinel/missions")
        self.assertEqual(data_set_to_dict_data_set_put["description_links"][1], "https://sentinel.esa.int/documents/247904/685211/Sentinel-2_User_Handbook")
        self.assertEqual(data_set_to_dict_data_set_put["description_links"][2], "https://sentinel.esa.int/web/sentinel/missions/sentinel-2/data-products")
        self.assertEqual(data_set_to_dict_data_set_put["description_links"][3], "https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi")
        self.assertEqual(data_set_to_dict_data_set_put["data_source_name"], "European Space Agency Sentinel-2")
        self.assertEqual(data_set_to_dict_data_set_put["data_source_attribution"], "'Copernicus Sentinel data [Year]' for Sentinel data; see https://lta.cr.usgs.gov/sites/default/files/Sentinel_Data_Terms_and_Conditions.pdf")
        self.assertEqual(data_set_to_dict_data_set_put["data_source_description"], "'Level-2A is generated by the Payload Data Ground Segment using the Sen2Cor processor. Level-2A products are made available to users via the Copernicus Open Access Hub: https://scihub.copernicus.eu/dhus/#/home")
        self.assertEqual(data_set_to_dict_data_set_put["data_source_links"][0], "https://sentinel.esa.int/web/sentinel/sentinel-data-access")
        self.assertEqual(data_set_to_dict_data_set_put["update_interval_max"], "1 day")
        self.assertEqual(data_set_to_dict_data_set_put["update_interval_description"], "Uploads are run daily. However, note the temporal resolution.")
        self.assertEqual(data_set_to_dict_data_set_put["lag_horizon"], "5 days")
        self.assertEqual(data_set_to_dict_data_set_put["lag_horizon_description"], "Data is available within 24 hours.")
        self.assertEqual(data_set_to_dict_data_set_put["temporal_resolution"], "5 days")
        self.assertEqual(data_set_to_dict_data_set_put["temporal_resolution_description"], "string")
        self.assertEqual(data_set_to_dict_data_set_put["spatial_resolution_of_raw_data"], "100m")
        self.assertEqual(data_set_to_dict_data_set_put["interpolation"], "near")
        self.assertEqual(data_set_to_dict_data_set_put["dimensions_description"], "The sole dimension is called \"horizon\" and refers to the forecast horizon in hours. (Only integer horizons are allowed.)")
        self.assertEqual(data_set_to_dict_data_set_put["permanence"], True)
        self.assertEqual(data_set_to_dict_data_set_put["permanence_description"], "Data with timestamp into the future will be update, but remain constant past current timestamp (except for error corrrection).")
        self.assertEqual(data_set_to_dict_data_set_put["known_issues"], "Updates are irregular.")
        self.assertEqual(data_set_to_dict_data_set_put["responsible_organization"], "<Your Organization>")
        self.assertEqual(data_set_to_dict_data_set_put["properties"]["sector"][0], "Animals/livestock")
        self.assertEqual(data_set_to_dict_data_set_put["properties"]["sector"][1], "Transportation/infrastructure")
        self.assertEqual(data_set_to_dict_data_set_put["properties"]["sector"][2], "Vegetation/crops")
        self.assertEqual(data_set_to_dict_data_set_put["properties"]["sector"][3], "Weather/climate")
        self.assertEqual(data_set_to_dict_data_set_put["properties"]["application"][0], "Agriculture")
        self.assertEqual(data_set_to_dict_data_set_put["properties"]["domain"][0], "Land surface")
        self.assertEqual(data_set_to_dict_data_set_put["properties"]["type"][0], "Data product")
        self.assertEqual(data_set_to_dict_data_set_put["properties"]["source"][0], "Satellite")
        self.assertEqual(data_set_to_dict_data_set_put["properties"]["source"][1], "Survey")
        self.assertEqual(data_set_to_dict_data_set_put["spatial_coverage"]["country"][0], "Belgium")
        self.assertEqual(data_set_to_dict_data_set_put["spatial_coverage"]["country"][1], "Bolivia")
        self.assertEqual(data_set_to_dict_data_set_put["spatial_coverage"]["country"][2], "France")
        self.assertEqual(data_set_to_dict_data_set_put["spatial_coverage"]["country"][3], "Germany")
        self.assertEqual(data_set_to_dict_data_set_put["spatial_coverage"]["country"][4], "India")
        self.assertEqual(data_set_to_dict_data_set_put["spatial_coverage"]["country"][5], "Indonesia")
        self.assertEqual(data_set_to_dict_data_set_put["spatial_coverage"]["country"][6], "Luxembourg")
        self.assertEqual(data_set_to_dict_data_set_put["spatial_coverage"]["country"][7], "Netherlands")
        self.assertEqual(data_set_to_dict_data_set_put["spatial_coverage"]["country"][8], "Switzerland")
        self.assertEqual(data_set_to_dict_data_set_put["spatial_coverage"]["country"][9], "Thailand")
        self.assertEqual(data_set_to_dict_data_set_put["spatial_coverage"]["country"][10], "United Kingdom")
        self.assertEqual(data_set_to_dict_data_set_put["spatial_coverage"]["country"][11], "United States of America")
        self.assertEqual(data_set_to_dict_data_set_put["latitude_min"], -90)
        self.assertEqual(data_set_to_dict_data_set_put["longitude_min"], -180)
        self.assertEqual(data_set_to_dict_data_set_put["latitude_max"], 90)
        self.assertEqual(data_set_to_dict_data_set_put["longitude_max"], 180)
        self.assertEqual(data_set_to_dict_data_set_put["temporal_min"], "2016-03-12T00:00:01.000Z")
        self.assertEqual(data_set_to_dict_data_set_put["temporal_max"], "2019-07-30T00:00:01.000Z")
        self.assertEqual(data_set_to_dict_data_set_put["contact_person"], "John Smith <john.smith@ibm.com>")
        self.assertEqual(data_set_to_dict_data_set_put["description_internal"], "This data set is not for public dissemination.")
        self.assertEqual(data_set_to_dict_data_set_put["description_internal_links"][0], "http://www.ftp.ncep.noaa.gov/data/nccf/com/gfs/prod/")
        self.assertEqual(data_set_to_dict_data_set_put["data_storage_mid_term"], "pairsdata.pok.ibm.com:/data/datasets/sentinel2")
        self.assertEqual(data_set_to_dict_data_set_put["data_storage_long_term"], "Tape")
        self.assertEqual(data_set_to_dict_data_set_put["elt_scripts_links"][0], "https://some-place-where-your-code-is-stored.com")
        self.assertEqual(data_set_to_dict_data_set_put["license_information"], "Approved")

    #
    def test_data_set_from_json(self):
        
        self.logger.info('test_data_set_from_json')
        
        got_exception = False

        try:
            data_set_from_json = catalog.data_set_from_json(data_set_str)
        except Exception as ex:
            self.logger.info(ex)
            got_exception = True

        self.assertFalse(got_exception)
        self.assertEqual(data_set_from_json.id, "string")
        self.assertEqual(data_set_from_json.name, "string")
        self.assertEqual(data_set_from_json.key, "string")
        self.assertEqual(data_set_from_json.category.id, 1)
        self.assertEqual(data_set_from_json.category.name, "Satellite")
        self.assertEqual(data_set_from_json.level, 0)
        self.assertEqual(data_set_from_json.crs, "string")
        self.assertEqual(data_set_from_json.dsource_h_link, "string")
        self.assertEqual(data_set_from_json.dsource_desc, "string")
        self.assertEqual(data_set_from_json.status, "Production")
        self.assertEqual(data_set_from_json.data_origin, "string")
        self.assertEqual(data_set_from_json.max_layers, 30)
        self.assertEqual(data_set_from_json.name_alternate, "ESA Sentinel 2 Level-2A")
        self.assertEqual(data_set_from_json.rating, 4.0)
        self.assertEqual(data_set_from_json.description_short, "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.")
        self.assertEqual(data_set_from_json.description_long, "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.")
        self.assertEqual(data_set_from_json.description_links[0], "https://sentinel.esa.int/web/sentinel/missions")
        self.assertEqual(data_set_from_json.description_links[1], "https://sentinel.esa.int/documents/247904/685211/Sentinel-2_User_Handbook")
        self.assertEqual(data_set_from_json.description_links[2], "https://sentinel.esa.int/web/sentinel/missions/sentinel-2/data-products")
        self.assertEqual(data_set_from_json.description_links[3], "https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi")
        self.assertEqual(data_set_from_json.data_source_name, "European Space Agency Sentinel-2")
        self.assertEqual(data_set_from_json.data_source_attribution, "'Copernicus Sentinel data [Year]' for Sentinel data; see https://lta.cr.usgs.gov/sites/default/files/Sentinel_Data_Terms_and_Conditions.pdf")
        self.assertEqual(data_set_from_json.data_source_description, "'Level-2A is generated by the Payload Data Ground Segment using the Sen2Cor processor. Level-2A products are made available to users via the Copernicus Open Access Hub: https://scihub.copernicus.eu/dhus/#/home")
        self.assertEqual(data_set_from_json.data_source_links[0], "https://sentinel.esa.int/web/sentinel/sentinel-data-access")
        self.assertEqual(data_set_from_json.update_interval_max, "1 day")
        self.assertEqual(data_set_from_json.update_interval_description, "Uploads are run daily. However, note the temporal resolution.")
        self.assertEqual(data_set_from_json.lag_horizon, "5 days")
        self.assertEqual(data_set_from_json.lag_horizon_description, "Data is available within 24 hours.")
        self.assertEqual(data_set_from_json.temporal_resolution, "5 days")
        self.assertEqual(data_set_from_json.temporal_resolution_description, "string")
        self.assertEqual(data_set_from_json.spatial_resolution_of_raw_data, "100m")
        self.assertEqual(data_set_from_json.interpolation, "near")
        self.assertEqual(data_set_from_json.dimensions_description, "The sole dimension is called \"horizon\" and refers to the forecast horizon in hours. (Only integer horizons are allowed.)")
        self.assertEqual(data_set_from_json.permanence, True)
        self.assertEqual(data_set_from_json.permanence_description, "Data with timestamp into the future will be update, but remain constant past current timestamp (except for error corrrection).")
        self.assertEqual(data_set_from_json.known_issues, "Updates are irregular.")
        self.assertEqual(data_set_from_json.responsible_organization, "<Your Organization>")
        self.assertEqual(data_set_from_json.properties.sector[0], "Animals/livestock")
        self.assertEqual(data_set_from_json.properties.sector[1], "Transportation/infrastructure")
        self.assertEqual(data_set_from_json.properties.sector[2], "Vegetation/crops")
        self.assertEqual(data_set_from_json.properties.sector[3], "Weather/climate")
        self.assertEqual(data_set_from_json.properties.application[0], "Agriculture")
        self.assertEqual(data_set_from_json.properties.domain[0], "Land surface")
        self.assertEqual(data_set_from_json.properties.type[0], "Data product")
        self.assertEqual(data_set_from_json.properties.source[0], "Satellite")
        self.assertEqual(data_set_from_json.properties.source[1], "Survey")
        self.assertEqual(data_set_from_json.spatial_coverage.country[0], "Belgium")
        self.assertEqual(data_set_from_json.spatial_coverage.country[1], "Bolivia")
        self.assertEqual(data_set_from_json.spatial_coverage.country[2], "France")
        self.assertEqual(data_set_from_json.spatial_coverage.country[3], "Germany")
        self.assertEqual(data_set_from_json.spatial_coverage.country[4], "India")
        self.assertEqual(data_set_from_json.spatial_coverage.country[5], "Indonesia")
        self.assertEqual(data_set_from_json.spatial_coverage.country[6], "Luxembourg")
        self.assertEqual(data_set_from_json.spatial_coverage.country[7], "Netherlands")
        self.assertEqual(data_set_from_json.spatial_coverage.country[8], "Switzerland")
        self.assertEqual(data_set_from_json.spatial_coverage.country[9], "Thailand")
        self.assertEqual(data_set_from_json.spatial_coverage.country[10], "United Kingdom")
        self.assertEqual(data_set_from_json.spatial_coverage.country[11], "United States of America")
        self.assertEqual(data_set_from_json.latitude_min, -90)
        self.assertEqual(data_set_from_json.longitude_min, -180)
        self.assertEqual(data_set_from_json.latitude_max, 90)
        self.assertEqual(data_set_from_json.longitude_max, 180)
        self.assertEqual(data_set_from_json.temporal_min, "2016-03-12T00:00:01.000Z")
        self.assertEqual(data_set_from_json.temporal_max, "2019-07-30T00:00:01.000Z")
        self.assertEqual(data_set_from_json.offering_status, "")
        self.assertEqual(data_set_from_json.contact_person, "John Smith <john.smith@ibm.com>")
        self.assertEqual(data_set_from_json.description_internal, "This data set is not for public dissemination.")
        self.assertEqual(data_set_from_json.description_internal_links[0], "http://www.ftp.ncep.noaa.gov/data/nccf/com/gfs/prod/")
        self.assertEqual(data_set_from_json.data_storage_mid_term, "pairsdata.pok.ibm.com:/data/datasets/sentinel2")
        self.assertEqual(data_set_from_json.data_storage_long_term, "Tape")
        self.assertEqual(data_set_from_json.elt_scripts_links[0], "https://some-place-where-your-code-is-stored.com")
        self.assertEqual(data_set_from_json.license_information, "Approved")
 
    #
    def test_data_set_to_json(self):
        
        self.logger.info('test_data_set_to_json')
        
        got_exception = False
        
        try:
            data_set_from_json = catalog.data_set_from_json(data_set_str)
            data_set_to_json = catalog.data_set_to_json(data_set_from_json)
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
    
    #
    def test_data_set_to_json_data_set_post(self):
        
        self.logger.info('test_data_set_to_json_data_set_post')
        
        got_exception = False
        
        try:
            data_set_from_json2 = catalog.data_set_from_json(data_set_str)
            data_set_to_json_data_set_post = catalog.data_set_to_json_post(data_set_from_json2)
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
    
    #
    def test_data_set_to_json_data_set_put(self):
        
        self.logger.info('test_data_set_to_json_data_set_put')
        
        got_exception = False
        
        try:
            data_set_from_json3 = catalog.data_set_from_json(data_set_str)
            data_set_to_json_data_set_put = catalog.data_set_to_json_put(data_set_from_json3)
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        
    #
    def test_data_set_display(self):
        
        self.logger.info('test_data_set_display')
        
        got_exception = False
        
        try:
            data_set_from_json4 = catalog.data_set_from_json(data_set_str)
            df = data_set_from_json4.display()
        except Exception as ex:
            got_exception = True
        
        self.assertFalse(got_exception)
        
        self.assertTrue(isinstance(df, pd.DataFrame))
        self.assertTrue(df.at[0,'id'], "string")
        self.assertTrue(df.at[0,'name'], "string")
        self.assertTrue(df.at[0,'description_short'], "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.")
        self.assertTrue(df.at[0,'description_long'], "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.")

        got_exception = False 
        
        try:
            data_set_from_json5 = catalog.data_set_from_json(data_set_str)
            df = data_set_from_json5.display(columns = ['id', 'latitude_min', 'notacolumn'])
        except Exception as ex:
            got_exception = True
        
        self.assertFalse(got_exception)
        self.assertTrue(df.at[0,'id'], "string")
        self.assertTrue(df.at[0,'latitude_min'], -90)
        self.assertTrue(df.at[0, 'notacolumn'], "NaN")  
    
    # mocked_data_set_requests_get
    @mock.patch('ibmpairs.client.Client.get', 
                side_effect=mocked_data_set_requests_get
               )
    def test_data_set_get(self, mock_get):
        
        self.logger.info('test_data_set_get: success')
        
        ds = catalog.DataSet()
                        
        got_exception = False

        try:
            result = ds.get(id = "1")
        except Exception as ex:
            got_exception = True
            
        self.assertFalse(got_exception)
        
        self.assertEqual(result.id, "string")
        self.assertEqual(result.name_alternate, "ESA Sentinel 2 Level-2A")
        
        self.logger.info('test_data_set_get: id already in object')
        
        ds5 = catalog.DataSet()
                        
        got_exception5 = False

        try:
            ds5.id = "1"
            result = ds5.get()
        except Exception as ex:
            got_exception5 = True
            
        self.assertFalse(got_exception5)
        
        self.logger.info('test_data_set_get: fail 404')
        
        ds2 = catalog.DataSet()
                        
        got_exception2 = False

        try:
            result = ds2.get(id = "2")
        except Exception as ex:
            got_exception2 = True
            self.assertEqual(str(ex), "The GET request call to https://pairs.res.ibm.com/v2/datasets/2 failed with status code: 404, message: failed.")
            
        self.assertTrue(got_exception2)
        
        self.logger.info('test_data_set_get: fail server error')
        
        ds3 = catalog.DataSet()
                        
        got_exception3 = False

        try:
            result = ds3.get(id = "3")
        except Exception as ex:
            got_exception3 = True
            self.assertEqual(str(ex), "The GET request to https://pairs.res.ibm.com/v2/datasets/3 encountered an unspecified error contacting the server; the request was unsuccessful, error message: __init__() got an unexpected keyword argument 'status'")

        self.assertTrue(got_exception3)
        
        self.logger.info('test_data_set_get: fail no id')
        
        ds4 = catalog.DataSet()
                        
        got_exception4 = False

        try:
            result = ds4.get()
        except Exception as ex:
            got_exception4 = True
            self.assertEqual(str(ex), "The DataSet object has no ID set and none was provided.")

        self.assertTrue(got_exception4)
        
        self.logger.info('test_data_set_get: helper, success')
                        
        got_exception6 = False

        try:
            result = catalog.get_data_set(id = "1")
        except Exception as ex:
            got_exception6 = True
            
        self.assertFalse(got_exception6)
        
        self.assertEqual(result.id, "string")
        self.assertEqual(result.name_alternate, "ESA Sentinel 2 Level-2A")
        
    # mocked_data_set_requests_post
    @mock.patch('ibmpairs.client.Client.post', 
                side_effect=mocked_data_set_requests_post
               )
    def test_data_set_create(self, mock_post):
        
        self.logger.info('test_data_set_create: success')
        
        got_exception = False

        try:
            data_set_create = catalog.data_set_from_json(data_set_requests_post_success_dict)
            data_set_create.create()
        except Exception as ex:
            self.logger.info(ex)        
            got_exception = True
            
        self.assertFalse(got_exception)
        self.assertEqual(data_set_create.data_set_response.data_set_id, "0")
        self.assertEqual(data_set_create.data_set_response.status, 0)
        self.assertEqual(data_set_create.data_set_response.message, "string")
        
        self.logger.info('test_data_set_create: fail 404')
        
        got_exception2 = False

        try:
            data_set_create2 = catalog.data_set_from_json(data_set_requests_post_success_dict)
            data_set_create2.name = "string2"
            data_set_create2.create()
        except Exception as ex:
            self.logger.info(ex)
            self.assertEqual(str(ex), "The POST request call to https://pairs.res.ibm.com/v2/datasets/ failed with status code: 404, message: Error: 404 Not Found.")
            got_exception2 = True
            
        self.assertTrue(got_exception2)
        self.assertEqual(data_set_create2.data_set_response.message, "Error: 404 Not Found")
        
        self.logger.info('test_data_set_create: fail server error')
        
        got_exception3 = False

        try:
            data_set_create3 = catalog.data_set_from_json(data_set_requests_post_success_dict)
            data_set_create3.name = "string3"
            data_set_create3.create()
        except Exception as ex:
            self.logger.info(ex)
            self.assertEqual(str(ex), "The POST request to https://pairs.res.ibm.com/v2/datasets/ encountered an unspecified error contacting the server; the request was unsuccessful, error message: __init__() got an unexpected keyword argument 'status'")
            got_exception3 = True
            
        self.assertTrue(got_exception3)
        
        self.logger.info('test_data_set_create: helper, success')
        
        got_exception4 = False

        try:
            data_set_create4 = catalog.data_set_from_json(data_set_requests_post_success_dict)
            helper = catalog.create_data_set(data_set = data_set_create4)
        except Exception as ex:
            self.logger.info(ex)        
            got_exception4 = True
            
        self.assertFalse(got_exception4)
        self.assertEqual(helper.data_set_response.data_set_id, "0")
        self.assertEqual(helper.data_set_response.status, 0)
        self.assertEqual(helper.data_set_response.message, "string")
        
    # mocked_data_set_requests_put
    @mock.patch('ibmpairs.client.Client.put', 
                side_effect=mocked_data_set_requests_put
               )
    def test_data_set_update(self, mock_put):
        
        self.logger.info('test_data_set_update: success')
        
        got_exception = False

        try:
            data_set_update = catalog.data_set_from_json(data_set_requests_post_success_dict)
            data_set_update.update(id = 1)
        except Exception as ex:
            self.logger.info(ex)        
            got_exception = True
            
        self.assertFalse(got_exception)
        self.assertEqual(data_set_update.data_set_response.data_set_id, "0")
        self.assertEqual(data_set_update.data_set_response.status, 0)
        self.assertEqual(data_set_update.data_set_response.message, "string")
        
        self.logger.info('test_data_set_update: id already in object')
            
        got_exception5 = False

        try:
            data_set_update5 = catalog.data_set_from_json(data_set_requests_post_success_dict)
            data_set_update5.id = "1"
            data_set_update5.update()
        except Exception as ex:
            self.logger.info(ex)        
            got_exception5 = True
            
        self.assertFalse(got_exception5)
        
        self.logger.info('test_data_set_update: fail 404')
        
        got_exception = False

        try:
            data_set_update2 = catalog.data_set_from_json(data_set_requests_post_success_dict)
            data_set_update2.name = "string2"
            data_set_update2.update(id = 2)
        except Exception as ex:
            self.logger.info(ex)
            self.assertEqual(str(ex), "The PUT request call to https://pairs.res.ibm.com/v2/datasets/2 failed with status code: 404, message: Error: 404 Not Found.")
            got_exception = True
            
        self.assertTrue(got_exception)
        self.assertEqual(data_set_update2.data_set_response.message, "Error: 404 Not Found")
        
        self.logger.info('test_data_set_update: fail server error')
        
        got_exception = False

        try:
            data_set_update3 = catalog.data_set_from_json(data_set_requests_post_success_dict)
            data_set_update3.name = "string3"
            data_set_update3.update(id = 3)
        except Exception as ex:
            self.logger.info(ex)
            self.assertEqual(str(ex), "The PUT request to https://pairs.res.ibm.com/v2/datasets/3 encountered an unspecified error contacting the server; the request was unsuccessful, error message: __init__() got an unexpected keyword argument 'status'")
            got_exception = True
            
        self.assertTrue(got_exception)
        
        self.logger.info('test_data_set_get: fail no id')
        
        got_exception4 = False

        try:
            data_set_update4 = catalog.data_set_from_json(data_set_requests_post_success_dict)
            data_set_update4.update()
        except Exception as ex:
            self.logger.info(ex)        
            got_exception4 = True
            self.assertEqual(str(ex), "The DataSet object has no ID set and none was provided.")

        self.assertTrue(got_exception4)
        
        self.logger.info('test_data_set_update: helper, success')
        
        got_exception6 = False

        try:
            data_set_update6 = catalog.data_set_from_json(data_set_requests_post_success_dict)
            catalog.update_data_set(data_set = data_set_update6,
                                    id       = 1)
        except Exception as ex:
            self.logger.info(ex)        
            got_exception6 = True
            
        self.assertFalse(got_exception6)
        self.assertEqual(data_set_update6.data_set_response.data_set_id, "0")
        self.assertEqual(data_set_update6.data_set_response.status, 0)
        self.assertEqual(data_set_update6.data_set_response.message, "string")

    # mocked_data_set_requests_delete
    @mock.patch('ibmpairs.client.Client.delete', 
                side_effect=mocked_data_set_requests_delete
               )
    def test_data_set_delete(self, mock_delete):
        
        self.logger.info('test_data_set_delete: success')
        
        got_exception = False

        try:
            data_set_delete = catalog.DataSet()
            data_set_delete.delete(id = 1)
        except Exception as ex:
            self.logger.info(ex)        
            got_exception = True
            
        self.assertFalse(got_exception)
        self.assertEqual(data_set_delete.data_set_response.data_set_id, "1")
        self.assertEqual(data_set_delete.data_set_response.status, 0)
        self.assertEqual(data_set_delete.data_set_response.message, "string")
        
        self.logger.info('test_data_set_delete: hard delete')
            
        got_exception5 = False

        try:
            data_set_delete5 = catalog.DataSet()
            data_set_delete5.delete(id = 2,
                                    hard_delete = True)
        except Exception as ex:
            self.logger.info(ex)        
            got_exception5 = True
            
        self.assertFalse(got_exception5)
        
        self.logger.info('test_data_set_delete: fail 404')
        
        got_exception = False

        try:
            data_set_delete2 = catalog.DataSet()
            data_set_delete2.delete(id = 3)
        except Exception as ex:
            self.logger.info(ex)
            self.assertEqual(str(ex), "The DELETE request call to https://pairs.res.ibm.com/v2/datasets/3 failed with status code: 404, message: Error: 404 Not Found.")
            got_exception = True
            
        self.assertTrue(got_exception)
        self.assertEqual(data_set_delete2.data_set_response.message, "Error: 404 Not Found")
        
        self.logger.info('test_data_set_delete: fail server error')
        
        got_exception = False

        try:
            data_set_delete3 = catalog.DataSet()
            data_set_delete3.delete(id = 4)
        except Exception as ex:
            self.logger.info(ex)
            self.assertEqual(str(ex), "The DELETE request to https://pairs.res.ibm.com/v2/datasets/4 encountered an unspecified error contacting the server; the request was unsuccessful, error message: __init__() got an unexpected keyword argument 'status'")
            got_exception = True
            
        self.assertTrue(got_exception)
        
        self.logger.info('test_data_set_get: fail no id')
        
        got_exception4 = False

        try:
            data_set_delete4 = catalog.DataSet()
            data_set_delete4.delete()
        except Exception as ex:
            self.logger.info(ex)        
            got_exception4 = True
            self.assertEqual(str(ex), "delete() missing 1 required positional argument: 'id'")

        self.assertTrue(got_exception4)
        
        self.logger.info('test_data_set_delete: helper, success')
        
        got_exception6 = False

        try:
            data_set_delete6 = catalog.DataSet()
            helper = catalog.delete_data_set(id = 1)
        except Exception as ex:
            self.logger.info(ex)        
            got_exception6 = True
            
        self.assertFalse(got_exception6)
        self.assertEqual(helper.data_set_response.data_set_id, "1")
        self.assertEqual(helper.data_set_response.status, 0)
        self.assertEqual(helper.data_set_response.message, "string")
        
data_sets_dict = [ 
    {
        "id": "string",
        "name": "string",
        "key": "string",
        "category": {
            "id": "1",
            "name": "Satellite"
        },
        "level": 0,
        "crs": "string",
        "dsourceHLink": "string",
        "dsourceDesc": "string",
        "status": "Production",
        "dataOrigin": "string",
        "maxLayers": "30",
        "name_alternate": "ESA Sentinel 2 Level-2A",
        "rating": "4.0",
        "description_short": "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.",
        "description_long": "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.",
        "description_links": [
            "https://sentinel.esa.int/web/sentinel/missions",
            "https://sentinel.esa.int/documents/247904/685211/Sentinel-2_User_Handbook",
            "https://sentinel.esa.int/web/sentinel/missions/sentinel-2/data-products",
            "https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi"
        ],
        "data_source_name": "European Space Agency Sentinel-2",
        "data_source_attribution": "'Copernicus Sentinel data [Year]' for Sentinel data; see https://lta.cr.usgs.gov/sites/default/files/Sentinel_Data_Terms_and_Conditions.pdf",
        "data_source_description": "'Level-2A is generated by the Payload Data Ground Segment using the Sen2Cor processor. Level-2A products are made available to users via the Copernicus Open Access Hub: https://scihub.copernicus.eu/dhus/#/home",
        "data_source_links": [
            "https://sentinel.esa.int/web/sentinel/sentinel-data-access"
        ],
        "update_interval_max": "1 day",
        "update_interval_description": "Uploads are run daily. However, note the temporal resolution.",
        "lag_horizon": "5 days",
        "lag_horizon_description": "Data is available within 24 hours.",
        "temporal_resolution": "5 days",
        "temporal_resolution_description": "string",
        "spatial_resolution_of_raw_data": "100m",
        "interpolation": "near",
        "dimensions_description": "The sole dimension is called \"horizon\" and refers to the forecast horizon in hours. (Only integer horizons are allowed.)",
        "permanence": "true",
        "permanence_description": "Data with timestamp into the future will be update, but remain constant past current timestamp (except for error corrrection).",
        "known_issues": "Updates are irregular.",
        "responsible_organization": "<Your Organization>",
        "properties": {
            "Sector": [
                "Animals/livestock",
                "Transportation/infrastructure",
                "Vegetation/crops",
                "Weather/climate"
            ],
            "Application": [
                "Agriculture"
            ],
            "Domain": [
                "Land surface"
            ],
            "Type": [
                "Data product"
            ],
            "Source": [
                "Satellite",
                "Survey"
            ]
        },
        "spatial_coverage": {
            "Country": [
                "Belgium",
                "Bolivia",
                "France",
                "Germany",
                "India",
                "Indonesia",
                "Luxembourg",
                "Netherlands",
                "Switzerland",
                "Thailand",
                "United Kingdom",
                "United States of America"
            ]
        },
        "latitude_min": "-90",
        "longitude_min": "-180",
        "latitude_max": "90",
        "longitude_max": "180",
        "temporal_min": "2016-03-12T00:00:01.000Z",
        "temporal_max": "2019-07-30T00:00:01.000Z",
        "offering_status": ""
    },
    {
        "id": "string2",
        "name": "string2",
        "key": "string2",
        "category": {
            "id": "2",
            "name": "Satellite"
        },
        "level": 1,
        "crs": "string2",
        "dsourceHLink": "string2",
        "dsourceDesc": "string2",
        "status": "Production",
        "dataOrigin": "string2",
        "maxLayers": "31",
        "name_alternate": "ESA Sentinel 2 Level-2A",
        "rating": "4.0",
        "description_short": "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.",
        "description_long": "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.",
        "description_links": [
            "https://sentinel.esa.int/web/sentinel/missions2",
            "https://sentinel.esa.int/documents/247904/685211/Sentinel-2_User_Handbook2",
            "https://sentinel.esa.int/web/sentinel/missions/sentinel-2/data-products2",
            "https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi2"
        ],
        "data_source_name": "European Space Agency Sentinel-2",
        "data_source_attribution": "'Copernicus Sentinel data [Year]' for Sentinel data; see https://lta.cr.usgs.gov/sites/default/files/Sentinel_Data_Terms_and_Conditions.pdf",
        "data_source_description": "'Level-2A is generated by the Payload Data Ground Segment using the Sen2Cor processor. Level-2A products are made available to users via the Copernicus Open Access Hub: https://scihub.copernicus.eu/dhus/#/home",
        "data_source_links": [
            "https://sentinel.esa.int/web/sentinel/sentinel-data-access2"
        ],
        "update_interval_max": "1 day",
        "update_interval_description": "Uploads are run daily. However, note the temporal resolution.",
        "lag_horizon": "5 days",
        "lag_horizon_description": "Data is available within 24 hours.",
        "temporal_resolution": "5 days",
        "temporal_resolution_description": "string2",
        "spatial_resolution_of_raw_data": "100m",
        "interpolation": "near",
        "dimensions_description": "The sole dimension is called \"horizon\" and refers to the forecast horizon in hours. (Only integer horizons are allowed.)",
        "permanence": "true",
        "permanence_description": "Data with timestamp into the future will be update, but remain constant past current timestamp (except for error corrrection).",
        "known_issues": "Updates are irregular.",
        "responsible_organization": "<Your Organization>",
        "properties": {
            "Sector": [
                "Animals/livestock2",
                "Transportation/infrastructure2",
                "Vegetation/crops2",
                "Weather/climate2"
            ],
            "Application": [
                "Agriculture2"
            ],
            "Domain": [
                "Land surface2"
            ],
            "Type": [
                "Data product2"
            ],
            "Source": [
                "Satellite2",
                "Survey2"
            ]
        },
        "spatial_coverage": {
            "Country": [
                "Belgium2",
                "Bolivia2",
                "France2",
                "Germany2",
                "India2",
                "Indonesia2",
                "Luxembourg2",
                "Netherlands2",
                "Switzerland2",
                "Thailand2",
                "United Kingdom2",
                "United States of America2"
            ]
        },
        "latitude_min": "-180",
        "longitude_min": "-90",
        "latitude_max": "180",
        "longitude_max": "90",
        "temporal_min": "1970-03-12T00:00:01.000Z",
        "temporal_max": "1970-07-30T00:00:01.000Z",
        "offering_status": ""
    }
]

data_sets_str = r'''[ 
    {
        "id": "string",
        "name": "string",
        "key": "string",
        "category": {
            "id": "1",
            "name": "Satellite"
        },
        "level": 0,
        "crs": "string",
        "dsourceHLink": "string",
        "dsourceDesc": "string",
        "status": "Production",
        "dataOrigin": "string",
        "maxLayers": "30",
        "name_alternate": "ESA Sentinel 2 Level-2A",
        "rating": "4.0",
        "description_short": "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.",
        "description_long": "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.",
        "description_links": [
            "https://sentinel.esa.int/web/sentinel/missions",
            "https://sentinel.esa.int/documents/247904/685211/Sentinel-2_User_Handbook",
            "https://sentinel.esa.int/web/sentinel/missions/sentinel-2/data-products",
            "https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi"
        ],
        "data_source_name": "European Space Agency Sentinel-2",
        "data_source_attribution": "'Copernicus Sentinel data [Year]' for Sentinel data; see https://lta.cr.usgs.gov/sites/default/files/Sentinel_Data_Terms_and_Conditions.pdf",
        "data_source_description": "'Level-2A is generated by the Payload Data Ground Segment using the Sen2Cor processor. Level-2A products are made available to users via the Copernicus Open Access Hub: https://scihub.copernicus.eu/dhus/#/home",
        "data_source_links": [
            "https://sentinel.esa.int/web/sentinel/sentinel-data-access"
        ],
        "update_interval_max": "1 day",
        "update_interval_description": "Uploads are run daily. However, note the temporal resolution.",
        "lag_horizon": "5 days",
        "lag_horizon_description": "Data is available within 24 hours.",
        "temporal_resolution": "5 days",
        "temporal_resolution_description": "string",
        "spatial_resolution_of_raw_data": "100m",
        "interpolation": "near",
        "dimensions_description": "The sole dimension is called \"horizon\" and refers to the forecast horizon in hours. (Only integer horizons are allowed.)",
        "permanence": "true",
        "permanence_description": "Data with timestamp into the future will be update, but remain constant past current timestamp (except for error corrrection).",
        "known_issues": "Updates are irregular.",
        "responsible_organization": "<Your Organization>",
        "properties": {
            "Sector": [
                "Animals/livestock",
                "Transportation/infrastructure",
                "Vegetation/crops",
                "Weather/climate"
            ],
            "Application": [
                "Agriculture"
            ],
            "Domain": [
                "Land surface"
            ],
            "Type": [
                "Data product"
            ],
            "Source": [
                "Satellite",
                "Survey"
            ]
        },
        "spatial_coverage": {
            "Country": [
                "Belgium",
                "Bolivia",
                "France",
                "Germany",
                "India",
                "Indonesia",
                "Luxembourg",
                "Netherlands",
                "Switzerland",
                "Thailand",
                "United Kingdom",
                "United States of America"
            ]
        },
        "latitude_min": "-90",
        "longitude_min": "-180",
        "latitude_max": "90",
        "longitude_max": "180",
        "temporal_min": "2016-03-12T00:00:01.000Z",
        "temporal_max": "2019-07-30T00:00:01.000Z",
        "offering_status": ""
    },
    {
        "id": "string2",
        "name": "string2",
        "key": "string2",
        "category": {
            "id": "2",
            "name": "Satellite"
        },
        "level": 1,
        "crs": "string2",
        "dsourceHLink": "string2",
        "dsourceDesc": "string2",
        "status": "Production",
        "dataOrigin": "string2",
        "maxLayers": "31",
        "name_alternate": "ESA Sentinel 2 Level-2A",
        "rating": "4.0",
        "description_short": "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.",
        "description_long": "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.",
        "description_links": [
            "https://sentinel.esa.int/web/sentinel/missions2",
            "https://sentinel.esa.int/documents/247904/685211/Sentinel-2_User_Handbook2",
            "https://sentinel.esa.int/web/sentinel/missions/sentinel-2/data-products2",
            "https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi2"
        ],
        "data_source_name": "European Space Agency Sentinel-2",
        "data_source_attribution": "'Copernicus Sentinel data [Year]' for Sentinel data; see https://lta.cr.usgs.gov/sites/default/files/Sentinel_Data_Terms_and_Conditions.pdf",
        "data_source_description": "'Level-2A is generated by the Payload Data Ground Segment using the Sen2Cor processor. Level-2A products are made available to users via the Copernicus Open Access Hub: https://scihub.copernicus.eu/dhus/#/home",
        "data_source_links": [
            "https://sentinel.esa.int/web/sentinel/sentinel-data-access2"
        ],
        "update_interval_max": "1 day",
        "update_interval_description": "Uploads are run daily. However, note the temporal resolution.",
        "lag_horizon": "5 days",
        "lag_horizon_description": "Data is available within 24 hours.",
        "temporal_resolution": "5 days",
        "temporal_resolution_description": "string2",
        "spatial_resolution_of_raw_data": "100m",
        "interpolation": "near",
        "dimensions_description": "The sole dimension is called \"horizon\" and refers to the forecast horizon in hours. (Only integer horizons are allowed.)",
        "permanence": "true",
        "permanence_description": "Data with timestamp into the future will be update, but remain constant past current timestamp (except for error corrrection).",
        "known_issues": "Updates are irregular.",
        "responsible_organization": "<Your Organization>",
        "properties": {
            "Sector": [
                "Animals/livestock2",
                "Transportation/infrastructure2",
                "Vegetation/crops2",
                "Weather/climate2"
            ],
            "Application": [
                "Agriculture2"
            ],
            "Domain": [
                "Land surface2"
            ],
            "Type": [
                "Data product2"
            ],
            "Source": [
                "Satellite2",
                "Survey2"
            ]
        },
        "spatial_coverage": {
            "Country": [
                "Belgium2",
                "Bolivia2",
                "France2",
                "Germany2",
                "India2",
                "Indonesia2",
                "Luxembourg2",
                "Netherlands2",
                "Switzerland2",
                "Thailand2",
                "United Kingdom2",
                "United States of America2"
            ]
        },
        "latitude_min": "-180",
        "longitude_min": "-90",
        "latitude_max": "180",
        "longitude_max": "90",
        "temporal_min": "1970-03-12T00:00:01.000Z",
        "temporal_max": "1970-07-30T00:00:01.000Z",
        "offering_status": ""
    }
]'''

data_sets_multi_name_dict = [
    {
        "name": "abc"
    },
    {
        "name": "abc"
    }
]

data_sets_obj_repr_dict = {
    "data_sets": [
        {
            "name": "abc"
        },
        {
            "name": "abc2"
        }
    ]
}

#
class DataSetsUnitTest(unittest.TestCase):
    
    #
    def setUp(self):
        self.logger = logger
        self.logger.info('setup')
    
    #
    def tearDown(self):
        self.logger.info('teardown')

    #    
    def test_data_sets_from_dict(self):
        
        self.logger.info('test_data_sets_from_dict')
        
        client = cl.Client()
        data_sets = catalog.DataSets

        data_sets_from_dict = None
            
        got_exception = False

        try:
            data_sets_from_dict = data_sets.from_dict(data_sets_dict)
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)    
        
        self.assertEqual(data_sets_from_dict["string"].id, "string")
        self.assertEqual(data_sets_from_dict["string"].name, "string")
        self.assertEqual(data_sets_from_dict["string"].key, "string")
        self.assertEqual(data_sets_from_dict["string"].category.id, 1)
        self.assertEqual(data_sets_from_dict["string"].category.name, "Satellite")
        self.assertEqual(data_sets_from_dict["string"].level, 0)
        self.assertEqual(data_sets_from_dict["string"].crs, "string")
        self.assertEqual(data_sets_from_dict["string"].dsource_h_link, "string")
        self.assertEqual(data_sets_from_dict["string"].dsource_desc, "string")
        self.assertEqual(data_sets_from_dict["string"].status, "Production")
        self.assertEqual(data_sets_from_dict["string"].data_origin, "string")
        self.assertEqual(data_sets_from_dict["string"].max_layers, 30)
        self.assertEqual(data_sets_from_dict["string"].name_alternate, "ESA Sentinel 2 Level-2A")
        self.assertEqual(data_sets_from_dict["string"].rating, 4.0)
        self.assertEqual(data_sets_from_dict["string"].description_short, "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.")
        self.assertEqual(data_sets_from_dict["string"].description_long, "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.")
        self.assertEqual(data_sets_from_dict["string"].description_links[0], "https://sentinel.esa.int/web/sentinel/missions")
        self.assertEqual(data_sets_from_dict["string"].description_links[1], "https://sentinel.esa.int/documents/247904/685211/Sentinel-2_User_Handbook")
        self.assertEqual(data_sets_from_dict["string"].description_links[2], "https://sentinel.esa.int/web/sentinel/missions/sentinel-2/data-products")
        self.assertEqual(data_sets_from_dict["string"].description_links[3], "https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi")
        self.assertEqual(data_sets_from_dict["string"].data_source_name, "European Space Agency Sentinel-2")
        self.assertEqual(data_sets_from_dict["string"].data_source_attribution, "'Copernicus Sentinel data [Year]' for Sentinel data; see https://lta.cr.usgs.gov/sites/default/files/Sentinel_Data_Terms_and_Conditions.pdf")
        self.assertEqual(data_sets_from_dict["string"].data_source_description, "'Level-2A is generated by the Payload Data Ground Segment using the Sen2Cor processor. Level-2A products are made available to users via the Copernicus Open Access Hub: https://scihub.copernicus.eu/dhus/#/home")
        self.assertEqual(data_sets_from_dict["string"].data_source_links[0], "https://sentinel.esa.int/web/sentinel/sentinel-data-access")
        self.assertEqual(data_sets_from_dict["string"].update_interval_max, "1 day")
        self.assertEqual(data_sets_from_dict["string"].update_interval_description, "Uploads are run daily. However, note the temporal resolution.")
        self.assertEqual(data_sets_from_dict["string"].lag_horizon, "5 days")
        self.assertEqual(data_sets_from_dict["string"].lag_horizon_description, "Data is available within 24 hours.")
        self.assertEqual(data_sets_from_dict["string"].temporal_resolution, "5 days")
        self.assertEqual(data_sets_from_dict["string"].temporal_resolution_description, "string")
        self.assertEqual(data_sets_from_dict["string"].spatial_resolution_of_raw_data, "100m")
        self.assertEqual(data_sets_from_dict["string"].interpolation, "near")
        self.assertEqual(data_sets_from_dict["string"].dimensions_description, "The sole dimension is called \"horizon\" and refers to the forecast horizon in hours. (Only integer horizons are allowed.)")
        self.assertEqual(data_sets_from_dict["string"].permanence, True)
        self.assertEqual(data_sets_from_dict["string"].permanence_description, "Data with timestamp into the future will be update, but remain constant past current timestamp (except for error corrrection).")
        self.assertEqual(data_sets_from_dict["string"].known_issues, "Updates are irregular.")
        self.assertEqual(data_sets_from_dict["string"].responsible_organization, "<Your Organization>")
        self.assertEqual(data_sets_from_dict["string"].properties.sector[0], "Animals/livestock")
        self.assertEqual(data_sets_from_dict["string"].properties.sector[1], "Transportation/infrastructure")
        self.assertEqual(data_sets_from_dict["string"].properties.sector[2], "Vegetation/crops")
        self.assertEqual(data_sets_from_dict["string"].properties.sector[3], "Weather/climate")
        self.assertEqual(data_sets_from_dict["string"].properties.application[0], "Agriculture")
        self.assertEqual(data_sets_from_dict["string"].properties.domain[0], "Land surface")
        self.assertEqual(data_sets_from_dict["string"].properties.type[0], "Data product")
        self.assertEqual(data_sets_from_dict["string"].properties.source[0], "Satellite")
        self.assertEqual(data_sets_from_dict["string"].properties.source[1], "Survey")
        self.assertEqual(data_sets_from_dict["string"].spatial_coverage.country[0], "Belgium")
        self.assertEqual(data_sets_from_dict["string"].spatial_coverage.country[1], "Bolivia")
        self.assertEqual(data_sets_from_dict["string"].spatial_coverage.country[2], "France")
        self.assertEqual(data_sets_from_dict["string"].spatial_coverage.country[3], "Germany")
        self.assertEqual(data_sets_from_dict["string"].spatial_coverage.country[4], "India")
        self.assertEqual(data_sets_from_dict["string"].spatial_coverage.country[5], "Indonesia")
        self.assertEqual(data_sets_from_dict["string"].spatial_coverage.country[6], "Luxembourg")
        self.assertEqual(data_sets_from_dict["string"].spatial_coverage.country[7], "Netherlands")
        self.assertEqual(data_sets_from_dict["string"].spatial_coverage.country[8], "Switzerland")
        self.assertEqual(data_sets_from_dict["string"].spatial_coverage.country[9], "Thailand")
        self.assertEqual(data_sets_from_dict["string"].spatial_coverage.country[10], "United Kingdom")
        self.assertEqual(data_sets_from_dict["string"].spatial_coverage.country[11], "United States of America")
        self.assertEqual(data_sets_from_dict["string"].latitude_min, -90)
        self.assertEqual(data_sets_from_dict["string"].longitude_min, -180)
        self.assertEqual(data_sets_from_dict["string"].latitude_max, 90)
        self.assertEqual(data_sets_from_dict["string"].longitude_max, 180)
        self.assertEqual(data_sets_from_dict["string"].temporal_min, "2016-03-12T00:00:01.000Z")
        self.assertEqual(data_sets_from_dict["string"].temporal_max, "2019-07-30T00:00:01.000Z")
        self.assertEqual(data_sets_from_dict["string"].offering_status, "")
        
        self.assertEqual(data_sets_from_dict["string2"].id, "string2")
        self.assertEqual(data_sets_from_dict["string2"].name, "string2")
        self.assertEqual(data_sets_from_dict["string2"].key, "string2")
        self.assertEqual(data_sets_from_dict["string2"].category.id, 2)
        self.assertEqual(data_sets_from_dict["string2"].category.name, "Satellite")
        self.assertEqual(data_sets_from_dict["string2"].level, 1)
        self.assertEqual(data_sets_from_dict["string2"].crs, "string2")
        self.assertEqual(data_sets_from_dict["string2"].dsource_h_link, "string2")
        self.assertEqual(data_sets_from_dict["string2"].dsource_desc, "string2")
        self.assertEqual(data_sets_from_dict["string2"].status, "Production")
        self.assertEqual(data_sets_from_dict["string2"].data_origin, "string2")
        self.assertEqual(data_sets_from_dict["string2"].max_layers, 31)
        self.assertEqual(data_sets_from_dict["string2"].name_alternate, "ESA Sentinel 2 Level-2A")
        self.assertEqual(data_sets_from_dict["string2"].rating, 4.0)
        self.assertEqual(data_sets_from_dict["string2"].description_short, "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.")
        self.assertEqual(data_sets_from_dict["string2"].description_long, "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.")
        self.assertEqual(data_sets_from_dict["string2"].description_links[0], "https://sentinel.esa.int/web/sentinel/missions2")
        self.assertEqual(data_sets_from_dict["string2"].description_links[1], "https://sentinel.esa.int/documents/247904/685211/Sentinel-2_User_Handbook2")
        self.assertEqual(data_sets_from_dict["string2"].description_links[2], "https://sentinel.esa.int/web/sentinel/missions/sentinel-2/data-products2")
        self.assertEqual(data_sets_from_dict["string2"].description_links[3], "https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi2")
        self.assertEqual(data_sets_from_dict["string2"].data_source_name, "European Space Agency Sentinel-2")
        self.assertEqual(data_sets_from_dict["string2"].data_source_attribution, "'Copernicus Sentinel data [Year]' for Sentinel data; see https://lta.cr.usgs.gov/sites/default/files/Sentinel_Data_Terms_and_Conditions.pdf")
        self.assertEqual(data_sets_from_dict["string2"].data_source_description, "'Level-2A is generated by the Payload Data Ground Segment using the Sen2Cor processor. Level-2A products are made available to users via the Copernicus Open Access Hub: https://scihub.copernicus.eu/dhus/#/home")
        self.assertEqual(data_sets_from_dict["string2"].data_source_links[0], "https://sentinel.esa.int/web/sentinel/sentinel-data-access2")
        self.assertEqual(data_sets_from_dict["string2"].update_interval_max, "1 day")
        self.assertEqual(data_sets_from_dict["string2"].update_interval_description, "Uploads are run daily. However, note the temporal resolution.")
        self.assertEqual(data_sets_from_dict["string2"].lag_horizon, "5 days")
        self.assertEqual(data_sets_from_dict["string2"].lag_horizon_description, "Data is available within 24 hours.")
        self.assertEqual(data_sets_from_dict["string2"].temporal_resolution, "5 days")
        self.assertEqual(data_sets_from_dict["string2"].temporal_resolution_description, "string2")
        self.assertEqual(data_sets_from_dict["string2"].spatial_resolution_of_raw_data, "100m")
        self.assertEqual(data_sets_from_dict["string2"].interpolation, "near")
        self.assertEqual(data_sets_from_dict["string2"].dimensions_description, "The sole dimension is called \"horizon\" and refers to the forecast horizon in hours. (Only integer horizons are allowed.)")
        self.assertEqual(data_sets_from_dict["string2"].permanence, True)
        self.assertEqual(data_sets_from_dict["string2"].permanence_description, "Data with timestamp into the future will be update, but remain constant past current timestamp (except for error corrrection).")
        self.assertEqual(data_sets_from_dict["string2"].known_issues, "Updates are irregular.")
        self.assertEqual(data_sets_from_dict["string2"].responsible_organization, "<Your Organization>")
        self.assertEqual(data_sets_from_dict["string2"].properties.sector[0], "Animals/livestock2")
        self.assertEqual(data_sets_from_dict["string2"].properties.sector[1], "Transportation/infrastructure2")
        self.assertEqual(data_sets_from_dict["string2"].properties.sector[2], "Vegetation/crops2")
        self.assertEqual(data_sets_from_dict["string2"].properties.sector[3], "Weather/climate2")
        self.assertEqual(data_sets_from_dict["string2"].properties.application[0], "Agriculture2")
        self.assertEqual(data_sets_from_dict["string2"].properties.domain[0], "Land surface2")
        self.assertEqual(data_sets_from_dict["string2"].properties.type[0], "Data product2")
        self.assertEqual(data_sets_from_dict["string2"].properties.source[0], "Satellite2")
        self.assertEqual(data_sets_from_dict["string2"].properties.source[1], "Survey2")
        self.assertEqual(data_sets_from_dict["string2"].spatial_coverage.country[0], "Belgium2")
        self.assertEqual(data_sets_from_dict["string2"].spatial_coverage.country[1], "Bolivia2")
        self.assertEqual(data_sets_from_dict["string2"].spatial_coverage.country[2], "France2")
        self.assertEqual(data_sets_from_dict["string2"].spatial_coverage.country[3], "Germany2")
        self.assertEqual(data_sets_from_dict["string2"].spatial_coverage.country[4], "India2")
        self.assertEqual(data_sets_from_dict["string2"].spatial_coverage.country[5], "Indonesia2")
        self.assertEqual(data_sets_from_dict["string2"].spatial_coverage.country[6], "Luxembourg2")
        self.assertEqual(data_sets_from_dict["string2"].spatial_coverage.country[7], "Netherlands2")
        self.assertEqual(data_sets_from_dict["string2"].spatial_coverage.country[8], "Switzerland2")
        self.assertEqual(data_sets_from_dict["string2"].spatial_coverage.country[9], "Thailand2")
        self.assertEqual(data_sets_from_dict["string2"].spatial_coverage.country[10], "United Kingdom2")
        self.assertEqual(data_sets_from_dict["string2"].spatial_coverage.country[11], "United States of America2")
        self.assertEqual(data_sets_from_dict["string2"].latitude_min, -180)
        self.assertEqual(data_sets_from_dict["string2"].longitude_min, -90)
        self.assertEqual(data_sets_from_dict["string2"].latitude_max, 180)
        self.assertEqual(data_sets_from_dict["string2"].longitude_max, 90)
        self.assertEqual(data_sets_from_dict["string2"].temporal_min, "1970-03-12T00:00:01.000Z")
        self.assertEqual(data_sets_from_dict["string2"].temporal_max, "1970-07-30T00:00:01.000Z")
        self.assertEqual(data_sets_from_dict["string2"].offering_status, "")
        
        self.logger.info('test_data_sets_from_dict: no overload')
        
        self.assertEqual(data_sets_from_dict[0].name, "string")
        self.assertEqual(data_sets_from_dict[1].name, "string2")
        
        self.logger.info('test_data_sets_from_dict: set overload')
        
        data_sets_from_dict["string"].id = "newstring"
        data_sets_from_dict["string2"].id = "newstring2"
        data_sets_from_dict["string"].name = "newstring"
        data_sets_from_dict["string2"].name = "newstring2"
        
        self.assertEqual(data_sets_from_dict["newstring"].name, "newstring")
        self.assertEqual(data_sets_from_dict["newstring2"].name, "newstring2")
        self.assertEqual(data_sets_from_dict["newstring"].id, "newstring")
        self.assertEqual(data_sets_from_dict["newstring2"].id, "newstring2")
        
        self.logger.info('test_data_sets_from_dict: set no overload')
        
        data_sets_from_dict[0].id = "newnewstring"
        data_sets_from_dict[1].id = "newnewstring2"
        data_sets_from_dict[0].name = "newnewstring"
        data_sets_from_dict[1].name = "newnewstring2"
        
        self.assertEqual(data_sets_from_dict["newnewstring"].name, "newnewstring")
        self.assertEqual(data_sets_from_dict["newnewstring2"].name, "newnewstring2")
        self.assertEqual(data_sets_from_dict["newnewstring"].id, "newnewstring")
        self.assertEqual(data_sets_from_dict["newnewstring2"].id, "newnewstring2")
        self.assertEqual(data_sets_from_dict[0].name, "newnewstring")
        self.assertEqual(data_sets_from_dict[1].name, "newnewstring2")
        self.assertEqual(data_sets_from_dict[0].id, "newnewstring")
        self.assertEqual(data_sets_from_dict[1].id, "newnewstring2")
        
        data_sets_multi_name = catalog.DataSets

        data_sets_multi_name_from_dict = None
            
        got_exception2 = False

        try:
            data_sets_multi_name_from_dict = data_sets_multi_name.from_dict(data_sets_multi_name_dict)
        except Exception as ex:
            got_exception2 = True

        self.assertFalse(got_exception2)
        
        got_exception3 = False
        
        try:
            data_sets_multi_name_from_dict["ab"].name = "abcd"
        except Exception as ex:
            got_exception3 = True
            
        self.assertTrue(got_exception3)
        
        got_exception4 = False
        
        try:
            data_sets_multi_name_from_dict["abc"].name = "abcd"
        except Exception as ex:
            got_exception4 = True
            
        self.assertTrue(got_exception4)
        
        got_exception5 = False
        
        try:
            d = {}
            data_sets_multi_name_from_dict[d].name = "abcd"
        except Exception as ex:
            got_exception5 = True
            
        self.assertTrue(got_exception5)
        
        got_exception6 = False
        
        try:
            data_sets_multi_name_from_dict[0].name = "abcd"
        except Exception as ex:
            got_exception6 = True
            
        self.assertFalse(got_exception6)
        
        self.assertEqual(data_sets_multi_name_from_dict[0].name, "abcd")
        self.assertEqual(data_sets_multi_name_from_dict[1].name, "abc")
        
        got_exception7 = False
        
        try:
            data_sets_multi_name_from_dict["abc"].name = "efg"
        except Exception as ex:
            got_exception7 = True
            
        self.assertFalse(got_exception7)
        
        self.assertEqual(data_sets_multi_name_from_dict[0].name, "abcd")
        self.assertEqual(data_sets_multi_name_from_dict[1].name, "efg")
        
        data_sets_obj_repr = catalog.DataSets

        data_sets_obj_repr_from_dict = None
        
        got_exception8 = False

        try:
            data_sets_obj_repr_from_dict = data_sets_obj_repr.from_dict(data_sets_obj_repr_dict)
        except Exception as ex:
            got_exception8 = True

        self.assertFalse(got_exception8)
        
        self.assertEqual(data_sets_obj_repr_from_dict[0].name, "abc")
        self.assertEqual(data_sets_obj_repr_from_dict[1].name, "abc2")
        
    def test_data_sets_to_dict(self):
        
        self.logger.info('test_data_sets_to_dict')
        
        client = cl.Client()
        data_sets = catalog.DataSets

        data_sets_from_dict = None
        data_sets_to_dict   = None
                
        got_exception = False

        try:
            data_sets_from_dict = data_sets.from_dict(data_sets_dict)
            data_sets_to_dict = data_sets_from_dict.to_dict()
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        self.assertEqual(data_sets_to_dict["data_sets"][0]["id"], "string")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["name"], "string")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["key"], "string")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["category"]["id"], 1)
        self.assertEqual(data_sets_to_dict["data_sets"][0]["category"]["name"], "Satellite")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["level"], 0)
        self.assertEqual(data_sets_to_dict["data_sets"][0]["crs"], "string")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["dsource_h_link"], "string")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["dsource_desc"], "string")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["status"], "Production")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["data_origin"], "string")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["max_layers"], 30)
        self.assertEqual(data_sets_to_dict["data_sets"][0]["name_alternate"], "ESA Sentinel 2 Level-2A")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["rating"], 4.0)
        self.assertEqual(data_sets_to_dict["data_sets"][0]["description_short"], "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["description_long"], "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["description_links"][0], "https://sentinel.esa.int/web/sentinel/missions")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["description_links"][1], "https://sentinel.esa.int/documents/247904/685211/Sentinel-2_User_Handbook")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["description_links"][2], "https://sentinel.esa.int/web/sentinel/missions/sentinel-2/data-products")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["description_links"][3], "https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["data_source_name"], "European Space Agency Sentinel-2")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["data_source_attribution"], "'Copernicus Sentinel data [Year]' for Sentinel data; see https://lta.cr.usgs.gov/sites/default/files/Sentinel_Data_Terms_and_Conditions.pdf")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["data_source_description"], "'Level-2A is generated by the Payload Data Ground Segment using the Sen2Cor processor. Level-2A products are made available to users via the Copernicus Open Access Hub: https://scihub.copernicus.eu/dhus/#/home")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["data_source_links"][0], "https://sentinel.esa.int/web/sentinel/sentinel-data-access")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["update_interval_max"], "1 day")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["update_interval_description"], "Uploads are run daily. However, note the temporal resolution.")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["lag_horizon"], "5 days")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["lag_horizon_description"], "Data is available within 24 hours.")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["temporal_resolution"], "5 days")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["temporal_resolution_description"], "string")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["spatial_resolution_of_raw_data"], "100m")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["interpolation"], "near")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["dimensions_description"], "The sole dimension is called \"horizon\" and refers to the forecast horizon in hours. (Only integer horizons are allowed.)")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["permanence"], True)
        self.assertEqual(data_sets_to_dict["data_sets"][0]["permanence_description"], "Data with timestamp into the future will be update, but remain constant past current timestamp (except for error corrrection).")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["known_issues"], "Updates are irregular.")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["responsible_organization"], "<Your Organization>")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["properties"]["sector"][0], "Animals/livestock")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["properties"]["sector"][1], "Transportation/infrastructure")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["properties"]["sector"][2], "Vegetation/crops")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["properties"]["sector"][3], "Weather/climate")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["properties"]["application"][0], "Agriculture")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["properties"]["domain"][0], "Land surface")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["properties"]["type"][0], "Data product")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["properties"]["source"][0], "Satellite")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["properties"]["source"][1], "Survey")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["spatial_coverage"]["country"][0], "Belgium")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["spatial_coverage"]["country"][1], "Bolivia")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["spatial_coverage"]["country"][2], "France")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["spatial_coverage"]["country"][3], "Germany")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["spatial_coverage"]["country"][4], "India")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["spatial_coverage"]["country"][5], "Indonesia")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["spatial_coverage"]["country"][6], "Luxembourg")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["spatial_coverage"]["country"][7], "Netherlands")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["spatial_coverage"]["country"][8], "Switzerland")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["spatial_coverage"]["country"][9], "Thailand")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["spatial_coverage"]["country"][10], "United Kingdom")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["spatial_coverage"]["country"][11], "United States of America")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["latitude_min"], -90)
        self.assertEqual(data_sets_to_dict["data_sets"][0]["longitude_min"], -180)
        self.assertEqual(data_sets_to_dict["data_sets"][0]["latitude_max"], 90)
        self.assertEqual(data_sets_to_dict["data_sets"][0]["longitude_max"], 180)
        self.assertEqual(data_sets_to_dict["data_sets"][0]["temporal_min"], "2016-03-12T00:00:01.000Z")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["temporal_max"], "2019-07-30T00:00:01.000Z")
        self.assertEqual(data_sets_to_dict["data_sets"][0]["offering_status"], "")
        
        self.assertEqual(data_sets_to_dict["data_sets"][1]["id"], "string2")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["name"], "string2")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["key"], "string2")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["category"]["id"], 2)
        self.assertEqual(data_sets_to_dict["data_sets"][1]["category"]["name"], "Satellite")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["level"], 1)
        self.assertEqual(data_sets_to_dict["data_sets"][1]["crs"], "string2")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["dsource_h_link"], "string2")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["dsource_desc"], "string2")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["status"], "Production")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["data_origin"], "string2")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["max_layers"], 31)
        self.assertEqual(data_sets_to_dict["data_sets"][1]["name_alternate"], "ESA Sentinel 2 Level-2A")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["rating"], 4.0)
        self.assertEqual(data_sets_to_dict["data_sets"][1]["description_short"], "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["description_long"], "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["description_links"][0], "https://sentinel.esa.int/web/sentinel/missions2")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["description_links"][1], "https://sentinel.esa.int/documents/247904/685211/Sentinel-2_User_Handbook2")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["description_links"][2], "https://sentinel.esa.int/web/sentinel/missions/sentinel-2/data-products2")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["description_links"][3], "https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi2")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["data_source_name"], "European Space Agency Sentinel-2")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["data_source_attribution"], "'Copernicus Sentinel data [Year]' for Sentinel data; see https://lta.cr.usgs.gov/sites/default/files/Sentinel_Data_Terms_and_Conditions.pdf")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["data_source_description"], "'Level-2A is generated by the Payload Data Ground Segment using the Sen2Cor processor. Level-2A products are made available to users via the Copernicus Open Access Hub: https://scihub.copernicus.eu/dhus/#/home")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["data_source_links"][0], "https://sentinel.esa.int/web/sentinel/sentinel-data-access2")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["update_interval_max"], "1 day")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["update_interval_description"], "Uploads are run daily. However, note the temporal resolution.")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["lag_horizon"], "5 days")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["lag_horizon_description"], "Data is available within 24 hours.")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["temporal_resolution"], "5 days")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["temporal_resolution_description"], "string2")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["spatial_resolution_of_raw_data"], "100m")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["interpolation"], "near")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["dimensions_description"], "The sole dimension is called \"horizon\" and refers to the forecast horizon in hours. (Only integer horizons are allowed.)")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["permanence"], True)
        self.assertEqual(data_sets_to_dict["data_sets"][1]["permanence_description"], "Data with timestamp into the future will be update, but remain constant past current timestamp (except for error corrrection).")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["known_issues"], "Updates are irregular.")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["responsible_organization"], "<Your Organization>")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["properties"]["sector"][0], "Animals/livestock2")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["properties"]["sector"][1], "Transportation/infrastructure2")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["properties"]["sector"][2], "Vegetation/crops2")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["properties"]["sector"][3], "Weather/climate2")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["properties"]["application"][0], "Agriculture2")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["properties"]["domain"][0], "Land surface2")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["properties"]["type"][0], "Data product2")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["properties"]["source"][0], "Satellite2")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["properties"]["source"][1], "Survey2")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["spatial_coverage"]["country"][0], "Belgium2")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["spatial_coverage"]["country"][1], "Bolivia2")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["spatial_coverage"]["country"][2], "France2")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["spatial_coverage"]["country"][3], "Germany2")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["spatial_coverage"]["country"][4], "India2")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["spatial_coverage"]["country"][5], "Indonesia2")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["spatial_coverage"]["country"][6], "Luxembourg2")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["spatial_coverage"]["country"][7], "Netherlands2")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["spatial_coverage"]["country"][8], "Switzerland2")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["spatial_coverage"]["country"][9], "Thailand2")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["spatial_coverage"]["country"][10], "United Kingdom2")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["spatial_coverage"]["country"][11], "United States of America2")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["latitude_min"], -180)
        self.assertEqual(data_sets_to_dict["data_sets"][1]["longitude_min"], -90)
        self.assertEqual(data_sets_to_dict["data_sets"][1]["latitude_max"], 180)
        self.assertEqual(data_sets_to_dict["data_sets"][1]["longitude_max"], 90)
        self.assertEqual(data_sets_to_dict["data_sets"][1]["temporal_min"], "1970-03-12T00:00:01.000Z")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["temporal_max"], "1970-07-30T00:00:01.000Z")
        self.assertEqual(data_sets_to_dict["data_sets"][1]["offering_status"], "")

    #
    def test_data_sets_from_json(self):
        
        self.logger.info('test_data_sets_from_json')
        
        client = cl.Client()
        got_exception = False

        try:
            data_sets_from_json = catalog.data_sets_from_json(data_sets_str)
        except Exception as ex:
            self.logger.info(ex)
            got_exception = True

        self.assertFalse(got_exception)
        
        self.assertEqual(data_sets_from_json["string"].id, "string")
        self.assertEqual(data_sets_from_json["string"].name, "string")
        self.assertEqual(data_sets_from_json["string"].key, "string")
        self.assertEqual(data_sets_from_json["string"].category.id, 1)
        self.assertEqual(data_sets_from_json["string"].category.name, "Satellite")
        self.assertEqual(data_sets_from_json["string"].level, 0)
        self.assertEqual(data_sets_from_json["string"].crs, "string")
        self.assertEqual(data_sets_from_json["string"].dsource_h_link, "string")
        self.assertEqual(data_sets_from_json["string"].dsource_desc, "string")
        self.assertEqual(data_sets_from_json["string"].status, "Production")
        self.assertEqual(data_sets_from_json["string"].data_origin, "string")
        self.assertEqual(data_sets_from_json["string"].max_layers, 30)
        self.assertEqual(data_sets_from_json["string"].name_alternate, "ESA Sentinel 2 Level-2A")
        self.assertEqual(data_sets_from_json["string"].rating, 4.0)
        self.assertEqual(data_sets_from_json["string"].description_short, "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.")
        self.assertEqual(data_sets_from_json["string"].description_long, "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.")
        self.assertEqual(data_sets_from_json["string"].description_links[0], "https://sentinel.esa.int/web/sentinel/missions")
        self.assertEqual(data_sets_from_json["string"].description_links[1], "https://sentinel.esa.int/documents/247904/685211/Sentinel-2_User_Handbook")
        self.assertEqual(data_sets_from_json["string"].description_links[2], "https://sentinel.esa.int/web/sentinel/missions/sentinel-2/data-products")
        self.assertEqual(data_sets_from_json["string"].description_links[3], "https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi")
        self.assertEqual(data_sets_from_json["string"].data_source_name, "European Space Agency Sentinel-2")
        self.assertEqual(data_sets_from_json["string"].data_source_attribution, "'Copernicus Sentinel data [Year]' for Sentinel data; see https://lta.cr.usgs.gov/sites/default/files/Sentinel_Data_Terms_and_Conditions.pdf")
        self.assertEqual(data_sets_from_json["string"].data_source_description, "'Level-2A is generated by the Payload Data Ground Segment using the Sen2Cor processor. Level-2A products are made available to users via the Copernicus Open Access Hub: https://scihub.copernicus.eu/dhus/#/home")
        self.assertEqual(data_sets_from_json["string"].data_source_links[0], "https://sentinel.esa.int/web/sentinel/sentinel-data-access")
        self.assertEqual(data_sets_from_json["string"].update_interval_max, "1 day")
        self.assertEqual(data_sets_from_json["string"].update_interval_description, "Uploads are run daily. However, note the temporal resolution.")
        self.assertEqual(data_sets_from_json["string"].lag_horizon, "5 days")
        self.assertEqual(data_sets_from_json["string"].lag_horizon_description, "Data is available within 24 hours.")
        self.assertEqual(data_sets_from_json["string"].temporal_resolution, "5 days")
        self.assertEqual(data_sets_from_json["string"].temporal_resolution_description, "string")
        self.assertEqual(data_sets_from_json["string"].spatial_resolution_of_raw_data, "100m")
        self.assertEqual(data_sets_from_json["string"].interpolation, "near")
        self.assertEqual(data_sets_from_json["string"].dimensions_description, "The sole dimension is called \"horizon\" and refers to the forecast horizon in hours. (Only integer horizons are allowed.)")
        self.assertEqual(data_sets_from_json["string"].permanence, True)
        self.assertEqual(data_sets_from_json["string"].permanence_description, "Data with timestamp into the future will be update, but remain constant past current timestamp (except for error corrrection).")
        self.assertEqual(data_sets_from_json["string"].known_issues, "Updates are irregular.")
        self.assertEqual(data_sets_from_json["string"].responsible_organization, "<Your Organization>")
        self.assertEqual(data_sets_from_json["string"].properties.sector[0], "Animals/livestock")
        self.assertEqual(data_sets_from_json["string"].properties.sector[1], "Transportation/infrastructure")
        self.assertEqual(data_sets_from_json["string"].properties.sector[2], "Vegetation/crops")
        self.assertEqual(data_sets_from_json["string"].properties.sector[3], "Weather/climate")
        self.assertEqual(data_sets_from_json["string"].properties.application[0], "Agriculture")
        self.assertEqual(data_sets_from_json["string"].properties.domain[0], "Land surface")
        self.assertEqual(data_sets_from_json["string"].properties.type[0], "Data product")
        self.assertEqual(data_sets_from_json["string"].properties.source[0], "Satellite")
        self.assertEqual(data_sets_from_json["string"].properties.source[1], "Survey")
        self.assertEqual(data_sets_from_json["string"].spatial_coverage.country[0], "Belgium")
        self.assertEqual(data_sets_from_json["string"].spatial_coverage.country[1], "Bolivia")
        self.assertEqual(data_sets_from_json["string"].spatial_coverage.country[2], "France")
        self.assertEqual(data_sets_from_json["string"].spatial_coverage.country[3], "Germany")
        self.assertEqual(data_sets_from_json["string"].spatial_coverage.country[4], "India")
        self.assertEqual(data_sets_from_json["string"].spatial_coverage.country[5], "Indonesia")
        self.assertEqual(data_sets_from_json["string"].spatial_coverage.country[6], "Luxembourg")
        self.assertEqual(data_sets_from_json["string"].spatial_coverage.country[7], "Netherlands")
        self.assertEqual(data_sets_from_json["string"].spatial_coverage.country[8], "Switzerland")
        self.assertEqual(data_sets_from_json["string"].spatial_coverage.country[9], "Thailand")
        self.assertEqual(data_sets_from_json["string"].spatial_coverage.country[10], "United Kingdom")
        self.assertEqual(data_sets_from_json["string"].spatial_coverage.country[11], "United States of America")
        self.assertEqual(data_sets_from_json["string"].latitude_min, -90)
        self.assertEqual(data_sets_from_json["string"].longitude_min, -180)
        self.assertEqual(data_sets_from_json["string"].latitude_max, 90)
        self.assertEqual(data_sets_from_json["string"].longitude_max, 180)
        self.assertEqual(data_sets_from_json["string"].temporal_min, "2016-03-12T00:00:01.000Z")
        self.assertEqual(data_sets_from_json["string"].temporal_max, "2019-07-30T00:00:01.000Z")
        self.assertEqual(data_sets_from_json["string"].offering_status, "")
        
        self.assertEqual(data_sets_from_json["string2"].id, "string2")
        self.assertEqual(data_sets_from_json["string2"].name, "string2")
        self.assertEqual(data_sets_from_json["string2"].key, "string2")
        self.assertEqual(data_sets_from_json["string2"].category.id, 2)
        self.assertEqual(data_sets_from_json["string2"].category.name, "Satellite")
        self.assertEqual(data_sets_from_json["string2"].level, 1)
        self.assertEqual(data_sets_from_json["string2"].crs, "string2")
        self.assertEqual(data_sets_from_json["string2"].dsource_h_link, "string2")
        self.assertEqual(data_sets_from_json["string2"].dsource_desc, "string2")
        self.assertEqual(data_sets_from_json["string2"].status, "Production")
        self.assertEqual(data_sets_from_json["string2"].data_origin, "string2")
        self.assertEqual(data_sets_from_json["string2"].max_layers, 31)
        self.assertEqual(data_sets_from_json["string2"].name_alternate, "ESA Sentinel 2 Level-2A")
        self.assertEqual(data_sets_from_json["string2"].rating, 4.0)
        self.assertEqual(data_sets_from_json["string2"].description_short, "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.")
        self.assertEqual(data_sets_from_json["string2"].description_long, "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.")
        self.assertEqual(data_sets_from_json["string2"].description_links[0], "https://sentinel.esa.int/web/sentinel/missions2")
        self.assertEqual(data_sets_from_json["string2"].description_links[1], "https://sentinel.esa.int/documents/247904/685211/Sentinel-2_User_Handbook2")
        self.assertEqual(data_sets_from_json["string2"].description_links[2], "https://sentinel.esa.int/web/sentinel/missions/sentinel-2/data-products2")
        self.assertEqual(data_sets_from_json["string2"].description_links[3], "https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi2")
        self.assertEqual(data_sets_from_json["string2"].data_source_name, "European Space Agency Sentinel-2")
        self.assertEqual(data_sets_from_json["string2"].data_source_attribution, "'Copernicus Sentinel data [Year]' for Sentinel data; see https://lta.cr.usgs.gov/sites/default/files/Sentinel_Data_Terms_and_Conditions.pdf")
        self.assertEqual(data_sets_from_json["string2"].data_source_description, "'Level-2A is generated by the Payload Data Ground Segment using the Sen2Cor processor. Level-2A products are made available to users via the Copernicus Open Access Hub: https://scihub.copernicus.eu/dhus/#/home")
        self.assertEqual(data_sets_from_json["string2"].data_source_links[0], "https://sentinel.esa.int/web/sentinel/sentinel-data-access2")
        self.assertEqual(data_sets_from_json["string2"].update_interval_max, "1 day")
        self.assertEqual(data_sets_from_json["string2"].update_interval_description, "Uploads are run daily. However, note the temporal resolution.")
        self.assertEqual(data_sets_from_json["string2"].lag_horizon, "5 days")
        self.assertEqual(data_sets_from_json["string2"].lag_horizon_description, "Data is available within 24 hours.")
        self.assertEqual(data_sets_from_json["string2"].temporal_resolution, "5 days")
        self.assertEqual(data_sets_from_json["string2"].temporal_resolution_description, "string2")
        self.assertEqual(data_sets_from_json["string2"].spatial_resolution_of_raw_data, "100m")
        self.assertEqual(data_sets_from_json["string2"].interpolation, "near")
        self.assertEqual(data_sets_from_json["string2"].dimensions_description, "The sole dimension is called \"horizon\" and refers to the forecast horizon in hours. (Only integer horizons are allowed.)")
        self.assertEqual(data_sets_from_json["string2"].permanence, True)
        self.assertEqual(data_sets_from_json["string2"].permanence_description, "Data with timestamp into the future will be update, but remain constant past current timestamp (except for error corrrection).")
        self.assertEqual(data_sets_from_json["string2"].known_issues, "Updates are irregular.")
        self.assertEqual(data_sets_from_json["string2"].responsible_organization, "<Your Organization>")
        self.assertEqual(data_sets_from_json["string2"].properties.sector[0], "Animals/livestock2")
        self.assertEqual(data_sets_from_json["string2"].properties.sector[1], "Transportation/infrastructure2")
        self.assertEqual(data_sets_from_json["string2"].properties.sector[2], "Vegetation/crops2")
        self.assertEqual(data_sets_from_json["string2"].properties.sector[3], "Weather/climate2")
        self.assertEqual(data_sets_from_json["string2"].properties.application[0], "Agriculture2")
        self.assertEqual(data_sets_from_json["string2"].properties.domain[0], "Land surface2")
        self.assertEqual(data_sets_from_json["string2"].properties.type[0], "Data product2")
        self.assertEqual(data_sets_from_json["string2"].properties.source[0], "Satellite2")
        self.assertEqual(data_sets_from_json["string2"].properties.source[1], "Survey2")
        self.assertEqual(data_sets_from_json["string2"].spatial_coverage.country[0], "Belgium2")
        self.assertEqual(data_sets_from_json["string2"].spatial_coverage.country[1], "Bolivia2")
        self.assertEqual(data_sets_from_json["string2"].spatial_coverage.country[2], "France2")
        self.assertEqual(data_sets_from_json["string2"].spatial_coverage.country[3], "Germany2")
        self.assertEqual(data_sets_from_json["string2"].spatial_coverage.country[4], "India2")
        self.assertEqual(data_sets_from_json["string2"].spatial_coverage.country[5], "Indonesia2")
        self.assertEqual(data_sets_from_json["string2"].spatial_coverage.country[6], "Luxembourg2")
        self.assertEqual(data_sets_from_json["string2"].spatial_coverage.country[7], "Netherlands2")
        self.assertEqual(data_sets_from_json["string2"].spatial_coverage.country[8], "Switzerland2")
        self.assertEqual(data_sets_from_json["string2"].spatial_coverage.country[9], "Thailand2")
        self.assertEqual(data_sets_from_json["string2"].spatial_coverage.country[10], "United Kingdom2")
        self.assertEqual(data_sets_from_json["string2"].spatial_coverage.country[11], "United States of America2")
        self.assertEqual(data_sets_from_json["string2"].latitude_min, -180)
        self.assertEqual(data_sets_from_json["string2"].longitude_min, -90)
        self.assertEqual(data_sets_from_json["string2"].latitude_max, 180)
        self.assertEqual(data_sets_from_json["string2"].longitude_max, 90)
        self.assertEqual(data_sets_from_json["string2"].temporal_min, "1970-03-12T00:00:01.000Z")
        self.assertEqual(data_sets_from_json["string2"].temporal_max, "1970-07-30T00:00:01.000Z")
        self.assertEqual(data_sets_from_json["string2"].offering_status, "")
 
    #
    def test_data_sets_to_json(self):
        
        self.logger.info('test_data_sets_to_json')
        
        client = cl.Client()
        got_exception = False
        
        try:
            data_sets_from_json = catalog.data_sets_from_json(data_sets_str)
            data_sets_to_json = catalog.data_sets_to_json(data_sets_from_json)
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
    
    #    
    def test_data_sets_display(self):
        
        self.logger.info('test_data_set_display')
        
        try:
            data_sets_from_json2 = catalog.data_sets_from_json(data_sets_str)
            df = data_sets_from_json2.display()
        except Exception as ex:
            got_exception = True
            
        self.assertTrue(isinstance(df, pd.DataFrame))
        self.assertTrue(df.at[0,'id'], "string")
        self.assertTrue(df.at[0,'name'], "string")
        self.assertTrue(df.at[0,'description_short'], "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.")
        self.assertTrue(df.at[0,'description_long'], "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.")
        self.assertTrue(df.at[1,'id'], "string2")
        self.assertTrue(df.at[1,'name'], "string2")
        self.assertTrue(df.at[1,'description_short'], "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.")
        self.assertTrue(df.at[1,'description_long'], "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.")

        try:
            data_sets_from_json3 = catalog.data_sets_from_json(data_sets_str)
            df2 = data_sets_from_json3.display(columns = ['id', 'latitude_min', 'notacolumn'])
        except Exception as ex:
            got_exception = True

        self.assertTrue(df2.at[0,'id'], "string")
        self.assertTrue(df2.at[0,'latitude_min'], -90)
        self.assertTrue(df2.at[0, 'notacolumn'], "NaN")
        self.assertTrue(df2.at[1,'id'], "string2")
        self.assertTrue(df2.at[1,'latitude_min'], -180)
        self.assertTrue(df2.at[1, 'notacolumn'], "NaN")
    
    # mocked_data_sets_requests_get
    @mock.patch('ibmpairs.client.Client.get', 
                side_effect=mocked_data_sets_requests_get
               )
    def test_data_sets_get(self, mock_delete):
        
        self.logger.info('test_data_sets_get: success')
        
        ds = catalog.DataSets()
                        
        got_exception = False

        try:
            result = ds.get()
        except Exception as ex:
            got_exception = True
            
        self.assertFalse(got_exception)
        
        self.assertEqual(result["string"].id, "string")
        self.assertEqual(result["string"].name_alternate, "ESA Sentinel 2 Level-2A")
        self.assertEqual(result["string2"].id, "string2")
        self.assertEqual(result["string2"].name_alternate, "ESA Sentinel 2 Level-2A")
        
        self.logger.info('test_data_sets_get: fail 404')
        
        ds2 = catalog.DataSets()
                        
        got_exception2 = False

        try:
            result = ds2.get()
        except Exception as ex:
            got_exception2 = True
            self.assertEqual(str(ex), "The GET request call to https://pairs.res.ibm.com/v2/datasets/full failed with status code: 404, message: failed.")
            
        self.assertTrue(got_exception2)
        
        self.logger.info('test_data_sets_get: fail server error')
        
        ds3 = catalog.DataSets()
                        
        got_exception3 = False

        try:
            result = ds3.get()
        except Exception as ex:
            got_exception3 = True
            self.assertEqual(str(ex), "The GET request to https://pairs.res.ibm.com/v2/datasets/full encountered an unspecified error contacting the server; the request was unsuccessful, error message: __init__() got an unexpected keyword argument 'status'")

        self.assertTrue(got_exception3)
        
        self.logger.info('test_data_sets_get: helper, success')
                        
        got_exception6 = False

        try:
            result2 = catalog.get_data_sets()
        except Exception as ex:
            got_exception6 = True
            
        self.assertFalse(got_exception6)
        
        self.assertEqual(result2["string"].id, "string")
        self.assertEqual(result2["string"].name_alternate, "ESA Sentinel 2 Level-2A")
        self.assertEqual(result2["string2"].id, "string2")
        self.assertEqual(result2["string2"].name_alternate, "ESA Sentinel 2 Level-2A")
  
        
data_set_return_dict = {
    "datasetId": 0,
    "status": 0,
    "message": "string"
}

data_set_return_str = r'''{
    "data_set_id": 0,
    "status": 0,
    "message": "string"
}'''

#
class DataSetReturnUnitTest(unittest.TestCase):
    
    #
    def setUp(self):
        self.logger = logger
        self.logger.info('setup')
    
    #
    def tearDown(self):
        self.logger.info('teardown')

    #    
    def test_data_set_return_from_dict(self):
        
        self.logger.info('test_data_set_return_from_dict')
        
        data_set_return = catalog.DataSetReturn

        data_set_return_from_dict = None
            
        got_exception = False

        try:
            data_set_return_from_dict = data_set_return.from_dict(data_set_return_dict)
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        self.assertEqual(data_set_return_from_dict.data_set_id, "0")
        self.assertEqual(data_set_return_from_dict.status, 0)
        self.assertEqual(data_set_return_from_dict.message, "string")

    #    
    def test_data_set_return_to_dict(self):
        
        self.logger.info('test_data_set_return_to_dict')
        
        data_set_return = catalog.DataSetReturn

        data_set_return_from_dict = None
        data_set_return_to_dict   = None
                
        got_exception = False

        try:
            data_set_return_from_dict = data_set_return.from_dict(data_set_return_dict)
            data_set_return_to_dict = data_set_return_from_dict.to_dict()
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        self.assertIsInstance(data_set_return_to_dict, dict)
        self.assertEqual(data_set_return_to_dict["data_set_id"], "0")
        self.assertEqual(data_set_return_to_dict["status"], 0)
        self.assertEqual(data_set_return_to_dict["message"], "string")
        
    #
    def test_data_set_return_from_json(self):
        
        self.logger.info('test_data_set_return_from_json')

        got_exception = False

        try:
            data_set_return_from_json = catalog.data_set_return_from_json(data_set_return_str)
        except Exception as ex:
            self.logger.info(ex)
            got_exception = True

        self.assertFalse(got_exception)
        self.assertEqual(data_set_return_from_json.data_set_id, "0")
        self.assertEqual(data_set_return_from_json.status, 0)
        self.assertEqual(data_set_return_from_json.message, "string")
 
    #
    def test_data_set_return_to_json(self):
        
        self.logger.info('test_data_set_return_to_json')

        got_exception = False
        
        try:
            data_set_return_from_json = catalog.data_set_return_from_json(data_set_return_str)
            data_set_return_to_json = catalog.data_set_return_to_json(data_set_return_from_json)
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)

color_table_dict = {
    "id": "32451",
    "name": "string",
    "colors": "string"
}

color_table_str = r'''{
    "id": "32451",
    "name": "string",
    "colors": "string"
}'''

#
class ColorTableUnitTest(unittest.TestCase):
    
    #
    def setUp(self):
        self.logger = logger
        self.logger.info('setup')
    
    #
    def tearDown(self):
        self.logger.info('teardown')

    #    
    def test_color_table_from_dict(self):
        
        self.logger.info('test_color_table_from_dict')
        
        color_table = catalog.ColorTable

        color_table_from_dict = None
            
        got_exception = False

        try:
            color_table_from_dict = color_table.from_dict(color_table_dict)
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        self.assertEqual(color_table_from_dict.id, "32451")
        self.assertEqual(color_table_from_dict.name, "string")
        self.assertEqual(color_table_from_dict.colors, "string")

    #    
    def test_color_table_to_dict(self):
        
        self.logger.info('test_color_table_to_dict')
        
        color_table = catalog.ColorTable

        color_table_from_dict = None
        color_table_to_dict   = None
                
        got_exception = False

        try:
            color_table_from_dict = color_table.from_dict(color_table_dict)
            color_table_to_dict = color_table_from_dict.to_dict()
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        self.assertIsInstance(color_table_to_dict, dict)
        self.assertEqual(color_table_to_dict["id"], "32451")
        self.assertEqual(color_table_to_dict["name"], "string")
        self.assertEqual(color_table_to_dict["colors"], "string")
        
    #
    def test_color_table_from_json(self):
        
        self.logger.info('test_color_table_from_json')

        got_exception = False

        try:
            color_table_from_json = catalog.color_table_from_json(color_table_str)
        except Exception as ex:
            self.logger.info(ex)
            got_exception = True

        self.assertFalse(got_exception)
        self.assertEqual(color_table_from_json.id, "32451")
        self.assertEqual(color_table_from_json.name, "string")
        self.assertEqual(color_table_from_json.colors, "string")
 
    #
    def test_color_table_to_json(self):
        
        self.logger.info('test_color_table_to_json')

        got_exception = False
        
        try:
            color_table_from_json = catalog.color_table_from_json(color_table_str)
            color_table_to_json = catalog.color_table_to_json(color_table_from_json)
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        
data_layer_return_dict = {
    "datalayerIds": [
        87234,
        87235,
        872346
    ],
    "status": 200,
    "message": "Datalayer(s) created successfully"
}

data_layer_return_str = r'''{
    "data_layer_ids": [
        87234,
        87235,
        872346
    ],
    "status": 200,
    "message": "Datalayer(s) created successfully"
}'''

#
class DataLayerReturnUnitTest(unittest.TestCase):
    
    #
    def setUp(self):
        self.logger = logger
        self.logger.info('setup')
    
    #
    def tearDown(self):
        self.logger.info('teardown')

    #    
    def test_data_layer_return_from_dict(self):
        
        self.logger.info('test_data_layer_return_from_dict')
        
        data_layer_return = catalog.DataLayerReturn

        data_layer_return_from_dict = None
            
        got_exception = False

        try:
            data_layer_return_from_dict = data_layer_return.from_dict(data_layer_return_dict)
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        self.assertEqual(data_layer_return_from_dict.data_layer_ids[0], "87234")
        self.assertEqual(data_layer_return_from_dict.data_layer_ids[1], "87235")
        self.assertEqual(data_layer_return_from_dict.data_layer_ids[2], "872346")
        self.assertEqual(data_layer_return_from_dict.status, 200)
        self.assertEqual(data_layer_return_from_dict.message, "Datalayer(s) created successfully")

    #    
    def test_data_layer_return_to_dict(self):
        
        self.logger.info('test_data_layer_return_to_dict')
        
        data_layer_return = catalog.DataLayerReturn

        data_layer_return_from_dict = None
        data_layer_return_to_dict   = None
                
        got_exception = False

        try:
            data_layer_return_from_dict = data_layer_return.from_dict(data_layer_return_dict)
            data_layer_return_to_dict = data_layer_return_from_dict.to_dict()
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        self.assertIsInstance(data_layer_return_to_dict, dict)
        self.assertEqual(data_layer_return_to_dict["data_layer_ids"][0], "87234")
        self.assertEqual(data_layer_return_to_dict["data_layer_ids"][1], "87235")
        self.assertEqual(data_layer_return_to_dict["data_layer_ids"][2], "872346")
        self.assertEqual(data_layer_return_to_dict["status"], 200)
        self.assertEqual(data_layer_return_to_dict["message"], "Datalayer(s) created successfully")
        
    #
    def test_data_layer_return_from_json(self):
        
        self.logger.info('test_data_layer_return_from_json')

        got_exception = False

        try:
            data_layer_return_from_json = catalog.data_layer_return_from_json(data_layer_return_str)
        except Exception as ex:
            self.logger.info(ex)
            got_exception = True

        self.assertFalse(got_exception)
        self.assertEqual(data_layer_return_from_json.data_layer_ids[0], "87234")
        self.assertEqual(data_layer_return_from_json.data_layer_ids[1], "87235")
        self.assertEqual(data_layer_return_from_json.data_layer_ids[2], "872346")
        self.assertEqual(data_layer_return_from_json.status, 200)
        self.assertEqual(data_layer_return_from_json.message, "Datalayer(s) created successfully")
 
    #
    def test_data_layer_return_to_json(self):
        
        self.logger.info('test_data_layer_return_to_json')

        got_exception = False
        
        try:
            data_layer_return_from_json = catalog.data_layer_return_from_json(data_layer_return_str)
            data_layer_return_to_json = catalog.data_layer_return_to_json(data_layer_return_from_json)
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)

data_layer_dimension_return_dict = {
    "datalayerDimensionId": 47134,
    "status": 200,
    "message": "Datalayer dimension created successfully"
}

data_layer_dimension_return_str = r'''{
    "data_layer_dimension_id": 47134,
    "status": 200,
    "message": "Datalayer dimension created successfully"
}'''

#
class DataLayerDimensionReturnUnitTest(unittest.TestCase):
    
    #
    def setUp(self):
        self.logger = logger
        self.logger.info('setup')
    
    #
    def tearDown(self):
        self.logger.info('teardown')

    #    
    def test_data_layer_dimension_return_from_dict(self):
        
        self.logger.info('test_data_layer_dimension_return_from_dict')
        
        data_layer_dimension_return = catalog.DataLayerDimensionReturn

        data_layer_dimension_return_from_dict = None
            
        got_exception = False

        try:
            data_layer_dimension_return_from_dict = data_layer_dimension_return.from_dict(data_layer_dimension_return_dict)
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        self.assertEqual(data_layer_dimension_return_from_dict.data_layer_dimension_id, "47134")
        self.assertEqual(data_layer_dimension_return_from_dict.status, 200)
        self.assertEqual(data_layer_dimension_return_from_dict.message, "Datalayer dimension created successfully")

    #    
    def test_data_layer_dimension_return_to_dict(self):
        
        self.logger.info('test_data_layer_dimension_return_to_dict')
        
        data_layer_dimension_return = catalog.DataLayerDimensionReturn

        data_layer_dimension_return_from_dict = None
        data_layer_dimension_return_to_dict   = None
                
        got_exception = False

        try:
            data_layer_dimension_return_from_dict = data_layer_dimension_return.from_dict(data_layer_dimension_return_dict)
            data_layer_dimension_return_to_dict = data_layer_dimension_return_from_dict.to_dict()
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        self.assertIsInstance(data_layer_dimension_return_to_dict, dict)
        self.assertEqual(data_layer_dimension_return_to_dict["data_layer_dimension_id"], "47134")
        self.assertEqual(data_layer_dimension_return_to_dict["status"], 200)
        self.assertEqual(data_layer_dimension_return_to_dict["message"], "Datalayer dimension created successfully")
        
    #
    def test_data_layer_dimension_return_from_json(self):
        
        self.logger.info('test_data_layer_dimension_return_from_json')

        got_exception = False

        try:
            data_layer_dimension_return_from_json = catalog.data_layer_dimension_return_from_json(data_layer_dimension_return_str)
        except Exception as ex:
            self.logger.info(ex)
            got_exception = True

        self.assertFalse(got_exception)
        self.assertEqual(data_layer_dimension_return_from_json.data_layer_dimension_id, "47134")
        self.assertEqual(data_layer_dimension_return_from_json.status, 200)
        self.assertEqual(data_layer_dimension_return_from_json.message, "Datalayer dimension created successfully")
 
    #
    def test_data_layer_dimension_return_to_json(self):
        
        self.logger.info('test_data_layer_dimension_return_to_json')

        got_exception = False
        
        try:
            data_layer_dimension_return_from_json = catalog.data_layer_dimension_return_from_json(data_layer_dimension_return_str)
            data_layer_dimension_return_to_json = catalog.data_layer_dimension_return_to_json(data_layer_dimension_return_from_json)
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)

data_layer_dimension_dict = {
    "id": 0,
    "order": 0,
    "fullName": "string",
    "shortName": "string",
    "type": "string",
    "identifier": "string",
    "unit": "string"
}

data_layer_dimension_str = r'''{
    "id": 0,
    "order": 0,
    "full_name": "string",
    "short_name": "string",
    "type": "string",
    "identifier": "string",
    "unit": "string"
}'''

data_layer_dimension_requests_post_success_dict = {
    "fullName": "Forecast Horizon",
    "shortName": "horizon",
    "type": "integer",
    "unit": "day"
}

#
class DataLayerDimensionUnitTest(unittest.TestCase):
    
    #
    def setUp(self):
        self.logger = logger
        self.logger.info('setup')
        
        client = cl.Client()
    
    #
    def tearDown(self):
        self.logger.info('teardown')

    #    
    def test_data_layer_dimension_from_dict(self):
        
        self.logger.info('test_data_layer_dimension_from_dict')
        
        data_layer_dimension = catalog.DataLayerDimension

        data_layer_dimension_from_dict = None
            
        got_exception = False

        try:
            data_layer_dimension_from_dict = data_layer_dimension.from_dict(data_layer_dimension_dict)
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        self.assertEqual(data_layer_dimension_from_dict.id, "0")
        self.assertEqual(data_layer_dimension_from_dict.order, 0)
        self.assertEqual(data_layer_dimension_from_dict.full_name, "string")
        self.assertEqual(data_layer_dimension_from_dict.short_name, "string")
        self.assertEqual(data_layer_dimension_from_dict.type, "string")
        self.assertEqual(data_layer_dimension_from_dict.identifier, "string")
        self.assertEqual(data_layer_dimension_from_dict.unit, "string")

    #    
    def test_data_layer_dimension_to_dict(self):
        
        self.logger.info('test_data_layer_dimension_to_dict')
        
        data_layer_dimension = catalog.DataLayerDimension

        data_layer_dimension_from_dict = None
        data_layer_dimension_to_dict   = None
                
        got_exception = False

        try:
            data_layer_dimension_from_dict = data_layer_dimension.from_dict(data_layer_dimension_dict)
            data_layer_dimension_to_dict = data_layer_dimension_from_dict.to_dict()
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        self.assertIsInstance(data_layer_dimension_to_dict, dict)
        self.assertEqual(data_layer_dimension_to_dict["id"], "0")
        self.assertEqual(data_layer_dimension_to_dict["order"], 0)
        self.assertEqual(data_layer_dimension_to_dict["full_name"], "string")
        self.assertEqual(data_layer_dimension_to_dict["short_name"], "string")
        self.assertEqual(data_layer_dimension_to_dict["type"], "string")
        self.assertEqual(data_layer_dimension_to_dict["identifier"], "string")
        self.assertEqual(data_layer_dimension_to_dict["unit"], "string")
        
    #    
    def test_data_layer_dimension_to_dict_data_layer_dimension_post(self):
        
        self.logger.info('test_data_layer_dimension_to_dict_data_layer_dimension_post')
        
        data_layer_dimension2 = catalog.DataLayerDimension

        data_layer_dimension_from_dict = None
        data_layer_dimension_to_dict   = None
                
        got_exception = False

        try:
            data_layer_dimension_from_dict2 = data_layer_dimension2.from_dict(data_layer_dimension_dict)
            data_layer_dimension_to_dict_data_layer_dimension_post = data_layer_dimension_from_dict2.to_dict_data_layer_dimension_post()
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        self.assertIsInstance(data_layer_dimension_to_dict_data_layer_dimension_post, dict)
        self.assertEqual(data_layer_dimension_to_dict_data_layer_dimension_post["fullName"], "string")
        self.assertEqual(data_layer_dimension_to_dict_data_layer_dimension_post["shortName"], "string")
        self.assertEqual(data_layer_dimension_to_dict_data_layer_dimension_post["type"], "string")
        self.assertEqual(data_layer_dimension_to_dict_data_layer_dimension_post["unit"], "string")
        
    #
    def test_data_layer_dimension_from_json(self):
        
        self.logger.info('test_data_layer_dimension_from_json')

        got_exception = False

        try:
            data_layer_dimension_from_json = catalog.data_layer_dimension_from_json(data_layer_dimension_str)
        except Exception as ex:
            self.logger.info(ex)
            got_exception = True

        self.assertFalse(got_exception)
        self.assertEqual(data_layer_dimension_from_json.id, "0")
        self.assertEqual(data_layer_dimension_from_json.order, 0)
        self.assertEqual(data_layer_dimension_from_json.full_name, "string")
        self.assertEqual(data_layer_dimension_from_json.short_name, "string")
        self.assertEqual(data_layer_dimension_from_json.type, "string")
        self.assertEqual(data_layer_dimension_from_json.identifier, "string")
        self.assertEqual(data_layer_dimension_from_json.unit, "string")
 
    #
    def test_data_layer_dimension_to_json(self):
        
        self.logger.info('test_data_layer_dimension_to_json')

        got_exception = False
        
        try:
            data_layer_dimension_from_json = catalog.data_layer_dimension_from_json(data_layer_dimension_str)
            data_layer_dimension_to_json = catalog.data_layer_dimension_to_json(data_layer_dimension_from_json)
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
    
    #
    def test_data_layer_dimension_to_json_data_layer_dimension_post(self):
        
        self.logger.info('test_data_layer_dimension_to_json_data_layer_dimension_post')

        got_exception = False
        
        try:
            data_layer_dimension_from_json2 = catalog.data_layer_dimension_from_json(data_layer_dimension_str)
            data_layer_dimension_to_json_data_layer_dimension_post = catalog.data_layer_dimension_to_json_post(data_layer_dimension_from_json2)
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        
    #
    def test_data_layer_dimension_display(self):
        
        self.logger.info('test_data_layer_dimension_display')
        
        try:
            data_layer_dimension_from_json3 = catalog.data_layer_dimension_from_json(data_layer_dimension_str)
            df = data_layer_dimension_from_json3.display()
        except Exception as ex:
            got_exception = True
            
        self.assertTrue(isinstance(df, pd.DataFrame))
        self.assertTrue(df.at[0,'id'], "0")
        self.assertTrue(df.at[0,'full_name'], "string")
        self.assertTrue(df.at[0,'short_name'], "string")
        self.assertTrue(df.at[0,'type'], "string")
        self.assertTrue(df.at[0,'identifier'], "string")
        self.assertTrue(df.at[0,'unit'], "string")

        try:
            data_layer_dimension_from_json4 = catalog.data_layer_dimension_from_json(data_layer_dimension_str)
            df2 = data_layer_dimension_from_json4.display(columns = ['id', 'short_name', 'notacolumn'])
        except Exception as ex:
            got_exception = True
        
        self.assertTrue(df2.at[0,'id'], "0")
        self.assertTrue(df2.at[0,'short_name'], "string")
        self.assertTrue(df2.at[0,'notacolumn'], "NaN")
    
    # mocked_data_layer_dimension_requests_get
    @mock.patch('ibmpairs.client.Client.get', 
                side_effect=mocked_data_layer_dimension_requests_get
               )
    def test_data_layer_dimension_get(self, mock_get):
        
        self.logger.info('test_data_layer_dimension_get: success')
        
        dld = catalog.DataLayerDimension()
                        
        got_exception = False

        try:
            result = dld.get(id = "1")
        except Exception as ex:
            got_exception = True
            
        self.assertFalse(got_exception)
        
        self.assertEqual(result.id, "0")
        self.assertEqual(result.order, 0)
        self.assertEqual(result.full_name, "string")
        self.assertEqual(result.short_name, "string")
        self.assertEqual(result.type, "string")
        self.assertEqual(result.identifier, "string")
        self.assertEqual(result.unit, "string")
        
        self.logger.info('test_data_layer_dimension_get: id already in object')
        
        dld5 = catalog.DataLayerDimension()
                        
        got_exception5 = False

        try:
            dld5.id = "1"
            result = dld5.get()
        except Exception as ex:
            got_exception5 = True
            
        self.assertFalse(got_exception5)
        
        self.logger.info('test_data_layer_dimension_get: fail 404')
        
        dld2 = catalog.DataLayerDimension()
                        
        got_exception2 = False

        try:
            result = dld2.get(id = "2")
        except Exception as ex:
            got_exception2 = True
            self.assertEqual(str(ex), "The GET request call to https://pairs.res.ibm.com/v2/datalayer_dimensions/2 failed with status code: 404, message: failed.")
            
        self.assertTrue(got_exception2)
        
        self.logger.info('test_data_layer_dimension_get: fail server error')
        
        dld3 = catalog.DataLayerDimension()
                        
        got_exception3 = False

        try:
            result = dld3.get(id = "3")
        except Exception as ex:
            got_exception3 = True
            self.assertEqual(str(ex), "The GET request to https://pairs.res.ibm.com/v2/datalayer_dimensions/3 encountered an unspecified error contacting the server; the request was unsuccessful, error message: __init__() got an unexpected keyword argument 'status'")

        self.assertTrue(got_exception3)
        
        self.logger.info('test_data_layer_dimension_get: fail no id')
        
        dld4 = catalog.DataLayerDimension()
                        
        got_exception4 = False

        try:
            result = dld4.get()
        except Exception as ex:
            got_exception4 = True
            self.assertEqual(str(ex), "The DataLayerDimension object has no ID set and none was provided.")

        self.assertTrue(got_exception4)
        
        self.logger.info('test_data_layer_dimension_get: helper, success')
                        
        got_exception6 = False

        try:
            result2 = catalog.get_data_layer_dimension(id = "1")
        except Exception as ex:
            got_exception6 = True
            
        self.assertFalse(got_exception6)
        
        self.assertEqual(result2.id, "0")
        self.assertEqual(result2.order, 0)
        self.assertEqual(result2.full_name, "string")
        self.assertEqual(result2.short_name, "string")
        self.assertEqual(result2.type, "string")
        self.assertEqual(result2.identifier, "string")
        self.assertEqual(result.unit, "string")
        
    # mocked_data_layer_dimension_requests_post
    @mock.patch('ibmpairs.client.Client.post', 
                side_effect=mocked_data_layer_dimension_requests_post
               )
    def test_data_layer_dimension_create(self, mock_post):
        
        self.logger.info('test_data_layer_dimension_create: success')
        
        got_exception = False

        try:
            data_layer_dimension_create = catalog.data_layer_dimension_from_json(data_layer_dimension_requests_post_success_dict)
            data_layer_dimension_create.create(data_layer_id = 1)
        except Exception as ex:
            self.logger.info(ex)        
            got_exception = True
            
        self.assertFalse(got_exception)
        self.assertEqual(data_layer_dimension_create.data_layer_dimension_response.data_layer_dimension_id, "100")
        self.assertEqual(data_layer_dimension_create.data_layer_dimension_response.status, 200)
        self.assertEqual(data_layer_dimension_create.data_layer_dimension_response.message, "Datalayer dimension created successfully")
        
        self.logger.info('test_data_layer_dimension_create: fail 404')
        
        got_exception2 = False

        try:
            data_layer_dimension_create2 = catalog.data_layer_dimension_from_json(data_layer_dimension_requests_post_success_dict)
            data_layer_dimension_create2.name = "string2"
            dlds2 = data_layer_dimension_create2.create(data_layer_id = 2)
        except Exception as ex:
            self.logger.info(ex)
            self.assertEqual(str(ex), "The POST request call to https://pairs.res.ibm.com/v2/datalayers/2/datalayer_dimensions failed with status code: 404, message: failed.")
            got_exception2 = True
            
        self.assertTrue(got_exception2)
        
        self.logger.info('test_data_layer_dimension_create: fail server error')
        
        got_exception3 = False

        try:
           data_layer_dimension_create3 = catalog.data_layer_dimension_from_json(data_layer_dimension_requests_post_success_dict)
           data_layer_dimension_create3.name = "string3"
           dld3 = data_layer_dimension_create3.create(data_layer_id = 3)
        except Exception as ex:
            self.logger.info(ex)
            self.assertEqual(str(ex), "The POST request to https://pairs.res.ibm.com/v2/datalayers/3/datalayer_dimensions encountered an unspecified error contacting the server; the request was unsuccessful, error message: __init__() got an unexpected keyword argument 'status'")
            got_exception3 = True
            
        self.assertTrue(got_exception3)
        
        self.logger.info('test_data_layer_dimension_create: helper, success')
        
        got_exception4 = False

        try:
            data_layer_dimension_create4 = catalog.data_layer_dimension_from_json(data_layer_dimension_requests_post_success_dict)
            helper = catalog.create_data_layer_dimension(data_layer_dimension = data_layer_dimension_create4,
                                                    data_layer_id = 1)
        except Exception as ex:
            self.logger.info(ex)        
            got_exception4 = True
            
        self.assertFalse(got_exception4)
        self.assertEqual(helper.data_layer_dimension_response.data_layer_dimension_id, "100")
        self.assertEqual(helper.data_layer_dimension_response.status, 200)
        self.assertEqual(helper.data_layer_dimension_response.message, "Datalayer dimension created successfully")

data_layer_dimensions_dict = [
    {
        "id": 0,
        "order": 0,
        "full_name": "string",
        "short_name": "string",
        "type": "string",
        "identifier": "string",
        "unit": "string"
    },
    {
        "id": 1,
        "order": 1,
        "full_name": "string2",
        "short_name": "string2",
        "type": "string2",
        "identifier": "string2",
        "unit": "string2"
    }
]

data_layer_dimensions_str = r'''[
    {
        "id": 0,
        "order": 0,
        "full_name": "string",
        "short_name": "string",
        "type": "string",
        "identifier": "string",
        "unit": "string"
    },
    {
        "id": 1,
        "order": 1,
        "full_name": "string2",
        "short_name": "string2",
        "type": "string2",
        "identifier": "string2",
        "unit": "string2"
    }
]'''

data_layer_dimensions_multi_name_dict = [
    {
        "full_name": "abc",
    },
    {
        "full_name": "abc",
    }
]

data_layer_dimensions_obj_repr_dict = {
    "data_layer_dimensions": [
        {
            "full_name": "abc",
        },
        {
            "full_name": "abc2",
        }
    ]
}

#
class DataLayerDimensionsUnitTest(unittest.TestCase):
    
    #
    def setUp(self):
        self.logger = logger
        self.logger.info('setup')
        
        client = cl.Client()
    
    #
    def tearDown(self):
        self.logger.info('teardown')

    #    
    def test_data_layer_dimensions_from_dict(self):
        
        self.logger.info('test_data_layer_dimensions_from_dict')
        
        data_layer_dimensions = catalog.DataLayerDimensions

        data_layer_dimensions_from_dict = None
            
        got_exception = False

        try:
            data_layer_dimensions_from_dict = data_layer_dimensions.from_dict(data_layer_dimensions_dict)
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        self.assertEqual(data_layer_dimensions_from_dict["string"].id, "0")
        self.assertEqual(data_layer_dimensions_from_dict["string"].order, 0)
        self.assertEqual(data_layer_dimensions_from_dict["string"].full_name, "string")
        self.assertEqual(data_layer_dimensions_from_dict["string"].short_name, "string")
        self.assertEqual(data_layer_dimensions_from_dict["string"].type, "string")
        self.assertEqual(data_layer_dimensions_from_dict["string"].identifier, "string")
        self.assertEqual(data_layer_dimensions_from_dict["string"].unit, "string")
        
        self.assertEqual(data_layer_dimensions_from_dict["string2"].id, "1")
        self.assertEqual(data_layer_dimensions_from_dict["string2"].order, 1)
        self.assertEqual(data_layer_dimensions_from_dict["string2"].full_name, "string2")
        self.assertEqual(data_layer_dimensions_from_dict["string2"].short_name, "string2")
        self.assertEqual(data_layer_dimensions_from_dict["string2"].type, "string2")
        self.assertEqual(data_layer_dimensions_from_dict["string2"].identifier, "string2")
        self.assertEqual(data_layer_dimensions_from_dict["string2"].unit, "string2")
        
        self.logger.info('data_layer_dimensions_from_dict: no overload')
        
        self.assertEqual(data_layer_dimensions_from_dict.data_layer_dimensions[0].full_name, "string")
        self.assertEqual(data_layer_dimensions_from_dict.data_layer_dimensions[1].full_name, "string2")
        
        self.logger.info('data_layer_dimensions_from_dict: set overload')
        
        data_layer_dimensions_from_dict["string"].id = "newstring"
        data_layer_dimensions_from_dict["string2"].id = "newstring2"
        data_layer_dimensions_from_dict["string"].full_name = "newstring"
        data_layer_dimensions_from_dict["string2"].full_name = "newstring2"
        
        self.assertEqual(data_layer_dimensions_from_dict["newstring"].full_name, "newstring")
        self.assertEqual(data_layer_dimensions_from_dict["newstring2"].full_name, "newstring2")
        self.assertEqual(data_layer_dimensions_from_dict["newstring"].id, "newstring")
        self.assertEqual(data_layer_dimensions_from_dict["newstring2"].id, "newstring2")
        
        self.logger.info('data_layer_dimensions_from_dict: set no overload')
        
        data_layer_dimensions_from_dict[0].id = "newnewstring"
        data_layer_dimensions_from_dict[1].id = "newnewstring2"
        data_layer_dimensions_from_dict[0].full_name = "newnewstring"
        data_layer_dimensions_from_dict[1].full_name = "newnewstring2"
        
        self.assertEqual(data_layer_dimensions_from_dict["newnewstring"].full_name, "newnewstring")
        self.assertEqual(data_layer_dimensions_from_dict["newnewstring2"].full_name, "newnewstring2")
        self.assertEqual(data_layer_dimensions_from_dict["newnewstring"].id, "newnewstring")
        self.assertEqual(data_layer_dimensions_from_dict["newnewstring2"].id, "newnewstring2")
        self.assertEqual(data_layer_dimensions_from_dict[0].full_name, "newnewstring")
        self.assertEqual(data_layer_dimensions_from_dict[1].full_name, "newnewstring2")
        self.assertEqual(data_layer_dimensions_from_dict[0].id, "newnewstring")
        self.assertEqual(data_layer_dimensions_from_dict[1].id, "newnewstring2")
        
        data_layer_dimensions_multi_name = catalog.DataLayerDimensions

        data_layer_dimensions_multi_name_from_dict = None
            
        got_exception2 = False

        try:
            data_layer_dimensions_multi_name_from_dict = data_layer_dimensions_multi_name.from_dict(data_layer_dimensions_multi_name_dict)
        except Exception as ex:
            got_exception2 = True

        self.assertFalse(got_exception2)
        
        got_exception3 = False
        
        try:
            data_layer_dimensions_multi_name_from_dict["ab"].full_name = "abc"
        except Exception as ex:
            got_exception3 = True
            
        self.assertTrue(got_exception3)
        
        got_exception4 = False
        
        try:
            data_layer_dimensions_multi_name_from_dict["abc"].full_name = "abc"
        except Exception as ex:
            got_exception4 = True
            
        self.assertTrue(got_exception4)
        
        got_exception5 = False
        
        try:
            d = {}
            data_layer_dimensions_multi_name_from_dict[d].full_name = "abc"
        except Exception as ex:
            got_exception5 = True
            
        self.assertTrue(got_exception5)
        
        got_exception6 = False
        
        try:
            data_layer_dimensions_multi_name_from_dict[0].full_name = "abcd"
        except Exception as ex:
            got_exception6 = True
            
        self.assertFalse(got_exception6)
        
        self.assertEqual(data_layer_dimensions_multi_name_from_dict[0].full_name, "abcd")
        self.assertEqual(data_layer_dimensions_multi_name_from_dict[1].full_name, "abc")
        
        got_exception7 = False
        
        try:
            data_layer_dimensions_multi_name_from_dict["abc"].full_name = "efg"
        except Exception as ex:
            got_exception7 = True
            
        self.assertFalse(got_exception7)
        
        self.assertEqual(data_layer_dimensions_multi_name_from_dict[0].full_name, "abcd")
        self.assertEqual(data_layer_dimensions_multi_name_from_dict[1].full_name, "efg")
        
        data_layer_dimensions_obj_repr = catalog.DataLayerDimensions

        data_layer_dimensions_obj_repr_from_dict = None
        
        got_exception8 = False

        try:
            data_layer_dimensions_obj_repr_from_dict = data_layer_dimensions_obj_repr.from_dict(data_layer_dimensions_obj_repr_dict)
        except Exception as ex:
            got_exception8 = True

        self.assertFalse(got_exception8)
        
        self.assertEqual(data_layer_dimensions_obj_repr_from_dict[0].full_name, "abc")
        self.assertEqual(data_layer_dimensions_obj_repr_from_dict[1].full_name, "abc2")

    #    
    def test_data_layer_dimensions_to_dict(self):
        
        self.logger.info('test_data_layer_dimensions_to_dict')
        
        data_layer_dimensions = catalog.DataLayerDimensions

        data_layer_dimensions_from_dict = None
        data_layer_dimensions_to_dict   = None
                
        got_exception = False

        try:
            data_layer_dimensions_from_dict = data_layer_dimensions.from_dict(data_layer_dimensions_dict)
            data_layer_dimensions_to_dict = data_layer_dimensions_from_dict.to_dict()
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        self.assertIsInstance(data_layer_dimensions_to_dict, dict)
        self.assertEqual(data_layer_dimensions_to_dict["data_layer_dimensions"][0]["id"], "0")
        self.assertEqual(data_layer_dimensions_to_dict["data_layer_dimensions"][0]["order"], 0)
        self.assertEqual(data_layer_dimensions_to_dict["data_layer_dimensions"][0]["full_name"], "string")
        self.assertEqual(data_layer_dimensions_to_dict["data_layer_dimensions"][0]["short_name"], "string")
        self.assertEqual(data_layer_dimensions_to_dict["data_layer_dimensions"][0]["type"], "string")
        self.assertEqual(data_layer_dimensions_to_dict["data_layer_dimensions"][0]["identifier"], "string")
        self.assertEqual(data_layer_dimensions_to_dict["data_layer_dimensions"][0]["unit"], "string")
        
        self.assertEqual(data_layer_dimensions_to_dict["data_layer_dimensions"][1]["id"], "1")
        self.assertEqual(data_layer_dimensions_to_dict["data_layer_dimensions"][1]["order"], 1)
        self.assertEqual(data_layer_dimensions_to_dict["data_layer_dimensions"][1]["full_name"], "string2")
        self.assertEqual(data_layer_dimensions_to_dict["data_layer_dimensions"][1]["short_name"], "string2")
        self.assertEqual(data_layer_dimensions_to_dict["data_layer_dimensions"][1]["type"], "string2")
        self.assertEqual(data_layer_dimensions_to_dict["data_layer_dimensions"][1]["identifier"], "string2")
        self.assertEqual(data_layer_dimensions_to_dict["data_layer_dimensions"][1]["unit"], "string2")
        
    #
    def test_data_layer_dimensions_from_json(self):
        
        self.logger.info('test_data_layer_dimensions_from_json')

        got_exception = False

        try:
            data_layer_dimensions_from_json = catalog.data_layer_dimensions_from_json(data_layer_dimensions_str)
        except Exception as ex:
            self.logger.info(ex)
            got_exception = True
        
        self.assertEqual(data_layer_dimensions_from_json["string"].id, "0")
        self.assertEqual(data_layer_dimensions_from_json["string"].order, 0)
        self.assertEqual(data_layer_dimensions_from_json["string"].full_name, "string")
        self.assertEqual(data_layer_dimensions_from_json["string"].short_name, "string")
        self.assertEqual(data_layer_dimensions_from_json["string"].type, "string")
        self.assertEqual(data_layer_dimensions_from_json["string"].identifier, "string")
        self.assertEqual(data_layer_dimensions_from_json["string"].unit, "string")
        
        self.assertEqual(data_layer_dimensions_from_json["string2"].id, "1")
        self.assertEqual(data_layer_dimensions_from_json["string2"].order, 1)
        self.assertEqual(data_layer_dimensions_from_json["string2"].full_name, "string2")
        self.assertEqual(data_layer_dimensions_from_json["string2"].short_name, "string2")
        self.assertEqual(data_layer_dimensions_from_json["string2"].type, "string2")
        self.assertEqual(data_layer_dimensions_from_json["string2"].identifier, "string2")
        self.assertEqual(data_layer_dimensions_from_json["string2"].unit, "string2")
 
    #
    def test_data_layer_dimensions_to_json(self):
        
        self.logger.info('test_data_layer_dimensions_to_json')

        got_exception = False
        
        try:
            data_layer_dimensions_from_json = catalog.data_layer_dimensions_from_json(data_layer_dimensions_str)
            data_layer_dimensions_to_json = catalog.data_layer_dimensions_to_json(data_layer_dimensions_from_json)
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        
    #    
    def test_data_layer_dimensions_display(self):
        
        self.logger.info('test_data_layer_dimensions_display')
        
        try:
            data_layer_dimensions_from_json2 = catalog.data_layer_dimensions_from_json(data_layer_dimensions_str)
            df = data_layer_dimensions_from_json2.display()
        except Exception as ex:
            got_exception = True
            
        self.assertTrue(isinstance(df, pd.DataFrame))
        self.assertTrue(df.at[0,'id'], "0")
        self.assertTrue(df.at[0,'full_name'], "string")
        self.assertTrue(df.at[0,'short_name'], "string")
        self.assertTrue(df.at[0,'type'], "string")
        self.assertTrue(df.at[0,'identifier'], "string")
        self.assertTrue(df.at[0,'unit'], "string")
        self.assertTrue(df.at[1,'id'], "1")
        self.assertTrue(df.at[1,'full_name'], "string2")
        self.assertTrue(df.at[1,'short_name'], "string2")
        self.assertTrue(df.at[1,'type'], "string2")
        self.assertTrue(df.at[1,'identifier'], "string2")
        self.assertTrue(df.at[1,'unit'], "string2")

        try:
            data_layer_dimensions_from_json3 = catalog.data_layer_dimensions_from_json(data_layer_dimensions_str)
            df2 = data_layer_dimensions_from_json3.display(columns = ['id', 'short_name', 'notacolumn'])
        except Exception as ex:
            got_exception = True
        
        self.assertTrue(df2.at[0,'id'], "0")
        self.assertTrue(df2.at[0,'short_name'], "string")
        self.assertTrue(df2.at[0,'notacolumn'], "NaN")     
        self.assertTrue(df2.at[0,'id'], "1")
        self.assertTrue(df2.at[0,'short_name'], "string2")
        self.assertTrue(df2.at[0,'notacolumn'], "NaN")  
        
    # mocked_data_layer_dimensions_requests_get
    @mock.patch('ibmpairs.client.Client.get', 
                side_effect=mocked_data_layer_dimensions_requests_get
               )
    def test_data_layer_dimensions_get(self, mock_delete):
        
        self.logger.info('test_data_layer_dimensions_get: success')
        
        dld = catalog.DataLayerDimensions()
                        
        got_exception = False

        try:
            result = dld.get(data_layer_id = 1)
        except Exception as ex:
            got_exception = True
            
        self.assertFalse(got_exception)
        
        self.assertEqual(result["string"].id, "0")
        self.assertEqual(result["string"].full_name, "string")
        self.assertEqual(result["string2"].id, "1")
        self.assertEqual(result["string2"].full_name, "string2")
        
        self.logger.info('test_data_layer_dimensions_get: fail 404')
        
        dld2 = catalog.DataLayerDimensions()
                        
        got_exception2 = False

        try:
            result = dld2.get(data_layer_id = 2)
        except Exception as ex:
            got_exception2 = True
            self.assertEqual(str(ex), "The GET request call to https://pairs.res.ibm.com/v2/datalayers/2/datalayer_dimensions failed with status code: 404, message: failed.")
            
        self.assertTrue(got_exception2)
        
        self.logger.info('test_data_layer_dimensions_get: fail server error')
        
        dld3 = catalog.DataLayerDimensions()
                        
        got_exception3 = False

        try:
            result = dld3.get(data_layer_id = 3)
        except Exception as ex:
            got_exception3 = True
            self.assertEqual(str(ex), "The GET request to https://pairs.res.ibm.com/v2/datalayers/3/datalayer_dimensions encountered an unspecified error contacting the server; the request was unsuccessful, error message: __init__() got an unexpected keyword argument 'status'")

        self.assertTrue(got_exception3)

        self.logger.info('test_data_layer_dimensions_get: helper, success')
                        
        got_exception6 = False

        try:
            result2 = catalog.get_data_layer_dimensions(data_layer_id = 1)
        except Exception as ex:
            got_exception6 = True
            
        self.assertFalse(got_exception6)
       
        self.assertEqual(result2["string"].id, "0")
        self.assertEqual(result2["string"].full_name, "string")
        self.assertEqual(result2["string2"].id, "1")
        self.assertEqual(result2["string2"].full_name, "string2")
        
        
data_layer_property_return_dict = {
    "datalayerPropertyId": 47134,
    "status": 200,
    "message": "Datalayer property created successfully"
}

data_layer_property_return_str = r'''{
    "data_layer_property_id": 47134,
    "status": 200,
    "message": "Datalayer property created successfully"
}'''

#
class DataLayerPropertyReturnUnitTest(unittest.TestCase):
    
    #
    def setUp(self):
        self.logger = logger
        self.logger.info('setup')
    
    #
    def tearDown(self):
        self.logger.info('teardown')

    #    
    def test_data_layer_property_return_from_dict(self):
        
        self.logger.info('test_data_layer_property_return_from_dict')
        
        data_layer_property_return = catalog.DataLayerPropertyReturn

        data_layer_property_return_from_dict = None
            
        got_exception = False

        try:
            data_layer_property_return_from_dict = data_layer_property_return.from_dict(data_layer_property_return_dict)
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        self.assertEqual(data_layer_property_return_from_dict.data_layer_property_id, "47134")
        self.assertEqual(data_layer_property_return_from_dict.status, 200)
        self.assertEqual(data_layer_property_return_from_dict.message, "Datalayer property created successfully")

    #    
    def test_data_layer_property_return_to_dict(self):
        
        self.logger.info('test_data_layer_property_return_to_dict')
        
        data_layer_property_return = catalog.DataLayerPropertyReturn

        data_layer_property_return_from_dict = None
        data_layer_property_return_to_dict   = None
                
        got_exception = False

        try:
            data_layer_property_return_from_dict = data_layer_property_return.from_dict(data_layer_property_return_dict)
            data_layer_property_return_to_dict = data_layer_property_return_from_dict.to_dict()
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        self.assertIsInstance(data_layer_property_return_to_dict, dict)
        self.assertEqual(data_layer_property_return_to_dict["data_layer_property_id"], "47134")
        self.assertEqual(data_layer_property_return_to_dict["status"], 200)
        self.assertEqual(data_layer_property_return_to_dict["message"], "Datalayer property created successfully")
        
    #
    def test_data_layer_property_return_from_json(self):
        
        self.logger.info('test_data_layer_property_return_from_json')

        got_exception = False

        try:
            data_layer_property_return_from_json = catalog.data_layer_property_return_from_json(data_layer_property_return_str)
        except Exception as ex:
            self.logger.info(ex)
            got_exception = True

        self.assertFalse(got_exception)
        self.assertEqual(data_layer_property_return_from_json.data_layer_property_id, "47134")
        self.assertEqual(data_layer_property_return_from_json.status, 200)
        self.assertEqual(data_layer_property_return_from_json.message, "Datalayer property created successfully")
 
    #
    def test_data_layer_property_return_to_json(self):
        
        self.logger.info('test_data_layer_property_return_to_json')

        got_exception = False
        
        try:
            data_layer_property_return_from_json = catalog.data_layer_property_return_from_json(data_layer_property_return_str)
            data_layer_property_return_to_json = catalog.data_layer_property_return_to_json(data_layer_property_return_from_json)
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)

data_layer_property_dict = {
    "id": 0,
    "order": 0,
    "fullName": "string",
    "shortName": "string",
    "type": "string",
    "identifier": "string",
    "unit": "string"
}

data_layer_property_str = r'''{
    "id": 0,
    "order": 0,
    "fullName": "string",
    "shortName": "string",
    "type": "string",
    "identifier": "string",
    "unit": "string"
}'''

data_layer_property_requests_post_success_dict = {
    "fullName": "Forecast Horizon",
    "shortName": "horizon",
    "type": "string"
}

#
class DataLayerPropertyUnitTest(unittest.TestCase):
    
    #
    def setUp(self):
        self.logger = logger
        self.logger.info('setup')
        
        client = cl.Client()
    
    #
    def tearDown(self):
        self.logger.info('teardown')

    #    
    def test_data_layer_property_from_dict(self):
        
        self.logger.info('test_data_layer_property_from_dict')
        
        data_layer_property = catalog.DataLayerProperty

        data_layer_property_from_dict = None
            
        got_exception = False

        try:
            data_layer_property_from_dict = data_layer_property.from_dict(data_layer_property_dict)
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        self.assertEqual(data_layer_property_from_dict.id, "0")
        self.assertEqual(data_layer_property_from_dict.order, 0)
        self.assertEqual(data_layer_property_from_dict.full_name, "string")
        self.assertEqual(data_layer_property_from_dict.short_name, "string")
        self.assertEqual(data_layer_property_from_dict.type, "string")
        self.assertEqual(data_layer_property_from_dict.identifier, "string")
        self.assertEqual(data_layer_property_from_dict.unit, "string")

    #    
    def test_data_layer_property_to_dict(self):
        
        self.logger.info('test_data_layer_property_to_dict')
        
        data_layer_property = catalog.DataLayerProperty

        data_layer_property_from_dict = None
        data_layer_property_to_dict   = None
                
        got_exception = False

        try:
            data_layer_property_from_dict = data_layer_property.from_dict(data_layer_property_dict)
            data_layer_property_to_dict = data_layer_property_from_dict.to_dict()
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        self.assertIsInstance(data_layer_property_to_dict, dict)
        self.assertEqual(data_layer_property_to_dict["id"], "0")
        self.assertEqual(data_layer_property_to_dict["order"], 0)
        self.assertEqual(data_layer_property_to_dict["full_name"], "string")
        self.assertEqual(data_layer_property_to_dict["short_name"], "string")
        self.assertEqual(data_layer_property_to_dict["type"], "string")
        self.assertEqual(data_layer_property_to_dict["identifier"], "string")
        self.assertEqual(data_layer_property_to_dict["unit"], "string")
        
    #    
    def test_data_layer_property_to_dict_data_layer_property_post(self):
        
        self.logger.info('test_data_layer_property_to_dict_data_layer_property_post')
        
        data_layer_property2 = catalog.DataLayerProperty

        data_layer_property_from_dict2 = None
        data_layer_property_to_dict   = None
                
        got_exception = False

        try:
            data_layer_property_from_dict2 = data_layer_property2.from_dict(data_layer_property_dict)
            data_layer_property_to_dict_data_layer_property_post = data_layer_property_from_dict2.to_dict_data_layer_property_post()
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        self.assertIsInstance(data_layer_property_to_dict_data_layer_property_post, dict)
        self.assertEqual(data_layer_property_to_dict_data_layer_property_post["fullName"], "string")
        self.assertEqual(data_layer_property_to_dict_data_layer_property_post["shortName"], "string")
        self.assertEqual(data_layer_property_to_dict_data_layer_property_post["type"], "string")
        self.assertEqual(data_layer_property_to_dict_data_layer_property_post["unit"], "string")
        
    #
    def test_data_layer_property_from_json(self):
        
        self.logger.info('test_data_layer_property_from_json')

        got_exception = False

        try:
            data_layer_property_from_json = catalog.data_layer_property_from_json(data_layer_property_str)
        except Exception as ex:
            self.logger.info(ex)
            got_exception = True

        self.assertFalse(got_exception)
        self.assertEqual(data_layer_property_from_json.id, "0")
        self.assertEqual(data_layer_property_from_json.order, 0)
        self.assertEqual(data_layer_property_from_json.full_name, "string")
        self.assertEqual(data_layer_property_from_json.short_name, "string")
        self.assertEqual(data_layer_property_from_json.type, "string")
        self.assertEqual(data_layer_property_from_json.identifier, "string")
        self.assertEqual(data_layer_property_from_json.unit, "string")
 
    #
    def test_data_layer_property_to_json(self):
        
        self.logger.info('test_data_layer_property_to_json')

        got_exception = False
        
        try:
            data_layer_property_from_json = catalog.data_layer_property_from_json(data_layer_property_str)
            data_layer_property_to_json = catalog.data_layer_property_to_json(data_layer_property_from_json)
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        
    #
    def test_data_layer_property_to_json_data_layer_property_post(self):
        
        self.logger.info('test_data_layer_property_to_json_data_layer_property_post')

        got_exception = False
        
        try:
            data_layer_property_from_json2 = catalog.data_layer_property_from_json(data_layer_property_str)
            data_layer_property_to_json_data_layer_property_post = catalog.data_layer_property_to_json_post(data_layer_property_from_json2)
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        
    #
    def test_data_layer_property_display(self):
        
        self.logger.info('test_data_layer_property_display')
        
        try:
            data_layer_property_from_json3 = catalog.data_layer_property_from_json(data_layer_property_str)
            df = data_layer_property_from_json3.display()
        except Exception as ex:
            got_exception = True
            
        self.assertTrue(isinstance(df, pd.DataFrame))
        self.assertTrue(df.at[0,'id'], "0")
        self.assertTrue(df.at[0,'full_name'], "string")
        self.assertTrue(df.at[0,'short_name'], "string")
        self.assertTrue(df.at[0,'type'], "string")
        self.assertTrue(df.at[0,'identifier'], "string")
        self.assertTrue(df.at[0,'unit'], "string")

        try:
            data_layer_property_from_json4 = catalog.data_layer_property_from_json(data_layer_property_str)
            df2 = data_layer_property_from_json4.display(columns = ['id', 'short_name', 'notacolumn'])
        except Exception as ex:
            got_exception = True
        
        self.assertTrue(df2.at[0,'id'], "0")
        self.assertTrue(df2.at[0,'short_name'], "string")
        self.assertTrue(df2.at[0,'notacolumn'], "NaN")
        
    # mocked_data_layer_property_requests_get
    @mock.patch('ibmpairs.client.Client.get', 
                side_effect=mocked_data_layer_property_requests_get
               )
    def test_data_layer_property_get(self, mock_get):
        
        self.logger.info('test_data_layer_property_get: success')
        
        dlp = catalog.DataLayerProperty()
                        
        got_exception = False

        try:
            result = dlp.get(id = "1")
        except Exception as ex:
            got_exception = True
            
        self.assertFalse(got_exception)
        
        self.assertEqual(result.id, "0")
        self.assertEqual(result.order, 0)
        self.assertEqual(result.full_name, "string")
        self.assertEqual(result.short_name, "string")
        self.assertEqual(result.type, "string")
        self.assertEqual(result.identifier, "string")
        
        self.logger.info('test_data_layer_property_get: id already in object')
        
        dlp5 = catalog.DataLayerProperty()
                        
        got_exception5 = False

        try:
            dlp5.id = "1"
            result = dlp5.get()
        except Exception as ex:
            got_exception5 = True
            
        self.assertFalse(got_exception5)
        
        self.logger.info('test_data_layer_property_get: fail 404')
        
        dlp2 = catalog.DataLayerProperty()
                        
        got_exception2 = False

        try:
            result = dlp2.get(id = "2")
        except Exception as ex:
            got_exception2 = True
            self.assertEqual(str(ex), "The GET request call to https://pairs.res.ibm.com/v2/datalayer_properties/2 failed with status code: 404, message: failed.")
            
        self.assertTrue(got_exception2)
        
        self.logger.info('test_data_layer_property_get: fail server error')
        
        dlp3 = catalog.DataLayerProperty()
                        
        got_exception3 = False

        try:
            result = dlp3.get(id = "3")
        except Exception as ex:
            got_exception3 = True
            self.assertEqual(str(ex), "The GET request to https://pairs.res.ibm.com/v2/datalayer_properties/3 encountered an unspecified error contacting the server; the request was unsuccessful, error message: __init__() got an unexpected keyword argument 'status'")

        self.assertTrue(got_exception3)
        
        self.logger.info('test_data_layer_property_get: fail no id')
        
        dlp4 = catalog.DataLayerProperty()
                        
        got_exception4 = False

        try:
            result = dlp4.get()
        except Exception as ex:
            got_exception4 = True
            self.assertEqual(str(ex), "The DataLayerProperty object has no ID set and none was provided.")

        self.assertTrue(got_exception4)
        
        self.logger.info('test_data_layer_property_get: helper, success')
                        
        got_exception6 = False

        try:
            result2 = catalog.get_data_layer_property(id = "1")
        except Exception as ex:
            got_exception6 = True
            
        self.assertFalse(got_exception6)
        
        self.assertEqual(result2.id, "0")
        self.assertEqual(result2.order, 0)
        self.assertEqual(result2.full_name, "string")
        self.assertEqual(result2.short_name, "string")
        self.assertEqual(result2.type, "string")
        self.assertEqual(result2.identifier, "string")
    
    # mocked_data_layer_property_requests_post
    @mock.patch('ibmpairs.client.Client.post', 
                side_effect=mocked_data_layer_property_requests_post
               )
    def test_data_layer_property_create(self, mock_post):
        
        self.logger.info('test_data_layer_property_create: success')
        
        got_exception = False

        try:
            data_layer_property_create = catalog.data_layer_property_from_json(data_layer_property_requests_post_success_dict)
            data_layer_property_create.create(data_layer_id = 1)
        except Exception as ex:
            self.logger.info(ex)        
            got_exception = True
            
        self.assertFalse(got_exception)
        self.assertEqual(data_layer_property_create.data_layer_property_response.data_layer_property_id, "101")
        self.assertEqual(data_layer_property_create.data_layer_property_response.status, 200)
        self.assertEqual(data_layer_property_create.data_layer_property_response.message, "Datalayer property created successfully")
        
        self.logger.info('test_data_layer_property_create: fail 404')
        
        got_exception2 = False

        try:
            data_layer_property_create2 = catalog.data_layer_property_from_json(data_layer_property_requests_post_success_dict)
            data_layer_property_create2.name = "string2"
            dlps2 = data_layer_property_create2.create(data_layer_id = 2)
        except Exception as ex:
            self.logger.info(ex)
            self.assertEqual(str(ex), "The POST request call to https://pairs.res.ibm.com/v2/datalayers/2/datalayer_properties failed with status code: 404, message: Error: 404 Not Found.")
            got_exception2 = True
            
        self.assertTrue(got_exception2)
        
        self.logger.info('test_data_layer_property_create: fail server error')
        
        got_exception3 = False

        try:
            data_layer_property_create3 = catalog.data_layer_property_from_json(data_layer_property_requests_post_success_dict)
            data_layer_property_create3.name = "string3"
            dlp3 = data_layer_property_create3.create(data_layer_id = 3)
        except Exception as ex:
            self.logger.info(ex)
            self.assertEqual(str(ex), "The POST request to https://pairs.res.ibm.com/v2/datalayers/3/datalayer_properties encountered an unspecified error contacting the server; the request was unsuccessful, error message: __init__() got an unexpected keyword argument 'status'")
            got_exception3 = True
            
        self.assertTrue(got_exception3)
        
        self.logger.info('test_data_layer_property_create: helper, success')
        
        got_exception4 = False

        try:
            data_layer_property_create4 = catalog.data_layer_property_from_json(data_layer_property_requests_post_success_dict)
            helper = catalog.create_data_layer_property(data_layer_property = data_layer_property_create4,
                                                    data_layer_id = 1)
        except Exception as ex:
            self.logger.info(ex)        
            got_exception4 = True
            
        self.assertFalse(got_exception4)
        self.assertEqual(helper.data_layer_property_response.data_layer_property_id, "101")
        self.assertEqual(helper.data_layer_property_response.status, 200)
        self.assertEqual(helper.data_layer_property_response.message, "Datalayer property created successfully")

data_layer_properties_dict = [
    {
        "id": 0,
        "order": 0,
        "full_name": "string",
        "short_name": "string",
        "type": "string",
        "identifier": "string",
        "unit": "string"
    },
    {
        "id": 1,
        "order": 1,
        "full_name": "string2",
        "short_name": "string2",
        "type": "string2",
        "identifier": "string2",
        "unit": "string2"
    }
]

data_layer_properties_str = r'''[
    {
        "id": 0,
        "order": 0,
        "full_name": "string",
        "short_name": "string",
        "type": "string",
        "identifier": "string",
        "unit": "string"
    },
    {
        "id": 1,
        "order": 1,
        "full_name": "string2",
        "short_name": "string2",
        "type": "string2",
        "identifier": "string2",
        "unit": "string2"
    }
]'''

data_layer_properties_multi_name_dict = [
    {
        "full_name": "abc",
    },
    {
        "full_name": "abc",
    }
]

data_layer_properties_obj_repr_dict = {
    "data_layer_properties": [
        {
            "full_name": "abc",
        },
        {
            "full_name": "abc2",
        }
    ]
}

#
class DataLayerPropertiesUnitTest(unittest.TestCase):
    
    #
    def setUp(self):
        self.logger = logger
        self.logger.info('setup')
        
        client = cl.Client()
    
    #
    def tearDown(self):
        self.logger.info('teardown')

    #    
    def test_data_layer_properties_from_dict(self):
        
        self.logger.info('test_data_layer_properties_from_dict')
        
        data_layer_properties = catalog.DataLayerProperties

        data_layer_properties_from_dict = None
            
        got_exception = False

        try:
            data_layer_properties_from_dict = data_layer_properties.from_dict(data_layer_properties_dict)
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        self.assertEqual(data_layer_properties_from_dict["string"].id, "0")
        self.assertEqual(data_layer_properties_from_dict["string"].order, 0)
        self.assertEqual(data_layer_properties_from_dict["string"].full_name, "string")
        self.assertEqual(data_layer_properties_from_dict["string"].short_name, "string")
        self.assertEqual(data_layer_properties_from_dict["string"].type, "string")
        self.assertEqual(data_layer_properties_from_dict["string"].identifier, "string")
        self.assertEqual(data_layer_properties_from_dict["string"].unit, "string")
        
        self.assertEqual(data_layer_properties_from_dict["string2"].id, "1")
        self.assertEqual(data_layer_properties_from_dict["string2"].order, 1)
        self.assertEqual(data_layer_properties_from_dict["string2"].full_name, "string2")
        self.assertEqual(data_layer_properties_from_dict["string2"].short_name, "string2")
        self.assertEqual(data_layer_properties_from_dict["string2"].type, "string2")
        self.assertEqual(data_layer_properties_from_dict["string2"].identifier, "string2")
        self.assertEqual(data_layer_properties_from_dict["string2"].unit, "string2")
        
        self.logger.info('data_layer_properties_from_dict: no overload')
        
        self.assertEqual(data_layer_properties_from_dict.data_layer_properties[0].full_name, "string")
        self.assertEqual(data_layer_properties_from_dict.data_layer_properties[1].full_name, "string2")
        
        self.logger.info('data_layer_properties_from_dict: set overload')
        
        data_layer_properties_from_dict["string"].id = "newstring"
        data_layer_properties_from_dict["string2"].id = "newstring2"
        data_layer_properties_from_dict["string"].full_name = "newstring"
        data_layer_properties_from_dict["string2"].full_name = "newstring2"
        
        self.assertEqual(data_layer_properties_from_dict["newstring"].full_name, "newstring")
        self.assertEqual(data_layer_properties_from_dict["newstring2"].full_name, "newstring2")
        self.assertEqual(data_layer_properties_from_dict["newstring"].id, "newstring")
        self.assertEqual(data_layer_properties_from_dict["newstring2"].id, "newstring2")
        
        self.logger.info('data_layer_properties_from_dict: set no overload')
        
        data_layer_properties_from_dict[0].id = "newnewstring"
        data_layer_properties_from_dict[1].id = "newnewstring2"
        data_layer_properties_from_dict[0].full_name = "newnewstring"
        data_layer_properties_from_dict[1].full_name = "newnewstring2"
        
        self.assertEqual(data_layer_properties_from_dict["newnewstring"].full_name, "newnewstring")
        self.assertEqual(data_layer_properties_from_dict["newnewstring2"].full_name, "newnewstring2")
        self.assertEqual(data_layer_properties_from_dict["newnewstring"].id, "newnewstring")
        self.assertEqual(data_layer_properties_from_dict["newnewstring2"].id, "newnewstring2")
        self.assertEqual(data_layer_properties_from_dict[0].full_name, "newnewstring")
        self.assertEqual(data_layer_properties_from_dict[1].full_name, "newnewstring2")
        self.assertEqual(data_layer_properties_from_dict[0].id, "newnewstring")
        self.assertEqual(data_layer_properties_from_dict[1].id, "newnewstring2")
        
        data_layer_properties_multi_name = catalog.DataLayerProperties

        data_layer_properties_multi_name_from_dict = None
            
        got_exception2 = False

        try:
            data_layer_properties_multi_name_from_dict = data_layer_properties_multi_name.from_dict(data_layer_properties_multi_name_dict)
        except Exception as ex:
            got_exception2 = True

        self.assertFalse(got_exception2)
        
        got_exception3 = False
        
        try:
            data_layer_properties_multi_name_from_dict["ab"].full_name = "abc"
        except Exception as ex:
            got_exception3 = True
            
        self.assertTrue(got_exception3)
        
        got_exception4 = False
        
        try:
            data_layer_properties_multi_name_from_dict["abc"].full_name = "abc"
        except Exception as ex:
            got_exception4 = True
            
        self.assertTrue(got_exception4)
        
        got_exception5 = False
        
        try:
            d = {}
            data_layer_properties_multi_name_from_dict[d].full_name = "abc"
        except Exception as ex:
            got_exception5 = True
            
        self.assertTrue(got_exception5)
        
        got_exception6 = False
        
        try:
            data_layer_properties_multi_name_from_dict[0].full_name = "abcd"
        except Exception as ex:
            got_exception6 = True
            
        self.assertFalse(got_exception6)
        
        self.assertEqual(data_layer_properties_multi_name_from_dict[0].full_name, "abcd")
        self.assertEqual(data_layer_properties_multi_name_from_dict[1].full_name, "abc")
        
        got_exception7 = False
        
        try:
            data_layer_properties_multi_name_from_dict["abc"].full_name = "efg"
        except Exception as ex:
            got_exception7 = True
            
        self.assertFalse(got_exception7)
        
        self.assertEqual(data_layer_properties_multi_name_from_dict[0].full_name, "abcd")
        self.assertEqual(data_layer_properties_multi_name_from_dict[1].full_name, "efg")
        
        data_layer_properties_obj_repr = catalog.DataLayerProperties

        data_layer_properties_obj_repr_from_dict = None
        
        got_exception8 = False

        try:
            data_layer_properties_obj_repr_from_dict = data_layer_properties_obj_repr.from_dict(data_layer_properties_obj_repr_dict)
        except Exception as ex:
            got_exception8 = True

        self.assertFalse(got_exception8)
        
        self.assertEqual(data_layer_properties_obj_repr_from_dict[0].full_name, "abc")
        self.assertEqual(data_layer_properties_obj_repr_from_dict[1].full_name, "abc2")

    #    
    def test_data_layer_properties_to_dict(self):
        
        self.logger.info('test_data_layer_properties_to_dict')
        
        data_layer_properties = catalog.DataLayerProperties

        data_layer_properties_from_dict = None
        data_layer_properties_to_dict   = None
                
        got_exception = False

        try:
            data_layer_properties_from_dict = data_layer_properties.from_dict(data_layer_properties_dict)
            data_layer_properties_to_dict = data_layer_properties_from_dict.to_dict()
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        self.assertIsInstance(data_layer_properties_to_dict, dict)
        self.assertEqual(data_layer_properties_to_dict["data_layer_properties"][0]["id"], "0")
        self.assertEqual(data_layer_properties_to_dict["data_layer_properties"][0]["order"], 0)
        self.assertEqual(data_layer_properties_to_dict["data_layer_properties"][0]["full_name"], "string")
        self.assertEqual(data_layer_properties_to_dict["data_layer_properties"][0]["short_name"], "string")
        self.assertEqual(data_layer_properties_to_dict["data_layer_properties"][0]["type"], "string")
        self.assertEqual(data_layer_properties_to_dict["data_layer_properties"][0]["identifier"], "string")
        self.assertEqual(data_layer_properties_to_dict["data_layer_properties"][0]["unit"], "string")
        
        self.assertEqual(data_layer_properties_to_dict["data_layer_properties"][1]["id"], "1")
        self.assertEqual(data_layer_properties_to_dict["data_layer_properties"][1]["order"], 1)
        self.assertEqual(data_layer_properties_to_dict["data_layer_properties"][1]["full_name"], "string2")
        self.assertEqual(data_layer_properties_to_dict["data_layer_properties"][1]["short_name"], "string2")
        self.assertEqual(data_layer_properties_to_dict["data_layer_properties"][1]["type"], "string2")
        self.assertEqual(data_layer_properties_to_dict["data_layer_properties"][1]["identifier"], "string2")
        self.assertEqual(data_layer_properties_to_dict["data_layer_properties"][1]["unit"], "string2")
        
    #
    def test_data_layer_properties_from_json(self):
        
        self.logger.info('test_data_layer_properties_from_json')

        got_exception = False

        try:
            data_layer_properties_from_json = catalog.data_layer_properties_from_json(data_layer_properties_str)
        except Exception as ex:
            self.logger.info(ex)
            got_exception = True
        
        self.assertEqual(data_layer_properties_from_json["string"].id, "0")
        self.assertEqual(data_layer_properties_from_json["string"].order, 0)
        self.assertEqual(data_layer_properties_from_json["string"].full_name, "string")
        self.assertEqual(data_layer_properties_from_json["string"].short_name, "string")
        self.assertEqual(data_layer_properties_from_json["string"].type, "string")
        self.assertEqual(data_layer_properties_from_json["string"].identifier, "string")
        self.assertEqual(data_layer_properties_from_json["string"].unit, "string")
        
        self.assertEqual(data_layer_properties_from_json["string2"].id, "1")
        self.assertEqual(data_layer_properties_from_json["string2"].order, 1)
        self.assertEqual(data_layer_properties_from_json["string2"].full_name, "string2")
        self.assertEqual(data_layer_properties_from_json["string2"].short_name, "string2")
        self.assertEqual(data_layer_properties_from_json["string2"].type, "string2")
        self.assertEqual(data_layer_properties_from_json["string2"].identifier, "string2")
        self.assertEqual(data_layer_properties_from_json["string2"].unit, "string2")
 
    #
    def test_data_layer_properties_to_json(self):
        
        self.logger.info('test_data_layer_properties_to_json')

        got_exception = False
        
        try:
            data_layer_properties_from_json = catalog.data_layer_properties_from_json(data_layer_properties_str)
            data_layer_properties_to_json = catalog.data_layer_properties_to_json(data_layer_properties_from_json)
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        
    #    
    def test_data_layer_properties_display(self):
        
        self.logger.info('test_data_layer_properties_display')
        
        try:
            data_layer_properties_from_json2 = catalog.data_layer_properties_from_json(data_layer_properties_str)
            df = data_layer_properties_from_json2.display()
        except Exception as ex:
            got_exception = True
            
        self.assertTrue(isinstance(df, pd.DataFrame))
        self.assertTrue(df.at[0,'id'], "0")
        self.assertTrue(df.at[0,'full_name'], "string")
        self.assertTrue(df.at[0,'short_name'], "string")
        self.assertTrue(df.at[0,'type'], "string")
        self.assertTrue(df.at[0,'identifier'], "string")
        self.assertTrue(df.at[0,'unit'], "string")
        self.assertTrue(df.at[1,'id'], "1")
        self.assertTrue(df.at[1,'full_name'], "string2")
        self.assertTrue(df.at[1,'short_name'], "string2")
        self.assertTrue(df.at[1,'type'], "string2")
        self.assertTrue(df.at[1,'identifier'], "string2")
        self.assertTrue(df.at[1,'unit'], "string2")

        try:
            data_layer_properties_from_json3 = catalog.data_layer_properties_from_json(data_layer_properties_str)
            df2 = data_layer_properties_from_json3.display(columns = ['id', 'short_name', 'notacolumn'])
        except Exception as ex:
            got_exception = True
        
        self.assertTrue(df2.at[0,'id'], "0")
        self.assertTrue(df2.at[0,'short_name'], "string")
        self.assertTrue(df2.at[0,'notacolumn'], "NaN")     
        self.assertTrue(df2.at[0,'id'], "1")
        self.assertTrue(df2.at[0,'short_name'], "string2")
        self.assertTrue(df2.at[0,'notacolumn'], "NaN")  
        
data_layer_dict = {
    "id": "string",
    "name": "string",
    "description": "string",
    "dataset": {
        "id": "string",
        "name": "string",
        "key": "string",
        "category": {
            "id": "1",
            "name": "Satellite"
        },
        "level": 0,
        "crs": "string",
        "license_information": "string",
        "offering_status": "string",
        "description_short": "string"
    },
    "units": "string",
    "datatype": "sh",
    "level": "22",
    "crs": "string",
    "colorTable": {
        "id": "32451"
    },
    "name_alternate": "ESA Sentinel 2 Level-2A",
    "rating": "4.0",
    "description_short": "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.",
    "description_long": "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.",
    "description_links": [
        "https://sentinel.esa.int/web/sentinel/missions",
        "https://sentinel.esa.int/documents/247904/685211/Sentinel-2_User_Handbook",
        "https://sentinel.esa.int/web/sentinel/missions/sentinel-2/data-products",
        "https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi"
    ],
    "data_source_name": "European Space Agency Sentinel-2",
    "data_source_attribution": "'Copernicus Sentinel data [Year]' for Sentinel data; see https://lta.cr.usgs.gov/sites/default/files/Sentinel_Data_Terms_and_Conditions.pdf",
    "data_source_description": "'Level-2A is generated by the Payload Data Ground Segment using the Sen2Cor processor. Level-2A products are made available to users via the Copernicus Open Access Hub: https://scihub.copernicus.eu/dhus/#/home",
    "data_source_links": [
        "https://sentinel.esa.int/web/sentinel/sentinel-data-access"
    ],
    "update_interval_max": "1 day",
    "update_interval_description": "Uploads are run daily. However, note the temporal resolution.",
    "lag_horizon": "5 days",
    "lag_horizon_description": "Data is available within 24 hours.",
    "temporal_resolution": "5 days",
    "temporal_resolution_description": "string2",
    "spatial_resolution_of_raw_data": "100m",
    "interpolation": "near",
    "interpolation_upload": "near",
    "dimensions_description": "The sole dimension is called \"horizon\" and refers to the forecast horizon in hours. (Only integer horizons are allowed.)",
    "permanence": "true",
    "permanence_description": "Data with timestamp into the future will be update, but remain constant past current timestamp (except for error corrrection).",
    "known_issues": "Updates are irregular.",
    "properties": {
        "Sector": [
            "Animals/livestock",
            "Transportation/infrastructure",
            "Vegetation/crops",
            "Weather/climate"
        ],
        "Application": [
            "Agriculture"
        ],
        "Domain": [
            "Land surface"
        ],
        "Type": [
            "Data product"
        ],
        "Source": [
            "Satellite",
            "Survey"
        ]
    },
    "spatial_coverage": {
        "Country": [
            "Belgium",
            "Bolivia",
            "France",
            "Germany",
            "India",
            "Indonesia",
            "Luxembourg",
            "Netherlands",
            "Switzerland",
            "Thailand",
            "United Kingdom",
            "United States of America"
        ]
    },
    "latitude_min": "-90",
    "longitude_min": "-180",
    "latitude_max": "90",
    "longitude_max": "180",
    "temporal_min": "2016-03-12T00:00:01.000Z",
    "temporal_max": "2019-07-30T00:00:01.000Z",
    "measurement_interval": "6 hours",
    "measurement_interval_description": "Data is recorded instanteneously.",
    "meaning_of_timestamp": "Begining",
    "meaning_of_spatial_descriptor": "Average",
    "formula": "$ + 273.15",
    "min_value": "4.0",
    "max_value": "40.0"
}

data_layer_str = r'''{
    "id": "string",
    "name": "string",
    "description": "string",
    "dataset": {
        "id": "string",
        "name": "string",
        "key": "string",
        "category": {
            "id": "1",
            "name": "Satellite"
        },
        "level": 0,
        "crs": "string",
        "license_information": "string",
        "offering_status": "string",
        "description_short": "string"
    },
    "units": "string",
    "datatype": "sh",
    "level": "22",
    "crs": "string",
    "colorTable": {
        "id": "32451"
    },
    "name_alternate": "ESA Sentinel 2 Level-2A",
    "rating": "4.0",
    "description_short": "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.",
    "description_long": "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.",
    "description_links": [
        "https://sentinel.esa.int/web/sentinel/missions",
        "https://sentinel.esa.int/documents/247904/685211/Sentinel-2_User_Handbook",
        "https://sentinel.esa.int/web/sentinel/missions/sentinel-2/data-products",
        "https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi"
    ],
    "data_source_name": "European Space Agency Sentinel-2",
    "data_source_attribution": "'Copernicus Sentinel data [Year]' for Sentinel data; see https://lta.cr.usgs.gov/sites/default/files/Sentinel_Data_Terms_and_Conditions.pdf",
    "data_source_description": "'Level-2A is generated by the Payload Data Ground Segment using the Sen2Cor processor. Level-2A products are made available to users via the Copernicus Open Access Hub: https://scihub.copernicus.eu/dhus/#/home",
    "data_source_links": [
        "https://sentinel.esa.int/web/sentinel/sentinel-data-access"
    ],
    "update_interval_max": "1 day",
    "update_interval_description": "Uploads are run daily. However, note the temporal resolution.",
    "lag_horizon": "5 days",
    "lag_horizon_description": "Data is available within 24 hours.",
    "temporal_resolution": "5 days",
    "temporal_resolution_description": "string2",
    "spatial_resolution_of_raw_data": "100m",
    "interpolation": "near",
    "interpolation_upload": "near",
    "dimensions_description": "The sole dimension is called \"horizon\" and refers to the forecast horizon in hours. (Only integer horizons are allowed.)",
    "permanence": "true",
    "permanence_description": "Data with timestamp into the future will be update, but remain constant past current timestamp (except for error corrrection).",
    "known_issues": "Updates are irregular.",
    "properties": {
        "Sector": [
            "Animals/livestock",
            "Transportation/infrastructure",
            "Vegetation/crops",
            "Weather/climate"
        ],
        "Application": [
            "Agriculture"
        ],
        "Domain": [
            "Land surface"
        ],
        "Type": [
            "Data product"
        ],
        "Source": [
            "Satellite",
            "Survey"
        ]
    },
    "spatial_coverage": {
        "Country": [
            "Belgium",
            "Bolivia",
            "France",
            "Germany",
            "India",
            "Indonesia",
            "Luxembourg",
            "Netherlands",
            "Switzerland",
            "Thailand",
            "United Kingdom",
            "United States of America"
        ]
    },
    "latitude_min": "-90",
    "longitude_min": "-180",
    "latitude_max": "90",
    "longitude_max": "180",
    "temporal_min": "2016-03-12T00:00:01.000Z",
    "temporal_max": "2019-07-30T00:00:01.000Z",
    "measurement_interval": "6 hours",
    "measurement_interval_description": "Data is recorded instanteneously.",
    "meaning_of_timestamp": "Begining",
    "meaning_of_spatial_descriptor": "Average",
    "formula": "$ + 273.15",
    "min_value": "4.0",
    "max_value": "40.0"
}'''


data_layer_requests_post_success_dict = {
    "group": "usa_county",
    "layerType": "Raster",
    "layers": [
        {
            "name": "Aerosol optical thickness",
            "description": "AOT describes attenuation of sunlight by a column of aerosol.",
            "datatype": "sh",
            "level": "22",
            "crs": "string",
            "units": "string",
            "status": "ACTIVE",
            "colorTable": {
                "id": "32451"
            },
            "name_alternate": "ESA Sentinel 2 Level-2A",
            "rating": "4.0",
            "description_short": "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.",
            "description_long": "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.",
            "description_links": [
                "https://sentinel.esa.int/web/sentinel/missions",
                "https://sentinel.esa.int/documents/247904/685211/Sentinel-2_User_Handbook",
                "https://sentinel.esa.int/web/sentinel/missions/sentinel-2/data-products",
                "https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi"
            ],
            "data_source_name": "European Space Agency Sentinel-2",
            "data_source_attribution": "'Copernicus Sentinel data [Year]' for Sentinel data; see https://lta.cr.usgs.gov/sites/default/files/Sentinel_Data_Terms_and_Conditions.pdf",
            "data_source_description": "'Level-2A is generated by the Payload Data Ground Segment using the Sen2Cor processor. Level-2A products are made available to users via the Copernicus Open Access Hub: https://scihub.copernicus.eu/dhus/#/home",
            "data_source_links": [
                "https://sentinel.esa.int/web/sentinel/sentinel-data-access"
            ],
            "update_interval_max": "1 day",
            "update_interval_description": "Uploads are run daily. However, note the temporal resolution.",
            "lag_horizon": "5 days",
            "lag_horizon_description": "Data is available within 24 hours.",
            "temporal_resolution": "5 days",
            "temporal_resolution_description": "string",
            "spatial_resolution_of_raw_data": "100m",
            "interpolation": "near",
            "interpolation_upload": "near",
            "dimensions_description": "The sole dimension is called \"horizon\" and refers to the forecast horizon in hours. (Only integer horizons are allowed.)",
            "permanence": "true",
            "permanence_description": "Data with timestamp into the future will be update, but remain constant past current timestamp (except for error corrrection).",
            "known_issues": "Updates are irregular.",
            "description_internal": "This data set is not for public dissemination.",
            "description_internal_links": [
                "http://www.ftp.ncep.noaa.gov/data/nccf/com/gfs/prod/"
            ],
            "properties": {
                "Sector": [
                    "Animals/livestock",
                    "Transportation/infrastructure",
                    "Vegetation/crops",
                    "Weather/climate"
                ],
                "Application": [
                    "Agriculture"
                ],
                "Domain": [
                    "Land surface"
                ],
                "Type": [
                    "Data product"
                ],
                "Source": [
                    "Satellite",
                    "Survey"
                ]
            },
            "spatial_coverage": {
                "Country": [
                    "Belgium",
                    "Bolivia",
                    "France",
                    "Germany",
                    "India",
                    "Indonesia",
                    "Luxembourg",
                    "Netherlands",
                    "Switzerland",
                    "Thailand",
                    "United Kingdom",
                    "United States of America"
                ]
            },
            "latitude_min": "-90",
            "longitude_min": "-180",
            "latitude_max": "90",
            "longitude_max": "180",
            "temporal_min": "2016-03-12T00:00:01.000Z",
            "temporal_max": "2019-07-30T00:00:01.000Z",
            "measurement_interval": "6 hours",
            "measurement_interval_description": "Data is recorded instanteneously.",
            "meaning_of_timestamp": "Begining",
            "meaning_of_spatial_descriptor": "Average",
            "formula": "$ + 273.15"
        }
    ]
}

#
class DataLayerUnitTest(unittest.TestCase):
    
    #
    def setUp(self):
        self.logger = logger
        self.logger.info('setup')
        
        client = cl.Client()
    
    #
    def tearDown(self):
        self.logger.info('teardown')

    #    
    def test_data_layer_from_dict(self):
        
        self.logger.info('test_data_layer_from_dict')
        
        data_layer = catalog.DataLayer

        data_layer_from_dict = None
            
        got_exception = False

        try:
            data_layer_from_dict = data_layer.from_dict(data_layer_dict)
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)  
        
        self.assertEqual(data_layer_from_dict.id, "string")
        self.assertEqual(data_layer_from_dict.name, "string")
        self.assertEqual(data_layer_from_dict.description, "string")
        self.assertEqual(data_layer_from_dict.dataset.id, "string")
        self.assertEqual(data_layer_from_dict.dataset.name, "string")
        self.assertEqual(data_layer_from_dict.dataset.key, "string")
        self.assertEqual(data_layer_from_dict.dataset.category.id, 1)
        self.assertEqual(data_layer_from_dict.dataset.category.name, "Satellite")
        self.assertEqual(data_layer_from_dict.dataset.level, 0)
        self.assertEqual(data_layer_from_dict.dataset.crs, "string")
        self.assertEqual(data_layer_from_dict.dataset.license_information, "string")
        self.assertEqual(data_layer_from_dict.dataset.offering_status, "string")
        self.assertEqual(data_layer_from_dict.dataset.description_short, "string")
        self.assertEqual(data_layer_from_dict.units, "string")
        self.assertEqual(data_layer_from_dict.datatype, "sh")
        self.assertEqual(data_layer_from_dict.level, 22)
        self.assertEqual(data_layer_from_dict.crs, "string")
        self.assertEqual(data_layer_from_dict.color_table.id, "32451")
        self.assertEqual(data_layer_from_dict.name_alternate, "ESA Sentinel 2 Level-2A")
        self.assertEqual(data_layer_from_dict.rating, 4.0)
        self.assertEqual(data_layer_from_dict.description_short, "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.")
        self.assertEqual(data_layer_from_dict.description_long, "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.")
        self.assertEqual(data_layer_from_dict.description_links[0], "https://sentinel.esa.int/web/sentinel/missions")
        self.assertEqual(data_layer_from_dict.description_links[1], "https://sentinel.esa.int/documents/247904/685211/Sentinel-2_User_Handbook")
        self.assertEqual(data_layer_from_dict.description_links[2], "https://sentinel.esa.int/web/sentinel/missions/sentinel-2/data-products")
        self.assertEqual(data_layer_from_dict.description_links[3], "https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi")
        self.assertEqual(data_layer_from_dict.data_source_name, "European Space Agency Sentinel-2")
        self.assertEqual(data_layer_from_dict.data_source_attribution, "'Copernicus Sentinel data [Year]' for Sentinel data; see https://lta.cr.usgs.gov/sites/default/files/Sentinel_Data_Terms_and_Conditions.pdf")
        self.assertEqual(data_layer_from_dict.data_source_description, "'Level-2A is generated by the Payload Data Ground Segment using the Sen2Cor processor. Level-2A products are made available to users via the Copernicus Open Access Hub: https://scihub.copernicus.eu/dhus/#/home")
        self.assertEqual(data_layer_from_dict.data_source_links[0], "https://sentinel.esa.int/web/sentinel/sentinel-data-access")
        self.assertEqual(data_layer_from_dict.update_interval_max, "1 day")
        self.assertEqual(data_layer_from_dict.update_interval_description, "Uploads are run daily. However, note the temporal resolution.")
        self.assertEqual(data_layer_from_dict.lag_horizon, "5 days")
        self.assertEqual(data_layer_from_dict.lag_horizon_description, "Data is available within 24 hours.")
        self.assertEqual(data_layer_from_dict.temporal_resolution, "5 days")
        self.assertEqual(data_layer_from_dict.temporal_resolution_description, "string2")
        self.assertEqual(data_layer_from_dict.spatial_resolution_of_raw_data, "100m")
        self.assertEqual(data_layer_from_dict.interpolation, "near")
        self.assertEqual(data_layer_from_dict.interpolation_upload, "near")
        self.assertEqual(data_layer_from_dict.dimensions_description, "The sole dimension is called \"horizon\" and refers to the forecast horizon in hours. (Only integer horizons are allowed.)")
        self.assertEqual(data_layer_from_dict.permanence, True)
        self.assertEqual(data_layer_from_dict.permanence_description, "Data with timestamp into the future will be update, but remain constant past current timestamp (except for error corrrection).")
        self.assertEqual(data_layer_from_dict.known_issues, "Updates are irregular.")
        self.assertEqual(data_layer_from_dict.properties.sector[0], "Animals/livestock")
        self.assertEqual(data_layer_from_dict.properties.sector[1], "Transportation/infrastructure")
        self.assertEqual(data_layer_from_dict.properties.sector[2], "Vegetation/crops")
        self.assertEqual(data_layer_from_dict.properties.sector[3], "Weather/climate")
        self.assertEqual(data_layer_from_dict.properties.application[0], "Agriculture")
        self.assertEqual(data_layer_from_dict.properties.domain[0], "Land surface")
        self.assertEqual(data_layer_from_dict.properties.type[0], "Data product")
        self.assertEqual(data_layer_from_dict.properties.source[0], "Satellite")
        self.assertEqual(data_layer_from_dict.properties.source[1], "Survey")
        self.assertEqual(data_layer_from_dict.spatial_coverage.country[0], "Belgium")
        self.assertEqual(data_layer_from_dict.spatial_coverage.country[1], "Bolivia")
        self.assertEqual(data_layer_from_dict.spatial_coverage.country[2], "France")
        self.assertEqual(data_layer_from_dict.spatial_coverage.country[3], "Germany")
        self.assertEqual(data_layer_from_dict.spatial_coverage.country[4], "India")
        self.assertEqual(data_layer_from_dict.spatial_coverage.country[5], "Indonesia")
        self.assertEqual(data_layer_from_dict.spatial_coverage.country[6], "Luxembourg")
        self.assertEqual(data_layer_from_dict.spatial_coverage.country[7], "Netherlands")
        self.assertEqual(data_layer_from_dict.spatial_coverage.country[8], "Switzerland")
        self.assertEqual(data_layer_from_dict.spatial_coverage.country[9], "Thailand")
        self.assertEqual(data_layer_from_dict.spatial_coverage.country[10], "United Kingdom")
        self.assertEqual(data_layer_from_dict.spatial_coverage.country[11], "United States of America")
        self.assertEqual(data_layer_from_dict.latitude_min, -90)
        self.assertEqual(data_layer_from_dict.longitude_min, -180)
        self.assertEqual(data_layer_from_dict.latitude_max, 90)
        self.assertEqual(data_layer_from_dict.longitude_max, 180)
        self.assertEqual(data_layer_from_dict.temporal_min, "2016-03-12T00:00:01.000Z")
        self.assertEqual(data_layer_from_dict.temporal_max, "2019-07-30T00:00:01.000Z")
        self.assertEqual(data_layer_from_dict.measurement_interval, "6 hours")
        self.assertEqual(data_layer_from_dict.measurement_interval_description, "Data is recorded instanteneously.")
        self.assertEqual(data_layer_from_dict.meaning_of_timestamp, "Begining")
        self.assertEqual(data_layer_from_dict.meaning_of_spatial_descriptor, "Average")
        self.assertEqual(data_layer_from_dict.formula, "$ + 273.15")
        self.assertEqual(data_layer_from_dict.min_value, 4.0)
        self.assertEqual(data_layer_from_dict.max_value, 40.0)
        
    #    
    def test_data_layer_to_dict(self):
            
        self.logger.info('test_data_set_to_dict')
            
        data_layer = catalog.DataLayer

        data_layer_from_dict = None
        data_layer_to_dict   = None
                    
        got_exception = False

        try:
            data_layer_from_dict = data_layer.from_dict(data_layer_dict)
            data_layer_to_dict = data_layer_from_dict.to_dict()
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        self.assertEqual(data_layer_to_dict["id"], "string")
        self.assertEqual(data_layer_to_dict["name"], "string")
        self.assertEqual(data_layer_to_dict["description"], "string")
        self.assertEqual(data_layer_to_dict["dataset"]["id"], "string")
        self.assertEqual(data_layer_to_dict["dataset"]["name"], "string")
        self.assertEqual(data_layer_to_dict["dataset"]["key"], "string")
        self.assertEqual(data_layer_to_dict["dataset"]["name"], "string")
        self.assertEqual(data_layer_to_dict["dataset"]["category"]["id"], 1)
        self.assertEqual(data_layer_to_dict["dataset"]["category"]["name"], "Satellite")
        self.assertEqual(data_layer_to_dict["dataset"]["level"], 0)
        self.assertEqual(data_layer_to_dict["dataset"]["crs"], "string")
        self.assertEqual(data_layer_to_dict["dataset"]["license_information"], "string")
        self.assertEqual(data_layer_to_dict["dataset"]["offering_status"], "string")
        self.assertEqual(data_layer_to_dict["dataset"]["description_short"], "string")
        self.assertEqual(data_layer_to_dict["units"], "string")
        self.assertEqual(data_layer_to_dict["datatype"], "sh")
        self.assertEqual(data_layer_to_dict["level"], 22)
        self.assertEqual(data_layer_to_dict["crs"], "string")
        self.assertEqual(data_layer_to_dict["color_table"]["id"], "32451")
        self.assertEqual(data_layer_to_dict["name_alternate"], "ESA Sentinel 2 Level-2A")
        self.assertEqual(data_layer_to_dict["rating"], 4.0)
        self.assertEqual(data_layer_to_dict["description_short"], "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.")
        self.assertEqual(data_layer_to_dict["description_long"], "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.")
        self.assertEqual(data_layer_to_dict["description_links"][0], "https://sentinel.esa.int/web/sentinel/missions")
        self.assertEqual(data_layer_to_dict["description_links"][1], "https://sentinel.esa.int/documents/247904/685211/Sentinel-2_User_Handbook")
        self.assertEqual(data_layer_to_dict["description_links"][2], "https://sentinel.esa.int/web/sentinel/missions/sentinel-2/data-products")
        self.assertEqual(data_layer_to_dict["description_links"][3], "https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi")
        self.assertEqual(data_layer_to_dict["data_source_name"], "European Space Agency Sentinel-2")
        self.assertEqual(data_layer_to_dict["data_source_attribution"], "'Copernicus Sentinel data [Year]' for Sentinel data; see https://lta.cr.usgs.gov/sites/default/files/Sentinel_Data_Terms_and_Conditions.pdf")
        self.assertEqual(data_layer_to_dict["data_source_description"], "'Level-2A is generated by the Payload Data Ground Segment using the Sen2Cor processor. Level-2A products are made available to users via the Copernicus Open Access Hub: https://scihub.copernicus.eu/dhus/#/home")
        self.assertEqual(data_layer_to_dict["data_source_links"][0], "https://sentinel.esa.int/web/sentinel/sentinel-data-access")
        self.assertEqual(data_layer_to_dict["update_interval_max"], "1 day")
        self.assertEqual(data_layer_to_dict["update_interval_description"], "Uploads are run daily. However, note the temporal resolution.")
        self.assertEqual(data_layer_to_dict["lag_horizon"], "5 days")
        self.assertEqual(data_layer_to_dict["lag_horizon_description"], "Data is available within 24 hours.")
        self.assertEqual(data_layer_to_dict["temporal_resolution"], "5 days")
        self.assertEqual(data_layer_to_dict["temporal_resolution_description"], "string2")
        self.assertEqual(data_layer_to_dict["spatial_resolution_of_raw_data"], "100m")
        self.assertEqual(data_layer_to_dict["interpolation"], "near")
        self.assertEqual(data_layer_to_dict["interpolation_upload"], "near")
        self.assertEqual(data_layer_to_dict["dimensions_description"], "The sole dimension is called \"horizon\" and refers to the forecast horizon in hours. (Only integer horizons are allowed.)")
        self.assertEqual(data_layer_to_dict["permanence"], True)
        self.assertEqual(data_layer_to_dict["permanence_description"], "Data with timestamp into the future will be update, but remain constant past current timestamp (except for error corrrection).")
        self.assertEqual(data_layer_to_dict["known_issues"], "Updates are irregular.")
        self.assertEqual(data_layer_to_dict["properties"]["sector"][0], "Animals/livestock")
        self.assertEqual(data_layer_to_dict["properties"]["sector"][1], "Transportation/infrastructure")
        self.assertEqual(data_layer_to_dict["properties"]["sector"][2], "Vegetation/crops")
        self.assertEqual(data_layer_to_dict["properties"]["sector"][3], "Weather/climate")
        self.assertEqual(data_layer_to_dict["properties"]["application"][0], "Agriculture")
        self.assertEqual(data_layer_to_dict["properties"]["domain"][0], "Land surface")
        self.assertEqual(data_layer_to_dict["properties"]["type"][0], "Data product")
        self.assertEqual(data_layer_to_dict["properties"]["source"][0], "Satellite")
        self.assertEqual(data_layer_to_dict["properties"]["source"][1], "Survey")
        self.assertEqual(data_layer_to_dict["spatial_coverage"]["country"][0], "Belgium")
        self.assertEqual(data_layer_to_dict["spatial_coverage"]["country"][1], "Bolivia")
        self.assertEqual(data_layer_to_dict["spatial_coverage"]["country"][2], "France")
        self.assertEqual(data_layer_to_dict["spatial_coverage"]["country"][3], "Germany")
        self.assertEqual(data_layer_to_dict["spatial_coverage"]["country"][4], "India")
        self.assertEqual(data_layer_to_dict["spatial_coverage"]["country"][5], "Indonesia")
        self.assertEqual(data_layer_to_dict["spatial_coverage"]["country"][6], "Luxembourg")
        self.assertEqual(data_layer_to_dict["spatial_coverage"]["country"][7], "Netherlands")
        self.assertEqual(data_layer_to_dict["spatial_coverage"]["country"][8], "Switzerland")
        self.assertEqual(data_layer_to_dict["spatial_coverage"]["country"][9], "Thailand")
        self.assertEqual(data_layer_to_dict["spatial_coverage"]["country"][10], "United Kingdom")
        self.assertEqual(data_layer_to_dict["spatial_coverage"]["country"][11], "United States of America")
        self.assertEqual(data_layer_to_dict["latitude_min"], -90)
        self.assertEqual(data_layer_to_dict["longitude_min"], -180)
        self.assertEqual(data_layer_to_dict["latitude_max"], 90)
        self.assertEqual(data_layer_to_dict["longitude_max"], 180)
        self.assertEqual(data_layer_to_dict["temporal_min"], "2016-03-12T00:00:01.000Z")
        self.assertEqual(data_layer_to_dict["temporal_max"], "2019-07-30T00:00:01.000Z")
        self.assertEqual(data_layer_to_dict["measurement_interval"], "6 hours")
        self.assertEqual(data_layer_to_dict["measurement_interval_description"], "Data is recorded instanteneously.")
        self.assertEqual(data_layer_to_dict["meaning_of_timestamp"], "Begining")
        self.assertEqual(data_layer_to_dict["meaning_of_spatial_descriptor"], "Average")
        self.assertEqual(data_layer_to_dict["formula"], "$ + 273.15")
        self.assertEqual(data_layer_to_dict["min_value"], 4.0)
        self.assertEqual(data_layer_to_dict["max_value"], 40.0)
            
    #    
    def test_data_layer_to_dict_data_layer_post(self):
            
        self.logger.info('test_data_set_to_dict_data_layer_post')
            
        data_layer2 = catalog.DataLayer

        data_layer_from_dict2 = None
        data_layer_to_dict_data_layer_post   = None
                    
        got_exception = False

        try:
            data_layer_from_dict2 = data_layer2.from_dict(data_layer_dict)
            data_layer_to_dict_data_layer_post = data_layer_from_dict2.to_dict_data_layer_post()
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        self.assertEqual(data_layer_to_dict_data_layer_post["name"], "string")
        self.assertEqual(data_layer_to_dict_data_layer_post["description"], "string")
        self.assertEqual(data_layer_to_dict_data_layer_post["units"], "string")
        self.assertEqual(data_layer_to_dict_data_layer_post["datatype"], "sh")
        self.assertEqual(data_layer_to_dict_data_layer_post["level"], 22)
        self.assertEqual(data_layer_to_dict_data_layer_post["crs"], "string")
        self.assertEqual(data_layer_to_dict_data_layer_post["colorTable"]["id"], "32451")
        self.assertEqual(data_layer_to_dict_data_layer_post["name_alternate"], "ESA Sentinel 2 Level-2A")
        self.assertEqual(data_layer_to_dict_data_layer_post["rating"], 4.0)
        self.assertEqual(data_layer_to_dict_data_layer_post["description_short"], "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.")
        self.assertEqual(data_layer_to_dict_data_layer_post["description_long"], "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.")
        self.assertEqual(data_layer_to_dict_data_layer_post["description_links"][0], "https://sentinel.esa.int/web/sentinel/missions")
        self.assertEqual(data_layer_to_dict_data_layer_post["description_links"][1], "https://sentinel.esa.int/documents/247904/685211/Sentinel-2_User_Handbook")
        self.assertEqual(data_layer_to_dict_data_layer_post["description_links"][2], "https://sentinel.esa.int/web/sentinel/missions/sentinel-2/data-products")
        self.assertEqual(data_layer_to_dict_data_layer_post["description_links"][3], "https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi")
        self.assertEqual(data_layer_to_dict_data_layer_post["data_source_name"], "European Space Agency Sentinel-2")
        self.assertEqual(data_layer_to_dict_data_layer_post["data_source_attribution"], "'Copernicus Sentinel data [Year]' for Sentinel data; see https://lta.cr.usgs.gov/sites/default/files/Sentinel_Data_Terms_and_Conditions.pdf")
        self.assertEqual(data_layer_to_dict_data_layer_post["data_source_description"], "'Level-2A is generated by the Payload Data Ground Segment using the Sen2Cor processor. Level-2A products are made available to users via the Copernicus Open Access Hub: https://scihub.copernicus.eu/dhus/#/home")
        self.assertEqual(data_layer_to_dict_data_layer_post["data_source_links"][0], "https://sentinel.esa.int/web/sentinel/sentinel-data-access")
        self.assertEqual(data_layer_to_dict_data_layer_post["update_interval_max"], "1 day")
        self.assertEqual(data_layer_to_dict_data_layer_post["update_interval_description"], "Uploads are run daily. However, note the temporal resolution.")
        self.assertEqual(data_layer_to_dict_data_layer_post["lag_horizon"], "5 days")
        self.assertEqual(data_layer_to_dict_data_layer_post["lag_horizon_description"], "Data is available within 24 hours.")
        self.assertEqual(data_layer_to_dict_data_layer_post["temporal_resolution"], "5 days")
        self.assertEqual(data_layer_to_dict_data_layer_post["temporal_resolution_description"], "string2")
        self.assertEqual(data_layer_to_dict_data_layer_post["spatial_resolution_of_raw_data"], "100m")
        self.assertEqual(data_layer_to_dict_data_layer_post["interpolation"], "near")
        self.assertEqual(data_layer_to_dict_data_layer_post["interpolation_upload"], "near")
        self.assertEqual(data_layer_to_dict_data_layer_post["dimensions_description"], "The sole dimension is called \"horizon\" and refers to the forecast horizon in hours. (Only integer horizons are allowed.)")
        self.assertEqual(data_layer_to_dict_data_layer_post["permanence"], True)
        self.assertEqual(data_layer_to_dict_data_layer_post["permanence_description"], "Data with timestamp into the future will be update, but remain constant past current timestamp (except for error corrrection).")
        self.assertEqual(data_layer_to_dict_data_layer_post["known_issues"], "Updates are irregular.")
        self.assertEqual(data_layer_to_dict_data_layer_post["properties"]["sector"][0], "Animals/livestock")
        self.assertEqual(data_layer_to_dict_data_layer_post["properties"]["sector"][1], "Transportation/infrastructure")
        self.assertEqual(data_layer_to_dict_data_layer_post["properties"]["sector"][2], "Vegetation/crops")
        self.assertEqual(data_layer_to_dict_data_layer_post["properties"]["sector"][3], "Weather/climate")
        self.assertEqual(data_layer_to_dict_data_layer_post["properties"]["application"][0], "Agriculture")
        self.assertEqual(data_layer_to_dict_data_layer_post["properties"]["domain"][0], "Land surface")
        self.assertEqual(data_layer_to_dict_data_layer_post["properties"]["type"][0], "Data product")
        self.assertEqual(data_layer_to_dict_data_layer_post["properties"]["source"][0], "Satellite")
        self.assertEqual(data_layer_to_dict_data_layer_post["properties"]["source"][1], "Survey")
        self.assertEqual(data_layer_to_dict_data_layer_post["spatial_coverage"]["country"][0], "Belgium")
        self.assertEqual(data_layer_to_dict_data_layer_post["spatial_coverage"]["country"][1], "Bolivia")
        self.assertEqual(data_layer_to_dict_data_layer_post["spatial_coverage"]["country"][2], "France")
        self.assertEqual(data_layer_to_dict_data_layer_post["spatial_coverage"]["country"][3], "Germany")
        self.assertEqual(data_layer_to_dict_data_layer_post["spatial_coverage"]["country"][4], "India")
        self.assertEqual(data_layer_to_dict_data_layer_post["spatial_coverage"]["country"][5], "Indonesia")
        self.assertEqual(data_layer_to_dict_data_layer_post["spatial_coverage"]["country"][6], "Luxembourg")
        self.assertEqual(data_layer_to_dict_data_layer_post["spatial_coverage"]["country"][7], "Netherlands")
        self.assertEqual(data_layer_to_dict_data_layer_post["spatial_coverage"]["country"][8], "Switzerland")
        self.assertEqual(data_layer_to_dict_data_layer_post["spatial_coverage"]["country"][9], "Thailand")
        self.assertEqual(data_layer_to_dict_data_layer_post["spatial_coverage"]["country"][10], "United Kingdom")
        self.assertEqual(data_layer_to_dict_data_layer_post["spatial_coverage"]["country"][11], "United States of America")
        self.assertEqual(data_layer_to_dict_data_layer_post["latitude_min"], -90)
        self.assertEqual(data_layer_to_dict_data_layer_post["longitude_min"], -180)
        self.assertEqual(data_layer_to_dict_data_layer_post["latitude_max"], 90)
        self.assertEqual(data_layer_to_dict_data_layer_post["longitude_max"], 180)
        self.assertEqual(data_layer_to_dict_data_layer_post["temporal_min"], "2016-03-12T00:00:01.000Z")
        self.assertEqual(data_layer_to_dict_data_layer_post["temporal_max"], "2019-07-30T00:00:01.000Z")
        self.assertEqual(data_layer_to_dict_data_layer_post["measurement_interval"], "6 hours")
        self.assertEqual(data_layer_to_dict_data_layer_post["measurement_interval_description"], "Data is recorded instanteneously.")
        self.assertEqual(data_layer_to_dict_data_layer_post["meaning_of_timestamp"], "Begining")
        self.assertEqual(data_layer_to_dict_data_layer_post["meaning_of_spatial_descriptor"], "Average")
        self.assertEqual(data_layer_to_dict_data_layer_post["formula"], "$ + 273.15")
            
    #    
    def test_data_layer_to_dict_data_layer_put(self):
            
        self.logger.info('test_data_set_to_dict_data_layer_put')
            
        data_layer3 = catalog.DataLayer

        data_layer_from_dict3 = None
        data_layer_to_dict_data_layer_put = None
                    
        got_exception = False

        try:
            data_layer_from_dict3 = data_layer3.from_dict(data_layer_dict)
            data_layer_to_dict_data_layer_put = data_layer_from_dict3.to_dict_data_layer_put()
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        self.assertEqual(data_layer_to_dict_data_layer_put["name"], "string")
        self.assertEqual(data_layer_to_dict_data_layer_put["description"], "string")
        self.assertEqual(data_layer_to_dict_data_layer_put["name_alternate"], "ESA Sentinel 2 Level-2A")
        self.assertEqual(data_layer_to_dict_data_layer_put["rating"], 4.0)
        self.assertEqual(data_layer_to_dict_data_layer_put["description_short"], "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.")
        self.assertEqual(data_layer_to_dict_data_layer_put["description_long"], "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.")
        self.assertEqual(data_layer_to_dict_data_layer_put["description_links"][0], "https://sentinel.esa.int/web/sentinel/missions")
        self.assertEqual(data_layer_to_dict_data_layer_put["description_links"][1], "https://sentinel.esa.int/documents/247904/685211/Sentinel-2_User_Handbook")
        self.assertEqual(data_layer_to_dict_data_layer_put["description_links"][2], "https://sentinel.esa.int/web/sentinel/missions/sentinel-2/data-products")
        self.assertEqual(data_layer_to_dict_data_layer_put["description_links"][3], "https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi")
        self.assertEqual(data_layer_to_dict_data_layer_put["data_source_name"], "European Space Agency Sentinel-2")
        self.assertEqual(data_layer_to_dict_data_layer_put["data_source_attribution"], "'Copernicus Sentinel data [Year]' for Sentinel data; see https://lta.cr.usgs.gov/sites/default/files/Sentinel_Data_Terms_and_Conditions.pdf")
        self.assertEqual(data_layer_to_dict_data_layer_put["data_source_description"], "'Level-2A is generated by the Payload Data Ground Segment using the Sen2Cor processor. Level-2A products are made available to users via the Copernicus Open Access Hub: https://scihub.copernicus.eu/dhus/#/home")
        self.assertEqual(data_layer_to_dict_data_layer_put["data_source_links"][0], "https://sentinel.esa.int/web/sentinel/sentinel-data-access")
        self.assertEqual(data_layer_to_dict_data_layer_put["update_interval_max"], "1 day")
        self.assertEqual(data_layer_to_dict_data_layer_put["update_interval_description"], "Uploads are run daily. However, note the temporal resolution.")
        self.assertEqual(data_layer_to_dict_data_layer_put["lag_horizon"], "5 days")
        self.assertEqual(data_layer_to_dict_data_layer_put["lag_horizon_description"], "Data is available within 24 hours.")
        self.assertEqual(data_layer_to_dict_data_layer_put["temporal_resolution"], "5 days")
        self.assertEqual(data_layer_to_dict_data_layer_put["temporal_resolution_description"], "string2")
        self.assertEqual(data_layer_to_dict_data_layer_put["spatial_resolution_of_raw_data"], "100m")
        self.assertEqual(data_layer_to_dict_data_layer_put["interpolation"], "near")
        self.assertEqual(data_layer_to_dict_data_layer_put["interpolation_upload"], "near")
        self.assertEqual(data_layer_to_dict_data_layer_put["dimensions_description"], "The sole dimension is called \"horizon\" and refers to the forecast horizon in hours. (Only integer horizons are allowed.)")
        self.assertEqual(data_layer_to_dict_data_layer_put["permanence"], True)
        self.assertEqual(data_layer_to_dict_data_layer_put["permanence_description"], "Data with timestamp into the future will be update, but remain constant past current timestamp (except for error corrrection).")
        self.assertEqual(data_layer_to_dict_data_layer_put["known_issues"], "Updates are irregular.")
        self.assertEqual(data_layer_to_dict_data_layer_put["properties"]["sector"][0], "Animals/livestock")
        self.assertEqual(data_layer_to_dict_data_layer_put["properties"]["sector"][1], "Transportation/infrastructure")
        self.assertEqual(data_layer_to_dict_data_layer_put["properties"]["sector"][2], "Vegetation/crops")
        self.assertEqual(data_layer_to_dict_data_layer_put["properties"]["sector"][3], "Weather/climate")
        self.assertEqual(data_layer_to_dict_data_layer_put["properties"]["application"][0], "Agriculture")
        self.assertEqual(data_layer_to_dict_data_layer_put["properties"]["domain"][0], "Land surface")
        self.assertEqual(data_layer_to_dict_data_layer_put["properties"]["type"][0], "Data product")
        self.assertEqual(data_layer_to_dict_data_layer_put["properties"]["source"][0], "Satellite")
        self.assertEqual(data_layer_to_dict_data_layer_put["properties"]["source"][1], "Survey")
        self.assertEqual(data_layer_to_dict_data_layer_put["spatial_coverage"]["country"][0], "Belgium")
        self.assertEqual(data_layer_to_dict_data_layer_put["spatial_coverage"]["country"][1], "Bolivia")
        self.assertEqual(data_layer_to_dict_data_layer_put["spatial_coverage"]["country"][2], "France")
        self.assertEqual(data_layer_to_dict_data_layer_put["spatial_coverage"]["country"][3], "Germany")
        self.assertEqual(data_layer_to_dict_data_layer_put["spatial_coverage"]["country"][4], "India")
        self.assertEqual(data_layer_to_dict_data_layer_put["spatial_coverage"]["country"][5], "Indonesia")
        self.assertEqual(data_layer_to_dict_data_layer_put["spatial_coverage"]["country"][6], "Luxembourg")
        self.assertEqual(data_layer_to_dict_data_layer_put["spatial_coverage"]["country"][7], "Netherlands")
        self.assertEqual(data_layer_to_dict_data_layer_put["spatial_coverage"]["country"][8], "Switzerland")
        self.assertEqual(data_layer_to_dict_data_layer_put["spatial_coverage"]["country"][9], "Thailand")
        self.assertEqual(data_layer_to_dict_data_layer_put["spatial_coverage"]["country"][10], "United Kingdom")
        self.assertEqual(data_layer_to_dict_data_layer_put["spatial_coverage"]["country"][11], "United States of America")
        self.assertEqual(data_layer_to_dict_data_layer_put["latitude_min"], -90)
        self.assertEqual(data_layer_to_dict_data_layer_put["longitude_min"], -180)
        self.assertEqual(data_layer_to_dict_data_layer_put["latitude_max"], 90)
        self.assertEqual(data_layer_to_dict_data_layer_put["longitude_max"], 180)
        self.assertEqual(data_layer_to_dict_data_layer_put["temporal_min"], "2016-03-12T00:00:01.000Z")
        self.assertEqual(data_layer_to_dict_data_layer_put["temporal_max"], "2019-07-30T00:00:01.000Z")
        self.assertEqual(data_layer_to_dict_data_layer_put["measurement_interval"], "6 hours")
        self.assertEqual(data_layer_to_dict_data_layer_put["measurement_interval_description"], "Data is recorded instanteneously.")
        self.assertEqual(data_layer_to_dict_data_layer_put["meaning_of_timestamp"], "Begining")
        self.assertEqual(data_layer_to_dict_data_layer_put["meaning_of_spatial_descriptor"], "Average")
        self.assertEqual(data_layer_to_dict_data_layer_put["formula"], "$ + 273.15")
        self.assertEqual(data_layer_to_dict_data_layer_put["min_value"], 4.0)
        self.assertEqual(data_layer_to_dict_data_layer_put["max_value"], 40.0)

    #
    def test_data_layer_from_json(self):
            
        self.logger.info('test_data_set_from_json')
            
        got_exception = False

        try:
            data_layer_from_json = catalog.data_layer_from_json(data_layer_str)
        except Exception as ex:
            self.logger.info(ex)
            got_exception = True

        self.assertFalse(got_exception)
        self.assertEqual(data_layer_from_json.id, "string")
        self.assertEqual(data_layer_from_json.name, "string")
        self.assertEqual(data_layer_from_json.description, "string")
        self.assertEqual(data_layer_from_json.dataset.id, "string")
        self.assertEqual(data_layer_from_json.dataset.name, "string")
        self.assertEqual(data_layer_from_json.dataset.key, "string")
        self.assertEqual(data_layer_from_json.dataset.category.id, 1)
        self.assertEqual(data_layer_from_json.dataset.category.name, "Satellite")
        self.assertEqual(data_layer_from_json.dataset.level, 0)
        self.assertEqual(data_layer_from_json.dataset.crs, "string")
        self.assertEqual(data_layer_from_json.dataset.license_information, "string")
        self.assertEqual(data_layer_from_json.dataset.offering_status, "string")
        self.assertEqual(data_layer_from_json.dataset.description_short, "string")
        self.assertEqual(data_layer_from_json.units, "string")
        self.assertEqual(data_layer_from_json.datatype, "sh")
        self.assertEqual(data_layer_from_json.level, 22)
        self.assertEqual(data_layer_from_json.crs, "string")
        self.assertEqual(data_layer_from_json.color_table.id, "32451")
        self.assertEqual(data_layer_from_json.name_alternate, "ESA Sentinel 2 Level-2A")
        self.assertEqual(data_layer_from_json.rating, 4.0)
        self.assertEqual(data_layer_from_json.description_short, "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.")
        self.assertEqual(data_layer_from_json.description_long, "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.")
        self.assertEqual(data_layer_from_json.description_links[0], "https://sentinel.esa.int/web/sentinel/missions")
        self.assertEqual(data_layer_from_json.description_links[1], "https://sentinel.esa.int/documents/247904/685211/Sentinel-2_User_Handbook")
        self.assertEqual(data_layer_from_json.description_links[2], "https://sentinel.esa.int/web/sentinel/missions/sentinel-2/data-products")
        self.assertEqual(data_layer_from_json.description_links[3], "https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi")
        self.assertEqual(data_layer_from_json.data_source_name, "European Space Agency Sentinel-2")
        self.assertEqual(data_layer_from_json.data_source_attribution, "'Copernicus Sentinel data [Year]' for Sentinel data; see https://lta.cr.usgs.gov/sites/default/files/Sentinel_Data_Terms_and_Conditions.pdf")
        self.assertEqual(data_layer_from_json.data_source_description, "'Level-2A is generated by the Payload Data Ground Segment using the Sen2Cor processor. Level-2A products are made available to users via the Copernicus Open Access Hub: https://scihub.copernicus.eu/dhus/#/home")
        self.assertEqual(data_layer_from_json.data_source_links[0], "https://sentinel.esa.int/web/sentinel/sentinel-data-access")
        self.assertEqual(data_layer_from_json.update_interval_max, "1 day")
        self.assertEqual(data_layer_from_json.update_interval_description, "Uploads are run daily. However, note the temporal resolution.")
        self.assertEqual(data_layer_from_json.lag_horizon, "5 days")
        self.assertEqual(data_layer_from_json.lag_horizon_description, "Data is available within 24 hours.")
        self.assertEqual(data_layer_from_json.temporal_resolution, "5 days")
        self.assertEqual(data_layer_from_json.temporal_resolution_description, "string2")
        self.assertEqual(data_layer_from_json.spatial_resolution_of_raw_data, "100m")
        self.assertEqual(data_layer_from_json.interpolation, "near")
        self.assertEqual(data_layer_from_json.interpolation_upload, "near")
        self.assertEqual(data_layer_from_json.dimensions_description, "The sole dimension is called \"horizon\" and refers to the forecast horizon in hours. (Only integer horizons are allowed.)")
        self.assertEqual(data_layer_from_json.permanence, True)
        self.assertEqual(data_layer_from_json.permanence_description, "Data with timestamp into the future will be update, but remain constant past current timestamp (except for error corrrection).")
        self.assertEqual(data_layer_from_json.known_issues, "Updates are irregular.")
        self.assertEqual(data_layer_from_json.properties.sector[0], "Animals/livestock")
        self.assertEqual(data_layer_from_json.properties.sector[1], "Transportation/infrastructure")
        self.assertEqual(data_layer_from_json.properties.sector[2], "Vegetation/crops")
        self.assertEqual(data_layer_from_json.properties.sector[3], "Weather/climate")
        self.assertEqual(data_layer_from_json.properties.application[0], "Agriculture")
        self.assertEqual(data_layer_from_json.properties.domain[0], "Land surface")
        self.assertEqual(data_layer_from_json.properties.type[0], "Data product")
        self.assertEqual(data_layer_from_json.properties.source[0], "Satellite")
        self.assertEqual(data_layer_from_json.properties.source[1], "Survey")
        self.assertEqual(data_layer_from_json.spatial_coverage.country[0], "Belgium")
        self.assertEqual(data_layer_from_json.spatial_coverage.country[1], "Bolivia")
        self.assertEqual(data_layer_from_json.spatial_coverage.country[2], "France")
        self.assertEqual(data_layer_from_json.spatial_coverage.country[3], "Germany")
        self.assertEqual(data_layer_from_json.spatial_coverage.country[4], "India")
        self.assertEqual(data_layer_from_json.spatial_coverage.country[5], "Indonesia")
        self.assertEqual(data_layer_from_json.spatial_coverage.country[6], "Luxembourg")
        self.assertEqual(data_layer_from_json.spatial_coverage.country[7], "Netherlands")
        self.assertEqual(data_layer_from_json.spatial_coverage.country[8], "Switzerland")
        self.assertEqual(data_layer_from_json.spatial_coverage.country[9], "Thailand")
        self.assertEqual(data_layer_from_json.spatial_coverage.country[10], "United Kingdom")
        self.assertEqual(data_layer_from_json.spatial_coverage.country[11], "United States of America")
        self.assertEqual(data_layer_from_json.latitude_min, -90)
        self.assertEqual(data_layer_from_json.longitude_min, -180)
        self.assertEqual(data_layer_from_json.latitude_max, 90)
        self.assertEqual(data_layer_from_json.longitude_max, 180)
        self.assertEqual(data_layer_from_json.temporal_min, "2016-03-12T00:00:01.000Z")
        self.assertEqual(data_layer_from_json.temporal_max, "2019-07-30T00:00:01.000Z")
        self.assertEqual(data_layer_from_json.measurement_interval, "6 hours")
        self.assertEqual(data_layer_from_json.measurement_interval_description, "Data is recorded instanteneously.")
        self.assertEqual(data_layer_from_json.meaning_of_timestamp, "Begining")
        self.assertEqual(data_layer_from_json.meaning_of_spatial_descriptor, "Average")
        self.assertEqual(data_layer_from_json.formula, "$ + 273.15")
        self.assertEqual(data_layer_from_json.min_value, 4.0)
        self.assertEqual(data_layer_from_json.max_value, 40.0)
     
    #
    def test_layer_set_to_json(self):
            
        self.logger.info('test_layer_set_to_json')
            
        got_exception = False
            
        try:
            data_layer_from_json = catalog.data_layer_from_json(data_layer_str)
            data_layer_to_json = catalog.data_layer_to_json(data_layer_from_json)
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
            
    #
    def test_layer_set_to_json_data_layer_post(self):
            
        self.logger.info('test_layer_set_to_json_data_layer_post')
            
        got_exception = False
            
        try:
            data_layer_from_json2 = catalog.data_layer_from_json(data_layer_str)
            data_layer_to_json_data_layer_post = catalog.data_layer_to_json_post(data_layer_from_json2)
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
            
    #
    def test_layer_set_to_json_data_layer_put(self):
            
        self.logger.info('test_layer_set_to_json_data_layer_put')
            
        got_exception = False
            
        try:
            data_layer_from_json3 = catalog.data_layer_from_json(data_layer_str)
            data_layer_to_json_data_layer_put = catalog.data_layer_to_json_put(data_layer_from_json3)
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        
    #    
    def test_data_layer_display(self):
        
        self.logger.info('test_data_layer_display')
        
        try:
            data_layer_from_json3 = catalog.data_layer_from_json(data_layer_str)
            df = data_layer_from_json3.display()
        except Exception as ex:
            got_exception = True
        
        self.assertTrue(isinstance(df, pd.DataFrame))
        self.assertTrue(pd.isna(df.at[0,'dataset_id']))
        self.assertEqual(df.at[0,'id'], "string")
        self.assertEqual(df.at[0,'name'], "string")
        self.assertEqual(df.at[0,'description_short'], "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.")
        self.assertEqual(df.at[0,'description_long'], "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.")
        self.assertEqual(df.at[0,'level'], 22)
        #self.assertTrue(pd.isna(df.at[0,'type']))
        self.assertTrue(pd.isna(df.at[0,'unit']))

        try:
            data_layer_from_json4 = catalog.data_layer_from_json(data_layer_str)
            df2 = data_layer_from_json4.display(columns = ['id', 'name', 'notacolumn'])
        except Exception as ex:
            got_exception = True
        
        self.assertEqual(df2.at[0,'id'], "string")
        self.assertEqual(df2.at[0,'name'], "string")
        self.assertTrue(pd.isna(df2.at[0,'notacolumn']))
        
    # mocked_data_layer_requests_get
    @mock.patch('ibmpairs.client.Client.get', 
                side_effect=mocked_data_layer_requests_get
               )
    def test_data_layer_get(self, mock_get):
        
        self.logger.info('test_data_layer_get: success')
        
        dl = catalog.DataLayer()
                        
        got_exception = False

        try:
            result = dl.get(id = "1")
        except Exception as ex:
            got_exception = True
            
        self.assertFalse(got_exception)
        
        self.assertEqual(result.id, "string")
        self.assertEqual(result.name_alternate, "ESA Sentinel 2 Level-2A")
        
        self.logger.info('test_data_layer_get: id already in object')
        
        dl5 = catalog.DataLayer()
                        
        got_exception5 = False

        try:
            dl5.id = "1"
            result = dl5.get()
        except Exception as ex:
            got_exception5 = True
            
        self.assertFalse(got_exception5)
        
        self.logger.info('test_data_layer_get: fail 404')
        
        dl2 = catalog.DataLayer()
                        
        got_exception2 = False

        try:
            result = dl2.get(id = "2")
        except Exception as ex:
            got_exception2 = True
            self.assertEqual(str(ex), "The GET request call to https://pairs.res.ibm.com/v2/datalayers/2 failed with status code: 404, message: failed.")
            
        self.assertTrue(got_exception2)
        
        self.logger.info('test_data_layer_get: fail server error')
        
        dl3 = catalog.DataLayer()
                        
        got_exception3 = False

        try:
            result = dl3.get(id = "3")
        except Exception as ex:
            got_exception3 = True
            self.assertEqual(str(ex), "The GET request to https://pairs.res.ibm.com/v2/datalayers/3 encountered an unspecified error contacting the server; the request was unsuccessful, error message: __init__() got an unexpected keyword argument 'status'")

        self.assertTrue(got_exception3)
        
        self.logger.info('test_data_layer_get: fail no id')
        
        dl4 = catalog.DataLayer()
                        
        got_exception4 = False

        try:
            result = dl4.get()
        except Exception as ex:
            got_exception4 = True
            self.assertEqual(str(ex), "The DataLayer object has no ID set and none was provided.")

        self.assertTrue(got_exception4)
        
        self.logger.info('test_data_layer_get: helper, success')
                        
        got_exception6 = False

        try:
            result = catalog.get_data_layer(id = "1")
        except Exception as ex:
            got_exception6 = True
            
        self.assertFalse(got_exception6)
        
        self.assertEqual(result.id, "string")
        self.assertEqual(result.name_alternate, "ESA Sentinel 2 Level-2A")
        
    # mocked_data_layer_requests_post
    @mock.patch('ibmpairs.client.Client.get', 
                side_effect=mocked_data_layers_requests_get
               )
    @mock.patch('ibmpairs.client.Client.post', 
                side_effect=mocked_data_layer_requests_post
               )
    def test_data_layer_create(self, mock_post, mock_get):
    #, mock_get):
        
        self.logger.info('test_data_layer_create: success')
        
        got_exception = False

        try:
            data_layer_create = catalog.data_layer_from_json(data_layer_requests_post_success_dict)
            dls = data_layer_create.create(data_set_id      = 1,
                                           data_layer_type  = 'raster',
                                           data_layer_group = None
                                          )
        except Exception as ex:
            self.logger.info(ex)        
            got_exception = True
            
        self.assertFalse(got_exception)
        self.assertEqual(dls.data_layer_response.data_layer_ids[0], "1")
        self.assertEqual(dls.data_layer_response.status, 200)
        self.assertEqual(dls.data_layer_response.message, "Datalayer(s) created successfully")
        
        self.assertEqual(dls.data_set_id, "1")
        self.assertEqual(dls.layer_type, "raster")
        self.assertEqual(dls.data_layers[0].id, "1")
        self.assertEqual(dls.data_layers[0].name, "string")
        self.assertEqual(dls.data_layers[0].dataset.category.id, 1)
        
        self.logger.info('test_data_layer_create: fail 404')
        
        got_exception2 = False

        try:
            data_layer_create2 = catalog.data_layer_from_json(data_layer_requests_post_success_dict)
            data_layer_create2.name = "string2"
            dls2 = data_layer_create2.create(data_set_id      = 2,
                                             data_layer_type  = 'raster',
                                             data_layer_group = None)
        except Exception as ex:
            self.logger.info(ex)
            self.assertEqual(str(ex), "The POST request call to /v2/datasets/2/datalayers failed with status code: 404, message: Error: 404 Not Found.")
            got_exception2 = True
            
        self.assertTrue(got_exception2)
        
        self.logger.info('test_data_layer_create: fail server error')
        
        got_exception3 = False

        try:
            data_layer_create3 = catalog.data_layer_from_json(data_layer_requests_post_success_dict)
            data_layer_create3.name = "string3"
            dl3 = data_layer_create3.create(data_set_id      = 3,
                                            data_layer_type  = 'raster',
                                            data_layer_group = None)
        except Exception as ex:
            self.logger.info(ex)
            self.assertEqual(str(ex), "The POST request to https://pairs.res.ibm.com/v2/datasets/3/datalayers encountered an unspecified error contacting the server; the request was unsuccessful, error message: __init__() got an unexpected keyword argument 'status'")
            got_exception3 = True
            
        self.assertTrue(got_exception3)
        
        self.logger.info('test_data_layer_create: helper, success')
        
        got_exception4 = False

        try:
            data_layer_create4 = catalog.data_layer_from_json(data_layer_requests_post_success_dict)
            helper = catalog.create_data_layer(data_layer = data_layer_create4,
                                               data_set_id      = 1,
                                               data_layer_type  = 'raster',
                                               data_layer_group = None
                                              )
        except Exception as ex:
            self.logger.info(ex)        
            got_exception4 = True
            
        self.assertFalse(got_exception4)
        self.assertEqual(helper.data_layer_response.data_layer_ids[0], "1")
        self.assertEqual(helper.data_layer_response.status, 200)
        self.assertEqual(helper.data_layer_response.message, "Datalayer(s) created successfully")
        
    # mocked_data_layer_requests_put
    @mock.patch('ibmpairs.client.Client.put', 
                side_effect=mocked_data_layer_requests_put
               )
    def test_data_layer_update(self, mock_put):
        
        self.logger.info('test_data_layer_update: success')
        
        got_exception = False

        try:
            data_layer_update = catalog.data_layer_from_json(data_layer_requests_post_success_dict)
            data_layer_update.update(id = 1)
        except Exception as ex:
            self.logger.info(ex)        
            got_exception = True
            
        self.assertFalse(got_exception)
        
        self.assertEqual(data_layer_update.data_layer_response.data_layer_ids[0], "87234")
        self.assertEqual(data_layer_update.data_layer_response.data_layer_ids[1], "87235")
        self.assertEqual(data_layer_update.data_layer_response.data_layer_ids[2], "872346")
        self.assertEqual(data_layer_update.data_layer_response.status, 200)
        self.assertEqual(data_layer_update.data_layer_response.message, "Datalayer(s) created successfully")
        
        self.logger.info('test_data_layer_update: id already in object')
            
        got_exception5 = False

        try:
            data_layer_update5 = catalog.data_layer_from_json(data_layer_requests_post_success_dict)
            data_layer_update5.id = "1"
            data_layer_update5.update()
        except Exception as ex:
            self.logger.info(ex)        
            got_exception5 = True
            
        self.assertFalse(got_exception5)
        
        self.logger.info('test_data_layer_update: fail 404')
        
        got_exception = False

        try:
            data_layer_update2 = catalog.data_layer_from_json(data_layer_requests_post_success_dict)
            data_layer_update2.name = "string2"
            data_layer_update2.update(id = 2)
        except Exception as ex:
            self.logger.info(ex)
            self.assertEqual(str(ex), "The PUT request call to https://pairs.res.ibm.com/v2/datalayers/2 failed with status code: 404, message: Error: 404 Not Found.")
            got_exception = True
            
        self.assertTrue(got_exception)
        self.assertEqual(data_layer_update2.data_layer_response.message, "Error: 404 Not Found")
        
        self.logger.info('test_data_layer_update: fail server error')
        
        got_exception = False

        try:
            data_layer_update3 = catalog.data_layer_from_json(data_layer_requests_post_success_dict)
            data_layer_update3.name = "string3"
            data_layer_update3.update(id = 3)
        except Exception as ex:
            self.logger.info(ex)
            self.assertEqual(str(ex), "The PUT request to https://pairs.res.ibm.com/v2/datalayers/3 encountered an unspecified error contacting the server; the request was unsuccessful, error message: __init__() got an unexpected keyword argument 'status'")
            got_exception = True
            
        self.assertTrue(got_exception)
        
        self.logger.info('test_data_layer_get: fail no id')
        
        got_exception4 = False

        try:
            data_layer_update4 = catalog.data_layer_from_json(data_layer_requests_post_success_dict)
            data_layer_update4.update()
        except Exception as ex:
            self.logger.info(ex)        
            got_exception4 = True
            self.assertEqual(str(ex), "The DataLayer object has no ID set and none was provided.")

        self.assertTrue(got_exception4)
        
        self.logger.info('test_data_layer_update: helper, success')
        
        got_exception6 = False

        try:
            data_layer_update6 = catalog.data_layer_from_json(data_layer_requests_post_success_dict)
            catalog.update_data_layer(data_layer = data_layer_update6,
                                      id         = 1)
        except Exception as ex:
            self.logger.info(ex)        
            got_exception6 = True

        self.assertEqual(data_layer_update6.data_layer_response.data_layer_ids[0], "87234")
        self.assertEqual(data_layer_update6.data_layer_response.data_layer_ids[1], "87235")
        self.assertEqual(data_layer_update6.data_layer_response.data_layer_ids[2], "872346")
        self.assertEqual(data_layer_update6.data_layer_response.status, 200)
        self.assertEqual(data_layer_update6.data_layer_response.message, "Datalayer(s) created successfully")

    # mocked_data_layer_requests_delete
    @mock.patch('ibmpairs.client.Client.delete', 
                side_effect=mocked_data_layer_requests_delete
               )
    def test_data_layer_delete(self, mock_delete):
        
        self.logger.info('test_data_layer_delete: success')
        
        got_exception = False

        try:
            data_layer_delete = catalog.DataLayer()
            data_layer_delete.delete(id = 1)
        except Exception as ex:
            self.logger.info(ex)        
            got_exception = True
            
        self.assertFalse(got_exception)
        self.assertEqual(data_layer_delete.data_layer_response.id, "1")
        
        self.logger.info('test_data_layer_delete: hard delete')
            
        got_exception5 = False

        try:
            data_layer_delete5 = catalog.DataLayer()
            data_layer_delete5.delete(id          = 2,
                                      hard_delete = True)
        except Exception as ex:
            self.logger.info(ex)        
            got_exception5 = True
            
        self.assertFalse(got_exception5)
        
        self.logger.info('test_data_layer_delete: fail 404')
        
        got_exception = False

        try:
            data_layer_delete2 = catalog.DataLayer()
            data_layer_delete2.delete(id = 3)
        except Exception as ex:
            self.logger.info(ex)
            self.assertEqual(str(ex), "The DELETE request call to https://pairs.res.ibm.com/v2/datalayers/3 failed with status code: 404, message: Error: 404 Not Found.")
            got_exception = True
            
        self.assertTrue(got_exception)
        self.assertEqual(data_layer_delete2.data_layer_response.message, "Error: 404 Not Found")
        
        self.logger.info('test_data_layer_delete: fail server error')
        
        got_exception = False

        try:
            data_layer_delete3 = catalog.DataLayer()
            data_layer_delete3.delete(id = 4)
        except Exception as ex:
            self.logger.info(ex)
            self.assertEqual(str(ex), "The DELETE request to https://pairs.res.ibm.com/v2/datalayers/4 encountered an unspecified error contacting the server; the request was unsuccessful, error message: __init__() got an unexpected keyword argument 'status'")
            got_exception = True
            
        self.assertTrue(got_exception)
        
        self.logger.info('test_data_layer_delete: helper, success')
        
        got_exception6 = False

        try:
            data_layer_delete6 = catalog.DataLayer()
            helper = catalog.delete_data_layer(id = 1)
        except Exception as ex:
            self.logger.info(ex)        
            got_exception6 = True
            
        self.assertFalse(got_exception6)
        self.assertEqual(helper.data_layer_response.id, "1")
        
data_layers_dict = [
    {
        "id": "string",
        "name": "string",
        "description": "string",
        "dataset": {
            "id": "string",
            "name": "string",
            "key": "string",
            "category": {
                "id": "1",
                "name": "Satellite"
            },
            "level": 0,
            "crs": "string",
            "license_information": "string",
            "offering_status": "string",
            "description_short": "string"
        },
        "units": "string",
        "datatype": "sh",
        "level": "22",
        "crs": "string",
        "colorTable": {
            "id": "32451"
        },
        "name_alternate": "ESA Sentinel 2 Level-2A",
        "rating": "4.0",
        "description_short": "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.",
        "description_long": "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.",
        "description_links": [
            "https://sentinel.esa.int/web/sentinel/missions",
            "https://sentinel.esa.int/documents/247904/685211/Sentinel-2_User_Handbook",
            "https://sentinel.esa.int/web/sentinel/missions/sentinel-2/data-products",
            "https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi"
        ],
        "data_source_name": "European Space Agency Sentinel-2",
        "data_source_attribution": "'Copernicus Sentinel data [Year]' for Sentinel data; see https://lta.cr.usgs.gov/sites/default/files/Sentinel_Data_Terms_and_Conditions.pdf",
        "data_source_description": "'Level-2A is generated by the Payload Data Ground Segment using the Sen2Cor processor. Level-2A products are made available to users via the Copernicus Open Access Hub: https://scihub.copernicus.eu/dhus/#/home",
        "data_source_links": [
            "https://sentinel.esa.int/web/sentinel/sentinel-data-access"
        ],
        "update_interval_max": "1 day",
        "update_interval_description": "Uploads are run daily. However, note the temporal resolution.",
        "lag_horizon": "5 days",
        "lag_horizon_description": "Data is available within 24 hours.",
        "temporal_resolution": "5 days",
        "temporal_resolution_description": "string",
        "spatial_resolution_of_raw_data": "100m",
        "interpolation": "near",
        "interpolation_upload": "near",
        "dimensions_description": "The sole dimension is called \"horizon\" and refers to the forecast horizon in hours. (Only integer horizons are allowed.)",
        "permanence": "true",
        "permanence_description": "Data with timestamp into the future will be update, but remain constant past current timestamp (except for error corrrection).",
        "known_issues": "Updates are irregular.",
        "properties": {
            "Sector": [
                "Animals/livestock",
                "Transportation/infrastructure",
                "Vegetation/crops",
                "Weather/climate"
            ],
            "Application": [
                "Agriculture"
            ],
            "Domain": [
                "Land surface"
            ],
            "Type": [
                "Data product"
            ],
            "Source": [
                "Satellite",
                "Survey"
            ]
        },
        "spatial_coverage": {
            "Country": [
                "Belgium",
                "Bolivia",
                "France",
                "Germany",
                "India",
                "Indonesia",
                "Luxembourg",
                "Netherlands",
                "Switzerland",
                "Thailand",
                "United Kingdom",
                "United States of America"
            ]
        },
        "latitude_min": "-90",
        "longitude_min": "-180",
        "latitude_max": "90",
        "longitude_max": "180",
        "temporal_min": "2016-03-12T00:00:01.000Z",
        "temporal_max": "2019-07-30T00:00:01.000Z",
        "measurement_interval": "6 hours",
        "measurement_interval_description": "Data is recorded instanteneously.",
        "meaning_of_timestamp": "Begining",
        "meaning_of_spatial_descriptor": "Average"
    },
    {
        "id": "string2",
        "name": "string2",
        "description": "string2",
        "dataset": {
            "id": "string2",
            "name": "string2",
            "key": "string2",
            "category": {
                "id": "2",
                "name": "Satellite"
            },
            "level": 1,
            "crs": "string2",
            "license_information": "string2",
            "offering_status": "string2",
            "description_short": "string2"
        },
        "units": "string2",
        "datatype": "sh",
        "level": "23",
        "crs": "string2",
        "colorTable": {
            "id": "32451"
        },
        "name_alternate": "ESA Sentinel 2 Level-2A",
        "rating": "4.1",
        "description_short": "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.",
        "description_long": "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.",
        "description_links": [
            "https://sentinel.esa.int/web/sentinel/missions2",
            "https://sentinel.esa.int/documents/247904/685211/Sentinel-2_User_Handbook2",
            "https://sentinel.esa.int/web/sentinel/missions/sentinel-2/data-products2",
            "https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi2"
        ],
        "data_source_name": "European Space Agency Sentinel-2",
        "data_source_attribution": "'Copernicus Sentinel data [Year]' for Sentinel data; see https://lta.cr.usgs.gov/sites/default/files/Sentinel_Data_Terms_and_Conditions.pdf",
        "data_source_description": "'Level-2A is generated by the Payload Data Ground Segment using the Sen2Cor processor. Level-2A products are made available to users via the Copernicus Open Access Hub: https://scihub.copernicus.eu/dhus/#/home",
        "data_source_links": [
            "https://sentinel.esa.int/web/sentinel/sentinel-data-access2"
        ],
        "update_interval_max": "1 day",
        "update_interval_description": "Uploads are run daily. However, note the temporal resolution.",
        "lag_horizon": "5 days",
        "lag_horizon_description": "Data is available within 24 hours.",
        "temporal_resolution": "5 days",
        "temporal_resolution_description": "string2",
        "spatial_resolution_of_raw_data": "100m",
        "interpolation": "near",
        "interpolation_upload": "near",
        "dimensions_description": "The sole dimension is called \"horizon\" and refers to the forecast horizon in hours. (Only integer horizons are allowed.)",
        "permanence": "true",
        "permanence_description": "Data with timestamp into the future will be update, but remain constant past current timestamp (except for error corrrection).",
        "known_issues": "Updates are irregular.",
        "properties": {
            "Sector": [
                "Animals/livestock2",
                "Transportation/infrastructure2",
                "Vegetation/crops2",
                "Weather/climate2"
            ],
            "Application": [
                "Agriculture2"
            ],
            "Domain": [
                "Land surface2"
            ],
            "Type": [
                "Data product2"
            ],
            "Source": [
                "Satellite2",
                "Survey2"
            ]
        },
        "spatial_coverage": {
            "Country": [
                "Belgium2",
                "Bolivia2",
                "France2",
                "Germany2",
                "India2",
                "Indonesia2",
                "Luxembourg2",
                "Netherlands2",
                "Switzerland2",
                "Thailand2",
                "United Kingdom2",
                "United States of America2"
            ]
        },
        "latitude_min": "-180",
        "longitude_min": "-90",
        "latitude_max": "180",
        "longitude_max": "90",
        "temporal_min": "1970-03-12T00:00:01.000Z",
        "temporal_max": "1970-07-30T00:00:01.000Z",
        "measurement_interval": "6 hours",
        "measurement_interval_description": "Data is recorded instanteneously.",
        "meaning_of_timestamp": "Begining",
        "meaning_of_spatial_descriptor": "Average"
    }
]
    
data_layers_str = r'''[
    {
        "id": "string",
        "name": "string",
        "description": "string",
        "dataset": {
            "id": "string",
            "name": "string",
            "key": "string",
            "category": {
                "id": "1",
                "name": "Satellite"
            },
            "level": 0,
            "crs": "string",
            "license_information": "string",
            "offering_status": "string",
            "description_short": "string"
        },
        "units": "string",
        "datatype": "sh",
        "level": "22",
        "crs": "string",
        "colorTable": {
            "id": "32451"
        },
        "name_alternate": "ESA Sentinel 2 Level-2A",
        "rating": "4.0",
        "description_short": "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.",
        "description_long": "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.",
        "description_links": [
            "https://sentinel.esa.int/web/sentinel/missions",
            "https://sentinel.esa.int/documents/247904/685211/Sentinel-2_User_Handbook",
            "https://sentinel.esa.int/web/sentinel/missions/sentinel-2/data-products",
            "https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi"
        ],
        "data_source_name": "European Space Agency Sentinel-2",
        "data_source_attribution": "'Copernicus Sentinel data [Year]' for Sentinel data; see https://lta.cr.usgs.gov/sites/default/files/Sentinel_Data_Terms_and_Conditions.pdf",
        "data_source_description": "'Level-2A is generated by the Payload Data Ground Segment using the Sen2Cor processor. Level-2A products are made available to users via the Copernicus Open Access Hub: https://scihub.copernicus.eu/dhus/#/home",
        "data_source_links": [
            "https://sentinel.esa.int/web/sentinel/sentinel-data-access"
        ],
        "update_interval_max": "1 day",
        "update_interval_description": "Uploads are run daily. However, note the temporal resolution.",
        "lag_horizon": "5 days",
        "lag_horizon_description": "Data is available within 24 hours.",
        "temporal_resolution": "5 days",
        "temporal_resolution_description": "string",
        "spatial_resolution_of_raw_data": "100m",
        "interpolation": "near",
        "interpolation_upload": "near",
        "dimensions_description": "The sole dimension is called \"horizon\" and refers to the forecast horizon in hours. (Only integer horizons are allowed.)",
        "permanence": "true",
        "permanence_description": "Data with timestamp into the future will be update, but remain constant past current timestamp (except for error corrrection).",
        "known_issues": "Updates are irregular.",
        "properties": {
            "Sector": [
                "Animals/livestock",
                "Transportation/infrastructure",
                "Vegetation/crops",
                "Weather/climate"
            ],
            "Application": [
                "Agriculture"
            ],
            "Domain": [
                "Land surface"
            ],
            "Type": [
                "Data product"
            ],
            "Source": [
                "Satellite",
                "Survey"
            ]
        },
        "spatial_coverage": {
            "Country": [
                "Belgium",
                "Bolivia",
                "France",
                "Germany",
                "India",
                "Indonesia",
                "Luxembourg",
                "Netherlands",
                "Switzerland",
                "Thailand",
                "United Kingdom",
                "United States of America"
            ]
        },
        "latitude_min": "-90",
        "longitude_min": "-180",
        "latitude_max": "90",
        "longitude_max": "180",
        "temporal_min": "2016-03-12T00:00:01.000Z",
        "temporal_max": "2019-07-30T00:00:01.000Z",
        "measurement_interval": "6 hours",
        "measurement_interval_description": "Data is recorded instanteneously.",
        "meaning_of_timestamp": "Begining",
        "meaning_of_spatial_descriptor": "Average"
    },
    {
        "id": "string2",
        "name": "string2",
        "description": "string2",
        "dataset": {
            "id": "string2",
            "name": "string2",
            "key": "string2",
            "category": {
                "id": "2",
                "name": "Satellite"
            },
            "level": 1,
            "crs": "string2",
            "license_information": "string2",
            "offering_status": "string2",
            "description_short": "string2"
        },
        "units": "string2",
        "datatype": "sh",
        "level": "23",
        "crs": "string2",
        "colorTable": {
            "id": "32451"
        },
        "name_alternate": "ESA Sentinel 2 Level-2A",
        "rating": "4.1",
        "description_short": "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.",
        "description_long": "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.",
        "description_links": [
            "https://sentinel.esa.int/web/sentinel/missions2",
            "https://sentinel.esa.int/documents/247904/685211/Sentinel-2_User_Handbook2",
            "https://sentinel.esa.int/web/sentinel/missions/sentinel-2/data-products2",
            "https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi2"
        ],
        "data_source_name": "European Space Agency Sentinel-2",
        "data_source_attribution": "'Copernicus Sentinel data [Year]' for Sentinel data; see https://lta.cr.usgs.gov/sites/default/files/Sentinel_Data_Terms_and_Conditions.pdf",
        "data_source_description": "'Level-2A is generated by the Payload Data Ground Segment using the Sen2Cor processor. Level-2A products are made available to users via the Copernicus Open Access Hub: https://scihub.copernicus.eu/dhus/#/home",
        "data_source_links": [
            "https://sentinel.esa.int/web/sentinel/sentinel-data-access2"
        ],
        "update_interval_max": "1 day",
        "update_interval_description": "Uploads are run daily. However, note the temporal resolution.",
        "lag_horizon": "5 days",
        "lag_horizon_description": "Data is available within 24 hours.",
        "temporal_resolution": "5 days",
        "temporal_resolution_description": "string2",
        "spatial_resolution_of_raw_data": "100m",
        "interpolation": "near",
        "interpolation_upload": "near",
        "dimensions_description": "The sole dimension is called \"horizon\" and refers to the forecast horizon in hours. (Only integer horizons are allowed.)",
        "permanence": "true",
        "permanence_description": "Data with timestamp into the future will be update, but remain constant past current timestamp (except for error corrrection).",
        "known_issues": "Updates are irregular.",
        "properties": {
            "Sector": [
                "Animals/livestock2",
                "Transportation/infrastructure2",
                "Vegetation/crops2",
                "Weather/climate2"
            ],
            "Application": [
                "Agriculture2"
            ],
            "Domain": [
                "Land surface2"
            ],
            "Type": [
                "Data product2"
            ],
            "Source": [
                "Satellite2",
                "Survey2"
            ]
        },
        "spatial_coverage": {
            "Country": [
                "Belgium2",
                "Bolivia2",
                "France2",
                "Germany2",
                "India2",
                "Indonesia2",
                "Luxembourg2",
                "Netherlands2",
                "Switzerland2",
                "Thailand2",
                "United Kingdom2",
                "United States of America2"
            ]
        },
        "latitude_min": "-180",
        "longitude_min": "-90",
        "latitude_max": "180",
        "longitude_max": "90",
        "temporal_min": "1970-03-12T00:00:01.000Z",
        "temporal_max": "1970-07-30T00:00:01.000Z",
        "measurement_interval": "6 hours",
        "measurement_interval_description": "Data is recorded instanteneously.",
        "meaning_of_timestamp": "Begining",
        "meaning_of_spatial_descriptor": "Average"
    }
]'''

data_layers_multi_name_dict = [
    {
        "name": "abc"
    },
    {
        "name": "abc"
    }
]

data_layers_obj_repr_dict = {
    "data_layers": [
        {
            "name": "abc"
        },
        {
            "name": "abc2"
        }
    ]
}

#
class DataLayersUnitTest(unittest.TestCase):
    
    #
    def setUp(self):
        self.logger = logger
        self.logger.info('setup')
    
    #
    def tearDown(self):
        self.logger.info('teardown')

    #    
    def test_data_layers_from_dict(self):
        
        self.logger.info('test_data_layers_from_dict')
        
        client = cl.Client()
        data_layers = catalog.DataLayers

        data_layers_from_dict = None
            
        got_exception = False

        try:
            data_layers_from_dict = data_layers.from_dict(data_layers_dict)
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)    
        self.assertEqual(data_layers_from_dict["string"].id, "string")
        self.assertEqual(data_layers_from_dict["string"].name, "string")
        self.assertEqual(data_layers_from_dict["string"].description, "string")
        self.assertEqual(data_layers_from_dict["string"].dataset.id, "string")
        self.assertEqual(data_layers_from_dict["string"].dataset.name, "string")
        self.assertEqual(data_layers_from_dict["string"].dataset.key, "string")
        self.assertEqual(data_layers_from_dict["string"].dataset.category.id, 1)
        self.assertEqual(data_layers_from_dict["string"].dataset.category.name, "Satellite")
        self.assertEqual(data_layers_from_dict["string"].dataset.level, 0)
        self.assertEqual(data_layers_from_dict["string"].dataset.crs, "string")
        self.assertEqual(data_layers_from_dict["string"].dataset.license_information, "string")
        self.assertEqual(data_layers_from_dict["string"].dataset.offering_status, "string")
        self.assertEqual(data_layers_from_dict["string"].dataset.description_short, "string")
        self.assertEqual(data_layers_from_dict["string"].units, "string")
        self.assertEqual(data_layers_from_dict["string"].datatype, "sh")
        self.assertEqual(data_layers_from_dict["string"].level, 22)
        self.assertEqual(data_layers_from_dict["string"].crs, "string")
        self.assertEqual(data_layers_from_dict["string"].color_table.id, "32451")
        self.assertEqual(data_layers_from_dict["string"].name_alternate, "ESA Sentinel 2 Level-2A")
        self.assertEqual(data_layers_from_dict["string"].rating, 4.0)
        self.assertEqual(data_layers_from_dict["string"].description_short, "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.")
        self.assertEqual(data_layers_from_dict["string"].description_long, "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.")
        self.assertEqual(data_layers_from_dict["string"].description_links[0], "https://sentinel.esa.int/web/sentinel/missions")
        self.assertEqual(data_layers_from_dict["string"].description_links[1], "https://sentinel.esa.int/documents/247904/685211/Sentinel-2_User_Handbook")
        self.assertEqual(data_layers_from_dict["string"].description_links[2], "https://sentinel.esa.int/web/sentinel/missions/sentinel-2/data-products")
        self.assertEqual(data_layers_from_dict["string"].description_links[3], "https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi")
        self.assertEqual(data_layers_from_dict["string"].data_source_name, "European Space Agency Sentinel-2")
        self.assertEqual(data_layers_from_dict["string"].data_source_attribution, "'Copernicus Sentinel data [Year]' for Sentinel data; see https://lta.cr.usgs.gov/sites/default/files/Sentinel_Data_Terms_and_Conditions.pdf")
        self.assertEqual(data_layers_from_dict["string"].data_source_description, "'Level-2A is generated by the Payload Data Ground Segment using the Sen2Cor processor. Level-2A products are made available to users via the Copernicus Open Access Hub: https://scihub.copernicus.eu/dhus/#/home")
        self.assertEqual(data_layers_from_dict["string"].data_source_links[0], "https://sentinel.esa.int/web/sentinel/sentinel-data-access")
        self.assertEqual(data_layers_from_dict["string"].update_interval_max, "1 day")
        self.assertEqual(data_layers_from_dict["string"].update_interval_description, "Uploads are run daily. However, note the temporal resolution.")
        self.assertEqual(data_layers_from_dict["string"].lag_horizon, "5 days")
        self.assertEqual(data_layers_from_dict["string"].lag_horizon_description, "Data is available within 24 hours.")
        self.assertEqual(data_layers_from_dict["string"].temporal_resolution, "5 days")
        self.assertEqual(data_layers_from_dict["string"].temporal_resolution_description, "string")
        self.assertEqual(data_layers_from_dict["string"].spatial_resolution_of_raw_data, "100m")
        self.assertEqual(data_layers_from_dict["string"].interpolation, "near")
        self.assertEqual(data_layers_from_dict["string"].dimensions_description, "The sole dimension is called \"horizon\" and refers to the forecast horizon in hours. (Only integer horizons are allowed.)")
        self.assertEqual(data_layers_from_dict["string"].permanence, True)
        self.assertEqual(data_layers_from_dict["string"].permanence_description, "Data with timestamp into the future will be update, but remain constant past current timestamp (except for error corrrection).")
        self.assertEqual(data_layers_from_dict["string"].known_issues, "Updates are irregular.")
        self.assertEqual(data_layers_from_dict["string"].properties.sector[0], "Animals/livestock")
        self.assertEqual(data_layers_from_dict["string"].properties.sector[1], "Transportation/infrastructure")
        self.assertEqual(data_layers_from_dict["string"].properties.sector[2], "Vegetation/crops")
        self.assertEqual(data_layers_from_dict["string"].properties.sector[3], "Weather/climate")
        self.assertEqual(data_layers_from_dict["string"].properties.application[0], "Agriculture")
        self.assertEqual(data_layers_from_dict["string"].properties.domain[0], "Land surface")
        self.assertEqual(data_layers_from_dict["string"].properties.type[0], "Data product")
        self.assertEqual(data_layers_from_dict["string"].properties.source[0], "Satellite")
        self.assertEqual(data_layers_from_dict["string"].properties.source[1], "Survey")
        self.assertEqual(data_layers_from_dict["string"].spatial_coverage.country[0], "Belgium")
        self.assertEqual(data_layers_from_dict["string"].spatial_coverage.country[1], "Bolivia")
        self.assertEqual(data_layers_from_dict["string"].spatial_coverage.country[2], "France")
        self.assertEqual(data_layers_from_dict["string"].spatial_coverage.country[3], "Germany")
        self.assertEqual(data_layers_from_dict["string"].spatial_coverage.country[4], "India")
        self.assertEqual(data_layers_from_dict["string"].spatial_coverage.country[5], "Indonesia")
        self.assertEqual(data_layers_from_dict["string"].spatial_coverage.country[6], "Luxembourg")
        self.assertEqual(data_layers_from_dict["string"].spatial_coverage.country[7], "Netherlands")
        self.assertEqual(data_layers_from_dict["string"].spatial_coverage.country[8], "Switzerland")
        self.assertEqual(data_layers_from_dict["string"].spatial_coverage.country[9], "Thailand")
        self.assertEqual(data_layers_from_dict["string"].spatial_coverage.country[10], "United Kingdom")
        self.assertEqual(data_layers_from_dict["string"].spatial_coverage.country[11], "United States of America")
        self.assertEqual(data_layers_from_dict["string"].latitude_min, -90)
        self.assertEqual(data_layers_from_dict["string"].longitude_min, -180)
        self.assertEqual(data_layers_from_dict["string"].latitude_max, 90)
        self.assertEqual(data_layers_from_dict["string"].longitude_max, 180)
        self.assertEqual(data_layers_from_dict["string"].temporal_min, "2016-03-12T00:00:01.000Z")
        self.assertEqual(data_layers_from_dict["string"].temporal_max, "2019-07-30T00:00:01.000Z")
        self.assertEqual(data_layers_from_dict["string"].measurement_interval, "6 hours")
        self.assertEqual(data_layers_from_dict["string"].measurement_interval_description, "Data is recorded instanteneously.")
        self.assertEqual(data_layers_from_dict["string"].meaning_of_timestamp, "Begining")
        self.assertEqual(data_layers_from_dict["string"].meaning_of_spatial_descriptor, "Average")
        
        self.assertEqual(data_layers_from_dict["string2"].id, "string2")
        self.assertEqual(data_layers_from_dict["string2"].name, "string2")
        self.assertEqual(data_layers_from_dict["string2"].description, "string2")
        self.assertEqual(data_layers_from_dict["string2"].dataset.id, "string2")
        self.assertEqual(data_layers_from_dict["string2"].dataset.name, "string2")
        self.assertEqual(data_layers_from_dict["string2"].dataset.key, "string2")
        self.assertEqual(data_layers_from_dict["string2"].dataset.category.id, 2)
        self.assertEqual(data_layers_from_dict["string2"].dataset.category.name, "Satellite")
        self.assertEqual(data_layers_from_dict["string2"].dataset.level, 1)
        self.assertEqual(data_layers_from_dict["string2"].dataset.crs, "string2")
        self.assertEqual(data_layers_from_dict["string2"].dataset.license_information, "string2")
        self.assertEqual(data_layers_from_dict["string2"].dataset.offering_status, "string2")
        self.assertEqual(data_layers_from_dict["string2"].dataset.description_short, "string2")
        self.assertEqual(data_layers_from_dict["string2"].units, "string2")
        self.assertEqual(data_layers_from_dict["string2"].datatype, "sh")
        self.assertEqual(data_layers_from_dict["string2"].level, 23)
        self.assertEqual(data_layers_from_dict["string2"].crs, "string2")
        self.assertEqual(data_layers_from_dict["string2"].color_table.id, "32451")
        self.assertEqual(data_layers_from_dict["string2"].name_alternate, "ESA Sentinel 2 Level-2A")
        self.assertEqual(data_layers_from_dict["string2"].rating, 4.1)
        self.assertEqual(data_layers_from_dict["string2"].description_short, "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.")
        self.assertEqual(data_layers_from_dict["string2"].description_long, "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.")
        self.assertEqual(data_layers_from_dict["string2"].description_links[0], "https://sentinel.esa.int/web/sentinel/missions2")
        self.assertEqual(data_layers_from_dict["string2"].description_links[1], "https://sentinel.esa.int/documents/247904/685211/Sentinel-2_User_Handbook2")
        self.assertEqual(data_layers_from_dict["string2"].description_links[2], "https://sentinel.esa.int/web/sentinel/missions/sentinel-2/data-products2")
        self.assertEqual(data_layers_from_dict["string2"].description_links[3], "https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi2")
        self.assertEqual(data_layers_from_dict["string2"].data_source_name, "European Space Agency Sentinel-2")
        self.assertEqual(data_layers_from_dict["string2"].data_source_attribution, "'Copernicus Sentinel data [Year]' for Sentinel data; see https://lta.cr.usgs.gov/sites/default/files/Sentinel_Data_Terms_and_Conditions.pdf")
        self.assertEqual(data_layers_from_dict["string2"].data_source_description, "'Level-2A is generated by the Payload Data Ground Segment using the Sen2Cor processor. Level-2A products are made available to users via the Copernicus Open Access Hub: https://scihub.copernicus.eu/dhus/#/home")
        self.assertEqual(data_layers_from_dict["string2"].data_source_links[0], "https://sentinel.esa.int/web/sentinel/sentinel-data-access2")
        self.assertEqual(data_layers_from_dict["string2"].update_interval_max, "1 day")
        self.assertEqual(data_layers_from_dict["string2"].update_interval_description, "Uploads are run daily. However, note the temporal resolution.")
        self.assertEqual(data_layers_from_dict["string2"].lag_horizon, "5 days")
        self.assertEqual(data_layers_from_dict["string2"].lag_horizon_description, "Data is available within 24 hours.")
        self.assertEqual(data_layers_from_dict["string2"].temporal_resolution, "5 days")
        self.assertEqual(data_layers_from_dict["string2"].temporal_resolution_description, "string2")
        self.assertEqual(data_layers_from_dict["string2"].spatial_resolution_of_raw_data, "100m")
        self.assertEqual(data_layers_from_dict["string2"].interpolation, "near")
        self.assertEqual(data_layers_from_dict["string2"].dimensions_description, "The sole dimension is called \"horizon\" and refers to the forecast horizon in hours. (Only integer horizons are allowed.)")
        self.assertEqual(data_layers_from_dict["string2"].permanence, True)
        self.assertEqual(data_layers_from_dict["string2"].permanence_description, "Data with timestamp into the future will be update, but remain constant past current timestamp (except for error corrrection).")
        self.assertEqual(data_layers_from_dict["string2"].known_issues, "Updates are irregular.")
        self.assertEqual(data_layers_from_dict["string2"].properties.sector[0], "Animals/livestock2")
        self.assertEqual(data_layers_from_dict["string2"].properties.sector[1], "Transportation/infrastructure2")
        self.assertEqual(data_layers_from_dict["string2"].properties.sector[2], "Vegetation/crops2")
        self.assertEqual(data_layers_from_dict["string2"].properties.sector[3], "Weather/climate2")
        self.assertEqual(data_layers_from_dict["string2"].properties.application[0], "Agriculture2")
        self.assertEqual(data_layers_from_dict["string2"].properties.domain[0], "Land surface2")
        self.assertEqual(data_layers_from_dict["string2"].properties.type[0], "Data product2")
        self.assertEqual(data_layers_from_dict["string2"].properties.source[0], "Satellite2")
        self.assertEqual(data_layers_from_dict["string2"].properties.source[1], "Survey2")
        self.assertEqual(data_layers_from_dict["string2"].spatial_coverage.country[0], "Belgium2")
        self.assertEqual(data_layers_from_dict["string2"].spatial_coverage.country[1], "Bolivia2")
        self.assertEqual(data_layers_from_dict["string2"].spatial_coverage.country[2], "France2")
        self.assertEqual(data_layers_from_dict["string2"].spatial_coverage.country[3], "Germany2")
        self.assertEqual(data_layers_from_dict["string2"].spatial_coverage.country[4], "India2")
        self.assertEqual(data_layers_from_dict["string2"].spatial_coverage.country[5], "Indonesia2")
        self.assertEqual(data_layers_from_dict["string2"].spatial_coverage.country[6], "Luxembourg2")
        self.assertEqual(data_layers_from_dict["string2"].spatial_coverage.country[7], "Netherlands2")
        self.assertEqual(data_layers_from_dict["string2"].spatial_coverage.country[8], "Switzerland2")
        self.assertEqual(data_layers_from_dict["string2"].spatial_coverage.country[9], "Thailand2")
        self.assertEqual(data_layers_from_dict["string2"].spatial_coverage.country[10], "United Kingdom2")
        self.assertEqual(data_layers_from_dict["string2"].spatial_coverage.country[11], "United States of America2")
        self.assertEqual(data_layers_from_dict["string2"].latitude_min, -180)
        self.assertEqual(data_layers_from_dict["string2"].longitude_min, -90)
        self.assertEqual(data_layers_from_dict["string2"].latitude_max, 180)
        self.assertEqual(data_layers_from_dict["string2"].longitude_max, 90)
        self.assertEqual(data_layers_from_dict["string2"].temporal_min, "1970-03-12T00:00:01.000Z")
        self.assertEqual(data_layers_from_dict["string2"].temporal_max, "1970-07-30T00:00:01.000Z")
        self.assertEqual(data_layers_from_dict["string2"].measurement_interval, "6 hours")
        self.assertEqual(data_layers_from_dict["string2"].measurement_interval_description, "Data is recorded instanteneously.")
        self.assertEqual(data_layers_from_dict["string2"].meaning_of_timestamp, "Begining")
        self.assertEqual(data_layers_from_dict["string2"].meaning_of_spatial_descriptor, "Average")
        
        self.logger.info('test_data_layers_from_dict: no overload')
        
        self.assertEqual(data_layers_from_dict[0].name, "string")
        self.assertEqual(data_layers_from_dict[1].name, "string2")
        
        self.logger.info('test_data_layers_from_dict: set overload')
        
        data_layers_from_dict["string"].id = "newstring"
        data_layers_from_dict["string2"].id = "newstring2"
        data_layers_from_dict["string"].name = "newstring"
        data_layers_from_dict["string2"].name = "newstring2"
        
        self.assertEqual(data_layers_from_dict["newstring"].name, "newstring")
        self.assertEqual(data_layers_from_dict["newstring2"].name, "newstring2")
        self.assertEqual(data_layers_from_dict["newstring"].id, "newstring")
        self.assertEqual(data_layers_from_dict["newstring2"].id, "newstring2")
        
        self.logger.info('test_data_layers_from_dict: set no overload')
        
        data_layers_from_dict[0].id = "newnewstring"
        data_layers_from_dict[1].id = "newnewstring2"
        data_layers_from_dict[0].name = "newnewstring"
        data_layers_from_dict[1].name = "newnewstring2"
        
        self.assertEqual(data_layers_from_dict["newnewstring"].name, "newnewstring")
        self.assertEqual(data_layers_from_dict["newnewstring2"].name, "newnewstring2")
        self.assertEqual(data_layers_from_dict["newnewstring"].id, "newnewstring")
        self.assertEqual(data_layers_from_dict["newnewstring2"].id, "newnewstring2")
        self.assertEqual(data_layers_from_dict[0].name, "newnewstring")
        self.assertEqual(data_layers_from_dict[1].name, "newnewstring2")
        self.assertEqual(data_layers_from_dict[0].id, "newnewstring")
        self.assertEqual(data_layers_from_dict[1].id, "newnewstring2")
        
        data_layers_multi_name = catalog.DataLayers

        data_layers_multi_name_from_dict = None
            
        got_exception2 = False

        try:
            data_layers_multi_name_from_dict = data_layers_multi_name.from_dict(data_layers_multi_name_dict)
        except Exception as ex:
            got_exception2 = True

        self.assertFalse(got_exception2)
        
        got_exception3 = False
        
        try:
            data_layers_multi_name_from_dict["ab"].name = "abcd"
        except Exception as ex:
            got_exception3 = True
            
        self.assertTrue(got_exception3)
        
        got_exception4 = False
        
        try:
            data_layers_multi_name_from_dict["abc"].name = "abcd"
        except Exception as ex:
            got_exception4 = True
            
        self.assertTrue(got_exception4)
        
        got_exception5 = False
        
        try:
            d = {}
            data_layers_multi_name_from_dict[d].name = "abcd"
        except Exception as ex:
            got_exception5 = True
            
        self.assertTrue(got_exception5)
        
        got_exception6 = False
        
        try:
            data_layers_multi_name_from_dict[0].name = "abcd"
        except Exception as ex:
            got_exception6 = True
            
        self.assertFalse(got_exception6)
        
        self.assertEqual(data_layers_multi_name_from_dict[0].name, "abcd")
        self.assertEqual(data_layers_multi_name_from_dict[1].name, "abc")
        
        got_exception7 = False
        
        try:
            data_layers_multi_name_from_dict["abc"].name = "efg"
        except Exception as ex:
            got_exception7 = True
            
        self.assertFalse(got_exception7)
        
        self.assertEqual(data_layers_multi_name_from_dict[0].name, "abcd")
        self.assertEqual(data_layers_multi_name_from_dict[1].name, "efg")
        
        data_layers_obj_repr = catalog.DataLayers

        data_layers_obj_repr_from_dict = None
        
        got_exception8 = False

        try:
            data_layers_obj_repr_from_dict = data_layers_obj_repr.from_dict(data_layers_obj_repr_dict)
        except Exception as ex:
            got_exception8 = True

        self.assertFalse(got_exception8)
        
        self.assertEqual(data_layers_obj_repr_from_dict[0].name, "abc")
        self.assertEqual(data_layers_obj_repr_from_dict[1].name, "abc2")
        
    def test_data_layers_to_dict(self):
        
        self.logger.info('test_data_layers_to_dict')
        
        client = cl.Client()
        data_layers = catalog.DataLayers

        data_layers_from_dict = None
        data_layers_to_dict   = None
                
        got_exception = False

        try:
            data_layers_from_dict = data_layers.from_dict(data_layers_dict)
            data_layers_to_dict = data_layers_from_dict.to_dict()
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)        
        
        self.assertEqual(data_layers_to_dict["data_layers"][0]["id"], "string")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["name"], "string")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["description"], "string")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["dataset"]["id"], "string")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["dataset"]["name"], "string")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["dataset"]["key"], "string")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["dataset"]["name"], "string")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["dataset"]["category"]["id"], 1)
        self.assertEqual(data_layers_to_dict["data_layers"][0]["dataset"]["category"]["name"], "Satellite")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["dataset"]["level"], 0)
        self.assertEqual(data_layers_to_dict["data_layers"][0]["dataset"]["crs"], "string")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["dataset"]["license_information"], "string")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["dataset"]["offering_status"], "string")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["dataset"]["description_short"], "string")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["units"], "string")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["datatype"], "sh")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["level"], 22)
        self.assertEqual(data_layers_to_dict["data_layers"][0]["crs"], "string")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["color_table"]["id"], "32451")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["name_alternate"], "ESA Sentinel 2 Level-2A")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["rating"], 4.0)
        self.assertEqual(data_layers_to_dict["data_layers"][0]["description_short"], "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["description_long"], "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["description_links"][0], "https://sentinel.esa.int/web/sentinel/missions")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["description_links"][1], "https://sentinel.esa.int/documents/247904/685211/Sentinel-2_User_Handbook")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["description_links"][2], "https://sentinel.esa.int/web/sentinel/missions/sentinel-2/data-products")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["description_links"][3], "https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["data_source_name"], "European Space Agency Sentinel-2")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["data_source_attribution"], "'Copernicus Sentinel data [Year]' for Sentinel data; see https://lta.cr.usgs.gov/sites/default/files/Sentinel_Data_Terms_and_Conditions.pdf")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["data_source_description"], "'Level-2A is generated by the Payload Data Ground Segment using the Sen2Cor processor. Level-2A products are made available to users via the Copernicus Open Access Hub: https://scihub.copernicus.eu/dhus/#/home")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["data_source_links"][0], "https://sentinel.esa.int/web/sentinel/sentinel-data-access")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["update_interval_max"], "1 day")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["update_interval_description"], "Uploads are run daily. However, note the temporal resolution.")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["lag_horizon"], "5 days")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["lag_horizon_description"], "Data is available within 24 hours.")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["temporal_resolution"], "5 days")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["temporal_resolution_description"], "string")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["spatial_resolution_of_raw_data"], "100m")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["interpolation"], "near")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["dimensions_description"], "The sole dimension is called \"horizon\" and refers to the forecast horizon in hours. (Only integer horizons are allowed.)")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["permanence"], True)
        self.assertEqual(data_layers_to_dict["data_layers"][0]["permanence_description"], "Data with timestamp into the future will be update, but remain constant past current timestamp (except for error corrrection).")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["known_issues"], "Updates are irregular.")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["properties"]["sector"][0], "Animals/livestock")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["properties"]["sector"][1], "Transportation/infrastructure")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["properties"]["sector"][2], "Vegetation/crops")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["properties"]["sector"][3], "Weather/climate")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["properties"]["application"][0], "Agriculture")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["properties"]["domain"][0], "Land surface")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["properties"]["type"][0], "Data product")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["properties"]["source"][0], "Satellite")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["properties"]["source"][1], "Survey")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["spatial_coverage"]["country"][0], "Belgium")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["spatial_coverage"]["country"][1], "Bolivia")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["spatial_coverage"]["country"][2], "France")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["spatial_coverage"]["country"][3], "Germany")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["spatial_coverage"]["country"][4], "India")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["spatial_coverage"]["country"][5], "Indonesia")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["spatial_coverage"]["country"][6], "Luxembourg")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["spatial_coverage"]["country"][7], "Netherlands")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["spatial_coverage"]["country"][8], "Switzerland")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["spatial_coverage"]["country"][9], "Thailand")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["spatial_coverage"]["country"][10], "United Kingdom")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["spatial_coverage"]["country"][11], "United States of America")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["latitude_min"], -90)
        self.assertEqual(data_layers_to_dict["data_layers"][0]["longitude_min"], -180)
        self.assertEqual(data_layers_to_dict["data_layers"][0]["latitude_max"], 90)
        self.assertEqual(data_layers_to_dict["data_layers"][0]["longitude_max"], 180)
        self.assertEqual(data_layers_to_dict["data_layers"][0]["temporal_min"], "2016-03-12T00:00:01.000Z")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["temporal_max"], "2019-07-30T00:00:01.000Z")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["measurement_interval"], "6 hours")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["measurement_interval_description"], "Data is recorded instanteneously.")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["meaning_of_timestamp"], "Begining")
        self.assertEqual(data_layers_to_dict["data_layers"][0]["meaning_of_spatial_descriptor"], "Average")
        
        self.assertEqual(data_layers_to_dict["data_layers"][1]["id"], "string2")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["name"], "string2")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["description"], "string2")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["dataset"]["id"], "string2")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["dataset"]["name"], "string2")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["dataset"]["key"], "string2")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["dataset"]["name"], "string2")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["dataset"]["category"]["id"], 2)
        self.assertEqual(data_layers_to_dict["data_layers"][1]["dataset"]["category"]["name"], "Satellite")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["dataset"]["level"], 1)
        self.assertEqual(data_layers_to_dict["data_layers"][1]["dataset"]["crs"], "string2")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["dataset"]["license_information"], "string2")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["dataset"]["offering_status"], "string2")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["dataset"]["description_short"], "string2")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["units"], "string2")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["datatype"], "sh")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["level"], 23)
        self.assertEqual(data_layers_to_dict["data_layers"][1]["crs"], "string2")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["color_table"]["id"], "32451")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["name_alternate"], "ESA Sentinel 2 Level-2A")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["rating"], 4.1)
        self.assertEqual(data_layers_to_dict["data_layers"][1]["description_short"], "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["description_long"], "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["description_links"][0], "https://sentinel.esa.int/web/sentinel/missions2")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["description_links"][1], "https://sentinel.esa.int/documents/247904/685211/Sentinel-2_User_Handbook2")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["description_links"][2], "https://sentinel.esa.int/web/sentinel/missions/sentinel-2/data-products2")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["description_links"][3], "https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi2")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["data_source_name"], "European Space Agency Sentinel-2")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["data_source_attribution"], "'Copernicus Sentinel data [Year]' for Sentinel data; see https://lta.cr.usgs.gov/sites/default/files/Sentinel_Data_Terms_and_Conditions.pdf")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["data_source_description"], "'Level-2A is generated by the Payload Data Ground Segment using the Sen2Cor processor. Level-2A products are made available to users via the Copernicus Open Access Hub: https://scihub.copernicus.eu/dhus/#/home")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["data_source_links"][0], "https://sentinel.esa.int/web/sentinel/sentinel-data-access2")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["update_interval_max"], "1 day")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["update_interval_description"], "Uploads are run daily. However, note the temporal resolution.")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["lag_horizon"], "5 days")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["lag_horizon_description"], "Data is available within 24 hours.")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["temporal_resolution"], "5 days")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["temporal_resolution_description"], "string2")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["spatial_resolution_of_raw_data"], "100m")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["interpolation"], "near")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["dimensions_description"], "The sole dimension is called \"horizon\" and refers to the forecast horizon in hours. (Only integer horizons are allowed.)")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["permanence"], True)
        self.assertEqual(data_layers_to_dict["data_layers"][1]["permanence_description"], "Data with timestamp into the future will be update, but remain constant past current timestamp (except for error corrrection).")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["known_issues"], "Updates are irregular.")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["properties"]["sector"][0], "Animals/livestock2")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["properties"]["sector"][1], "Transportation/infrastructure2")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["properties"]["sector"][2], "Vegetation/crops2")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["properties"]["sector"][3], "Weather/climate2")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["properties"]["application"][0], "Agriculture2")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["properties"]["domain"][0], "Land surface2")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["properties"]["type"][0], "Data product2")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["properties"]["source"][0], "Satellite2")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["properties"]["source"][1], "Survey2")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["spatial_coverage"]["country"][0], "Belgium2")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["spatial_coverage"]["country"][1], "Bolivia2")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["spatial_coverage"]["country"][2], "France2")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["spatial_coverage"]["country"][3], "Germany2")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["spatial_coverage"]["country"][4], "India2")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["spatial_coverage"]["country"][5], "Indonesia2")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["spatial_coverage"]["country"][6], "Luxembourg2")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["spatial_coverage"]["country"][7], "Netherlands2")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["spatial_coverage"]["country"][8], "Switzerland2")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["spatial_coverage"]["country"][9], "Thailand2")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["spatial_coverage"]["country"][10], "United Kingdom2")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["spatial_coverage"]["country"][11], "United States of America2")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["latitude_min"], -180)
        self.assertEqual(data_layers_to_dict["data_layers"][1]["longitude_min"], -90)
        self.assertEqual(data_layers_to_dict["data_layers"][1]["latitude_max"], 180)
        self.assertEqual(data_layers_to_dict["data_layers"][1]["longitude_max"], 90)
        self.assertEqual(data_layers_to_dict["data_layers"][1]["temporal_min"], "1970-03-12T00:00:01.000Z")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["temporal_max"], "1970-07-30T00:00:01.000Z")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["measurement_interval"], "6 hours")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["measurement_interval_description"], "Data is recorded instanteneously.")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["meaning_of_timestamp"], "Begining")
        self.assertEqual(data_layers_to_dict["data_layers"][1]["meaning_of_spatial_descriptor"], "Average")
    
    def test_data_layers_to_dict_data_layers_post(self):
        
        self.logger.info('test_data_layers_to_dict_data_layers_post')
        
        client = cl.Client()
        data_layers = catalog.DataLayers

        data_layers_from_dict = None
        data_layers_to_dict   = None
                
        got_exception = False

        try:
            data_layers_from_dict2 = data_layers.from_dict(data_layers_dict)
            data_layers_from_dict2.group = "P12345"
            data_layers_from_dict2.layer_type = "Raster"
            data_layers_to_dict_data_layers_post = data_layers_from_dict2.to_dict_data_layers_post()
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception) 
        
        self.assertEqual(data_layers_to_dict_data_layers_post["group"], "P12345")
        self.assertEqual(data_layers_to_dict_data_layers_post["layerType"], "Raster")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["name"], "string")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["description"], "string")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["units"], "string")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["datatype"], "sh")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["level"], 22)
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["crs"], "string")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["colorTable"]["id"], "32451")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["name_alternate"], "ESA Sentinel 2 Level-2A")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["rating"], 4.0)
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["description_short"], "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["description_long"], "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["description_links"][0], "https://sentinel.esa.int/web/sentinel/missions")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["description_links"][1], "https://sentinel.esa.int/documents/247904/685211/Sentinel-2_User_Handbook")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["description_links"][2], "https://sentinel.esa.int/web/sentinel/missions/sentinel-2/data-products")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["description_links"][3], "https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["data_source_name"], "European Space Agency Sentinel-2")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["data_source_attribution"], "'Copernicus Sentinel data [Year]' for Sentinel data; see https://lta.cr.usgs.gov/sites/default/files/Sentinel_Data_Terms_and_Conditions.pdf")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["data_source_description"], "'Level-2A is generated by the Payload Data Ground Segment using the Sen2Cor processor. Level-2A products are made available to users via the Copernicus Open Access Hub: https://scihub.copernicus.eu/dhus/#/home")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["data_source_links"][0], "https://sentinel.esa.int/web/sentinel/sentinel-data-access")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["update_interval_max"], "1 day")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["update_interval_description"], "Uploads are run daily. However, note the temporal resolution.")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["lag_horizon"], "5 days")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["lag_horizon_description"], "Data is available within 24 hours.")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["temporal_resolution"], "5 days")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["temporal_resolution_description"], "string")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["spatial_resolution_of_raw_data"], "100m")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["interpolation"], "near")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["interpolation_upload"], "near")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["dimensions_description"], "The sole dimension is called \"horizon\" and refers to the forecast horizon in hours. (Only integer horizons are allowed.)")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["permanence"], True)
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["permanence_description"], "Data with timestamp into the future will be update, but remain constant past current timestamp (except for error corrrection).")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["known_issues"], "Updates are irregular.")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["properties"]["sector"][0], "Animals/livestock")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["properties"]["sector"][1], "Transportation/infrastructure")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["properties"]["sector"][2], "Vegetation/crops")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["properties"]["sector"][3], "Weather/climate")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["properties"]["application"][0], "Agriculture")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["properties"]["domain"][0], "Land surface")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["properties"]["type"][0], "Data product")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["properties"]["source"][0], "Satellite")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["properties"]["source"][1], "Survey")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["spatial_coverage"]["country"][0], "Belgium")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["spatial_coverage"]["country"][1], "Bolivia")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["spatial_coverage"]["country"][2], "France")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["spatial_coverage"]["country"][3], "Germany")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["spatial_coverage"]["country"][4], "India")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["spatial_coverage"]["country"][5], "Indonesia")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["spatial_coverage"]["country"][6], "Luxembourg")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["spatial_coverage"]["country"][7], "Netherlands")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["spatial_coverage"]["country"][8], "Switzerland")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["spatial_coverage"]["country"][9], "Thailand")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["spatial_coverage"]["country"][10], "United Kingdom")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["spatial_coverage"]["country"][11], "United States of America")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["latitude_min"], -90)
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["longitude_min"], -180)
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["latitude_max"], 90)
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["longitude_max"], 180)
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["temporal_min"], "2016-03-12T00:00:01.000Z")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["temporal_max"], "2019-07-30T00:00:01.000Z")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["measurement_interval"], "6 hours")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["measurement_interval_description"], "Data is recorded instanteneously.")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["meaning_of_timestamp"], "Begining")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][0]["meaning_of_spatial_descriptor"], "Average")
        
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["name"], "string2")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["description"], "string2")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["units"], "string2")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["datatype"], "sh")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["level"], 23)
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["crs"], "string2")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["colorTable"]["id"], "32451")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["name_alternate"], "ESA Sentinel 2 Level-2A")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["rating"], 4.1)
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["description_short"], "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["description_long"], "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["description_links"][0], "https://sentinel.esa.int/web/sentinel/missions2")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["description_links"][1], "https://sentinel.esa.int/documents/247904/685211/Sentinel-2_User_Handbook2")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["description_links"][2], "https://sentinel.esa.int/web/sentinel/missions/sentinel-2/data-products2")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["description_links"][3], "https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi2")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["data_source_name"], "European Space Agency Sentinel-2")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["data_source_attribution"], "'Copernicus Sentinel data [Year]' for Sentinel data; see https://lta.cr.usgs.gov/sites/default/files/Sentinel_Data_Terms_and_Conditions.pdf")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["data_source_description"], "'Level-2A is generated by the Payload Data Ground Segment using the Sen2Cor processor. Level-2A products are made available to users via the Copernicus Open Access Hub: https://scihub.copernicus.eu/dhus/#/home")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["data_source_links"][0], "https://sentinel.esa.int/web/sentinel/sentinel-data-access2")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["update_interval_max"], "1 day")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["update_interval_description"], "Uploads are run daily. However, note the temporal resolution.")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["lag_horizon"], "5 days")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["lag_horizon_description"], "Data is available within 24 hours.")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["temporal_resolution"], "5 days")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["temporal_resolution_description"], "string2")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["spatial_resolution_of_raw_data"], "100m")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["interpolation"], "near")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["interpolation_upload"], "near")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["dimensions_description"], "The sole dimension is called \"horizon\" and refers to the forecast horizon in hours. (Only integer horizons are allowed.)")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["permanence"], True)
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["permanence_description"], "Data with timestamp into the future will be update, but remain constant past current timestamp (except for error corrrection).")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["known_issues"], "Updates are irregular.")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["properties"]["sector"][0], "Animals/livestock2")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["properties"]["sector"][1], "Transportation/infrastructure2")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["properties"]["sector"][2], "Vegetation/crops2")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["properties"]["sector"][3], "Weather/climate2")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["properties"]["application"][0], "Agriculture2")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["properties"]["domain"][0], "Land surface2")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["properties"]["type"][0], "Data product2")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["properties"]["source"][0], "Satellite2")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["properties"]["source"][1], "Survey2")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["spatial_coverage"]["country"][0], "Belgium2")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["spatial_coverage"]["country"][1], "Bolivia2")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["spatial_coverage"]["country"][2], "France2")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["spatial_coverage"]["country"][3], "Germany2")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["spatial_coverage"]["country"][4], "India2")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["spatial_coverage"]["country"][5], "Indonesia2")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["spatial_coverage"]["country"][6], "Luxembourg2")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["spatial_coverage"]["country"][7], "Netherlands2")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["spatial_coverage"]["country"][8], "Switzerland2")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["spatial_coverage"]["country"][9], "Thailand2")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["spatial_coverage"]["country"][10], "United Kingdom2")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["spatial_coverage"]["country"][11], "United States of America2")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["latitude_min"], -180)
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["longitude_min"], -90)
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["latitude_max"], 180)
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["longitude_max"], 90)
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["temporal_min"], "1970-03-12T00:00:01.000Z")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["temporal_max"], "1970-07-30T00:00:01.000Z")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["measurement_interval"], "6 hours")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["measurement_interval_description"], "Data is recorded instanteneously.")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["meaning_of_timestamp"], "Begining")
        self.assertEqual(data_layers_to_dict_data_layers_post["layers"][1]["meaning_of_spatial_descriptor"], "Average")
        
    #
    def test_data_layers_from_json(self):
        
        self.logger.info('test_data_layers_from_json')
        
        client = cl.Client()
        got_exception = False

        try:
            data_layers_from_json = catalog.data_layers_from_json(data_layers_str)
        except Exception as ex:
            self.logger.info(ex)
            got_exception = True

        self.assertFalse(got_exception)
        
        self.assertEqual(data_layers_from_json["string"].id, "string")
        self.assertEqual(data_layers_from_json["string"].name, "string")
        self.assertEqual(data_layers_from_json["string"].description, "string")
        self.assertEqual(data_layers_from_json["string"].dataset.id, "string")
        self.assertEqual(data_layers_from_json["string"].dataset.name, "string")
        self.assertEqual(data_layers_from_json["string"].dataset.key, "string")
        self.assertEqual(data_layers_from_json["string"].dataset.category.id, 1)
        self.assertEqual(data_layers_from_json["string"].dataset.category.name, "Satellite")
        self.assertEqual(data_layers_from_json["string"].dataset.level, 0)
        self.assertEqual(data_layers_from_json["string"].dataset.crs, "string")
        self.assertEqual(data_layers_from_json["string"].dataset.license_information, "string")
        self.assertEqual(data_layers_from_json["string"].dataset.offering_status, "string")
        self.assertEqual(data_layers_from_json["string"].dataset.description_short, "string")
        self.assertEqual(data_layers_from_json["string"].units, "string")
        self.assertEqual(data_layers_from_json["string"].datatype, "sh")
        self.assertEqual(data_layers_from_json["string"].level, 22)
        self.assertEqual(data_layers_from_json["string"].crs, "string")
        self.assertEqual(data_layers_from_json["string"].color_table.id, "32451")
        self.assertEqual(data_layers_from_json["string"].name_alternate, "ESA Sentinel 2 Level-2A")
        self.assertEqual(data_layers_from_json["string"].rating, 4.0)
        self.assertEqual(data_layers_from_json["string"].description_short, "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.")
        self.assertEqual(data_layers_from_json["string"].description_long, "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.")
        self.assertEqual(data_layers_from_json["string"].description_links[0], "https://sentinel.esa.int/web/sentinel/missions")
        self.assertEqual(data_layers_from_json["string"].description_links[1], "https://sentinel.esa.int/documents/247904/685211/Sentinel-2_User_Handbook")
        self.assertEqual(data_layers_from_json["string"].description_links[2], "https://sentinel.esa.int/web/sentinel/missions/sentinel-2/data-products")
        self.assertEqual(data_layers_from_json["string"].description_links[3], "https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi")
        self.assertEqual(data_layers_from_json["string"].data_source_name, "European Space Agency Sentinel-2")
        self.assertEqual(data_layers_from_json["string"].data_source_attribution, "'Copernicus Sentinel data [Year]' for Sentinel data; see https://lta.cr.usgs.gov/sites/default/files/Sentinel_Data_Terms_and_Conditions.pdf")
        self.assertEqual(data_layers_from_json["string"].data_source_description, "'Level-2A is generated by the Payload Data Ground Segment using the Sen2Cor processor. Level-2A products are made available to users via the Copernicus Open Access Hub: https://scihub.copernicus.eu/dhus/#/home")
        self.assertEqual(data_layers_from_json["string"].data_source_links[0], "https://sentinel.esa.int/web/sentinel/sentinel-data-access")
        self.assertEqual(data_layers_from_json["string"].update_interval_max, "1 day")
        self.assertEqual(data_layers_from_json["string"].update_interval_description, "Uploads are run daily. However, note the temporal resolution.")
        self.assertEqual(data_layers_from_json["string"].lag_horizon, "5 days")
        self.assertEqual(data_layers_from_json["string"].lag_horizon_description, "Data is available within 24 hours.")
        self.assertEqual(data_layers_from_json["string"].temporal_resolution, "5 days")
        self.assertEqual(data_layers_from_json["string"].temporal_resolution_description, "string")
        self.assertEqual(data_layers_from_json["string"].spatial_resolution_of_raw_data, "100m")
        self.assertEqual(data_layers_from_json["string"].interpolation, "near")
        self.assertEqual(data_layers_from_json["string"].dimensions_description, "The sole dimension is called \"horizon\" and refers to the forecast horizon in hours. (Only integer horizons are allowed.)")
        self.assertEqual(data_layers_from_json["string"].permanence, True)
        self.assertEqual(data_layers_from_json["string"].permanence_description, "Data with timestamp into the future will be update, but remain constant past current timestamp (except for error corrrection).")
        self.assertEqual(data_layers_from_json["string"].known_issues, "Updates are irregular.")
        self.assertEqual(data_layers_from_json["string"].properties.sector[0], "Animals/livestock")
        self.assertEqual(data_layers_from_json["string"].properties.sector[1], "Transportation/infrastructure")
        self.assertEqual(data_layers_from_json["string"].properties.sector[2], "Vegetation/crops")
        self.assertEqual(data_layers_from_json["string"].properties.sector[3], "Weather/climate")
        self.assertEqual(data_layers_from_json["string"].properties.application[0], "Agriculture")
        self.assertEqual(data_layers_from_json["string"].properties.domain[0], "Land surface")
        self.assertEqual(data_layers_from_json["string"].properties.type[0], "Data product")
        self.assertEqual(data_layers_from_json["string"].properties.source[0], "Satellite")
        self.assertEqual(data_layers_from_json["string"].properties.source[1], "Survey")
        self.assertEqual(data_layers_from_json["string"].spatial_coverage.country[0], "Belgium")
        self.assertEqual(data_layers_from_json["string"].spatial_coverage.country[1], "Bolivia")
        self.assertEqual(data_layers_from_json["string"].spatial_coverage.country[2], "France")
        self.assertEqual(data_layers_from_json["string"].spatial_coverage.country[3], "Germany")
        self.assertEqual(data_layers_from_json["string"].spatial_coverage.country[4], "India")
        self.assertEqual(data_layers_from_json["string"].spatial_coverage.country[5], "Indonesia")
        self.assertEqual(data_layers_from_json["string"].spatial_coverage.country[6], "Luxembourg")
        self.assertEqual(data_layers_from_json["string"].spatial_coverage.country[7], "Netherlands")
        self.assertEqual(data_layers_from_json["string"].spatial_coverage.country[8], "Switzerland")
        self.assertEqual(data_layers_from_json["string"].spatial_coverage.country[9], "Thailand")
        self.assertEqual(data_layers_from_json["string"].spatial_coverage.country[10], "United Kingdom")
        self.assertEqual(data_layers_from_json["string"].spatial_coverage.country[11], "United States of America")
        self.assertEqual(data_layers_from_json["string"].latitude_min, -90)
        self.assertEqual(data_layers_from_json["string"].longitude_min, -180)
        self.assertEqual(data_layers_from_json["string"].latitude_max, 90)
        self.assertEqual(data_layers_from_json["string"].longitude_max, 180)
        self.assertEqual(data_layers_from_json["string"].temporal_min, "2016-03-12T00:00:01.000Z")
        self.assertEqual(data_layers_from_json["string"].temporal_max, "2019-07-30T00:00:01.000Z")
        self.assertEqual(data_layers_from_json["string"].measurement_interval, "6 hours")
        self.assertEqual(data_layers_from_json["string"].measurement_interval_description, "Data is recorded instanteneously.")
        self.assertEqual(data_layers_from_json["string"].meaning_of_timestamp, "Begining")
        self.assertEqual(data_layers_from_json["string"].meaning_of_spatial_descriptor, "Average")
        
        self.assertEqual(data_layers_from_json["string2"].id, "string2")
        self.assertEqual(data_layers_from_json["string2"].name, "string2")
        self.assertEqual(data_layers_from_json["string2"].description, "string2")
        self.assertEqual(data_layers_from_json["string2"].dataset.id, "string2")
        self.assertEqual(data_layers_from_json["string2"].dataset.name, "string2")
        self.assertEqual(data_layers_from_json["string2"].dataset.key, "string2")
        self.assertEqual(data_layers_from_json["string2"].dataset.category.id, 2)
        self.assertEqual(data_layers_from_json["string2"].dataset.category.name, "Satellite")
        self.assertEqual(data_layers_from_json["string2"].dataset.level, 1)
        self.assertEqual(data_layers_from_json["string2"].dataset.crs, "string2")
        self.assertEqual(data_layers_from_json["string2"].dataset.license_information, "string2")
        self.assertEqual(data_layers_from_json["string2"].dataset.offering_status, "string2")
        self.assertEqual(data_layers_from_json["string2"].dataset.description_short, "string2")
        self.assertEqual(data_layers_from_json["string2"].units, "string2")
        self.assertEqual(data_layers_from_json["string2"].datatype, "sh")
        self.assertEqual(data_layers_from_json["string2"].level, 23)
        self.assertEqual(data_layers_from_json["string2"].crs, "string2")
        self.assertEqual(data_layers_from_json["string2"].color_table.id, "32451")
        self.assertEqual(data_layers_from_json["string2"].name_alternate, "ESA Sentinel 2 Level-2A")
        self.assertEqual(data_layers_from_json["string2"].rating, 4.1)
        self.assertEqual(data_layers_from_json["string2"].description_short, "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.")
        self.assertEqual(data_layers_from_json["string2"].description_long, "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.")
        self.assertEqual(data_layers_from_json["string2"].description_links[0], "https://sentinel.esa.int/web/sentinel/missions2")
        self.assertEqual(data_layers_from_json["string2"].description_links[1], "https://sentinel.esa.int/documents/247904/685211/Sentinel-2_User_Handbook2")
        self.assertEqual(data_layers_from_json["string2"].description_links[2], "https://sentinel.esa.int/web/sentinel/missions/sentinel-2/data-products2")
        self.assertEqual(data_layers_from_json["string2"].description_links[3], "https://sentinel.esa.int/web/sentinel/user-guides/sentinel-2-msi2")
        self.assertEqual(data_layers_from_json["string2"].data_source_name, "European Space Agency Sentinel-2")
        self.assertEqual(data_layers_from_json["string2"].data_source_attribution, "'Copernicus Sentinel data [Year]' for Sentinel data; see https://lta.cr.usgs.gov/sites/default/files/Sentinel_Data_Terms_and_Conditions.pdf")
        self.assertEqual(data_layers_from_json["string2"].data_source_description, "'Level-2A is generated by the Payload Data Ground Segment using the Sen2Cor processor. Level-2A products are made available to users via the Copernicus Open Access Hub: https://scihub.copernicus.eu/dhus/#/home")
        self.assertEqual(data_layers_from_json["string2"].data_source_links[0], "https://sentinel.esa.int/web/sentinel/sentinel-data-access2")
        self.assertEqual(data_layers_from_json["string2"].update_interval_max, "1 day")
        self.assertEqual(data_layers_from_json["string2"].update_interval_description, "Uploads are run daily. However, note the temporal resolution.")
        self.assertEqual(data_layers_from_json["string2"].lag_horizon, "5 days")
        self.assertEqual(data_layers_from_json["string2"].lag_horizon_description, "Data is available within 24 hours.")
        self.assertEqual(data_layers_from_json["string2"].temporal_resolution, "5 days")
        self.assertEqual(data_layers_from_json["string2"].temporal_resolution_description, "string2")
        self.assertEqual(data_layers_from_json["string2"].spatial_resolution_of_raw_data, "100m")
        self.assertEqual(data_layers_from_json["string2"].interpolation, "near")
        self.assertEqual(data_layers_from_json["string2"].dimensions_description, "The sole dimension is called \"horizon\" and refers to the forecast horizon in hours. (Only integer horizons are allowed.)")
        self.assertEqual(data_layers_from_json["string2"].permanence, True)
        self.assertEqual(data_layers_from_json["string2"].permanence_description, "Data with timestamp into the future will be update, but remain constant past current timestamp (except for error corrrection).")
        self.assertEqual(data_layers_from_json["string2"].known_issues, "Updates are irregular.")
        self.assertEqual(data_layers_from_json["string2"].properties.sector[0], "Animals/livestock2")
        self.assertEqual(data_layers_from_json["string2"].properties.sector[1], "Transportation/infrastructure2")
        self.assertEqual(data_layers_from_json["string2"].properties.sector[2], "Vegetation/crops2")
        self.assertEqual(data_layers_from_json["string2"].properties.sector[3], "Weather/climate2")
        self.assertEqual(data_layers_from_json["string2"].properties.application[0], "Agriculture2")
        self.assertEqual(data_layers_from_json["string2"].properties.domain[0], "Land surface2")
        self.assertEqual(data_layers_from_json["string2"].properties.type[0], "Data product2")
        self.assertEqual(data_layers_from_json["string2"].properties.source[0], "Satellite2")
        self.assertEqual(data_layers_from_json["string2"].properties.source[1], "Survey2")
        self.assertEqual(data_layers_from_json["string2"].spatial_coverage.country[0], "Belgium2")
        self.assertEqual(data_layers_from_json["string2"].spatial_coverage.country[1], "Bolivia2")
        self.assertEqual(data_layers_from_json["string2"].spatial_coverage.country[2], "France2")
        self.assertEqual(data_layers_from_json["string2"].spatial_coverage.country[3], "Germany2")
        self.assertEqual(data_layers_from_json["string2"].spatial_coverage.country[4], "India2")
        self.assertEqual(data_layers_from_json["string2"].spatial_coverage.country[5], "Indonesia2")
        self.assertEqual(data_layers_from_json["string2"].spatial_coverage.country[6], "Luxembourg2")
        self.assertEqual(data_layers_from_json["string2"].spatial_coverage.country[7], "Netherlands2")
        self.assertEqual(data_layers_from_json["string2"].spatial_coverage.country[8], "Switzerland2")
        self.assertEqual(data_layers_from_json["string2"].spatial_coverage.country[9], "Thailand2")
        self.assertEqual(data_layers_from_json["string2"].spatial_coverage.country[10], "United Kingdom2")
        self.assertEqual(data_layers_from_json["string2"].spatial_coverage.country[11], "United States of America2")
        self.assertEqual(data_layers_from_json["string2"].latitude_min, -180)
        self.assertEqual(data_layers_from_json["string2"].longitude_min, -90)
        self.assertEqual(data_layers_from_json["string2"].latitude_max, 180)
        self.assertEqual(data_layers_from_json["string2"].longitude_max, 90)
        self.assertEqual(data_layers_from_json["string2"].temporal_min, "1970-03-12T00:00:01.000Z")
        self.assertEqual(data_layers_from_json["string2"].temporal_max, "1970-07-30T00:00:01.000Z")
        self.assertEqual(data_layers_from_json["string2"].measurement_interval, "6 hours")
        self.assertEqual(data_layers_from_json["string2"].measurement_interval_description, "Data is recorded instanteneously.")
        self.assertEqual(data_layers_from_json["string2"].meaning_of_timestamp, "Begining")
        self.assertEqual(data_layers_from_json["string2"].meaning_of_spatial_descriptor, "Average")
 
    #
    def test_data_layers_to_json(self):
        
        self.logger.info('test_data_layers_to_json')
        
        client = cl.Client()
        got_exception = False
        
        try:
            data_layers_from_json = catalog.data_layers_from_json(data_layers_str)
            data_layers_to_json = catalog.data_layers_to_json(data_layers_from_json)
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        
    #
    def test_data_layers_to_json_data_layers_post(self):
        
        self.logger.info('test_data_layers_to_json_data_layers_post')
        
        client = cl.Client()
        got_exception = False
        
        try:
            data_layers_from_json2 = catalog.data_layers_from_json(data_layers_str)
            data_layers_to_json_data_layers_post = catalog.data_layers_to_json_post(data_layers_from_json2)
        except Exception as ex:
            got_exception = True

        self.assertFalse(got_exception)
        
    #    
    def test_data_layers_display(self):
        
        self.logger.info('test_data_layers_display')
        
        try:
            data_layers_from_json3 = catalog.data_layers_from_json(data_layers_str)
            df = data_layers_from_json3.display()
        except Exception as ex:
            got_exception = True
        
        self.assertTrue(isinstance(df, pd.DataFrame))
        self.assertTrue(pd.isna(df.at[0,'dataset_id']))
        self.assertEqual(df.at[0,'id'], "string")
        self.assertEqual(df.at[0,'name'], "string")
        self.assertEqual(df.at[0,'description_short'], "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.")
        self.assertEqual(df.at[0,'description_long'], "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.")
        self.assertEqual(df.at[0,'level'], 22)
        #self.assertTrue(pd.isna(df.at[0,'type']))
        self.assertTrue(pd.isna(df.at[0,'unit']))
        self.assertTrue(pd.isna(df.at[1,'dataset_id']))
        self.assertEqual(df.at[1,'id'], "string2")
        self.assertEqual(df.at[1,'name'], "string2")
        self.assertEqual(df.at[1,'description_short'], "Images from the European Space Agency Sentinel 2 satellite pair which view land surface regions in 13 spectral bands every 5 days or faster.")
        self.assertEqual(df.at[1,'description_long'], "Sentinel-2 is a set of two satellites in polar orbit 180 degrees apart. It monitors land surface and coastal waters every 5 days at the equator and more frequently at mid-latitudes. The coverage is between latitudes 56° south and 84° north. Images are in 13 spectral bands at various ground resolutions: 4 bands at 10 m, 6 at 20 m and 3 at 60 m; the orbital swath is 290 km wide. Level 2A (L2A) images are 100x100 km ortho-rectified and spatially registered on a  global reference system; they are corrected for the atmosphere so they represent ground conditions. Currently PAIRS ingests Bands 4 (red), 8 (NIR) and SCL (Scene Classification). An NDVI layer, called 'NDVI sh', is calculated from Bands 4 and 8. Tiles are ingested on request. Currently there is some coverage for tiles in USA, Brazil, India and the Netherlands for selected days in 2018 and 2019.")
        self.assertEqual(df.at[1,'level'], 23)
        #self.assertTrue(pd.isna(df.at[1,'type']))
        self.assertTrue(pd.isna(df.at[1,'unit']))

        try:
            data_layers_from_json4 = catalog.data_layers_from_json(data_layers_str)
            df2 = data_layers_from_json4.display(columns = ['id', 'name', 'notacolumn'])
        except Exception as ex:
            got_exception = True
        
        self.assertEqual(df2.at[0,'id'], "string")
        self.assertEqual(df2.at[0,'name'], "string")
        self.assertTrue(pd.isna(df2.at[0,'notacolumn']))     
        self.assertEqual(df2.at[1,'id'], "string2")
        self.assertEqual(df2.at[1,'name'], "string2")
        self.assertTrue(pd.isna(df2.at[1,'notacolumn'])) 

    # mocked_data_layers_requests_get
    @mock.patch('ibmpairs.client.Client.get', 
                side_effect=mocked_data_layers_requests_get
               )
    def test_data_layers_get(self, mock_delete):
        
        self.logger.info('test_data_layers_get: success')
        
        dl = catalog.DataLayers()
                        
        got_exception = False

        try:
            result = dl.get()
        except Exception as ex:
            got_exception = True
            
        self.assertFalse(got_exception)
        
        self.assertEqual(result["string"].id, "string")
        self.assertEqual(result["string"].name, "string")
        self.assertEqual(result["string2"].id, "string2")
        self.assertEqual(result["string2"].name, "string2")
        
        self.logger.info('test_data_layers_get: success by set')
        
        dl7 = catalog.DataLayers()
                        
        got_exception = False

        try:
            result = dl7.get(data_set_id = 999)
        except Exception as ex:
            got_exception = True
            
        self.assertFalse(got_exception)
        
        self.assertEqual(result["string"].id, "string")
        self.assertEqual(result["string"].name, "string")
        self.assertEqual(result["string"].dataset.id, "999")
        self.assertEqual(result["string2"].id, "string2")
        self.assertEqual(result["string2"].name, "string2")
        self.assertEqual(result["string2"].dataset.id, "999")
        
        self.logger.info('test_data_layers_get: fail 404')
        
        dl2 = catalog.DataLayers()
                        
        got_exception2 = False

        try:
            result = dl2.get()
        except Exception as ex:
            got_exception2 = True
            self.assertEqual(str(ex), "The GET request call to https://pairs.res.ibm.com/v2/datalayers/full failed with status code: 404, message: failed.")
            
        self.assertTrue(got_exception2)
        
        self.logger.info('test_data_layers_get: fail server error')
        
        dl3 = catalog.DataLayers()
                        
        got_exception3 = False

        try:
            result = dl3.get()
        except Exception as ex:
            got_exception3 = True
            self.assertEqual(str(ex), "The GET request to https://pairs.res.ibm.com/v2/datalayers/full encountered an unspecified error contacting the server; the request was unsuccessful, error message: __init__() got an unexpected keyword argument 'status'")

        self.assertTrue(got_exception3)
        
        self.logger.info('test_data_layers_get: fail server error by set')
        
        dl4 = catalog.DataLayers()
                        
        got_exception4 = False

        try:
            result4 = dl4.get(data_set_id = 997)
        except Exception as ex:
            got_exception4 = True
            self.assertEqual(str(ex), "The GET request to https://pairs.res.ibm.com/v2/datasets/997/datalayers encountered an unspecified error contacting the server; the request was unsuccessful, error message: __init__() got an unexpected keyword argument 'status'")

        self.assertTrue(got_exception4)
        
        self.logger.info('test_data_layers_get: helper, success')
                        
        got_exception6 = False

        try:
            result2 = catalog.get_data_layers()
        except Exception as ex:
            got_exception6 = True
            
        self.assertFalse(got_exception6)
       
        self.assertTrue(result2["string"].id, "string")
        self.assertTrue(result2["string"].name_alternate, "string")
        self.assertTrue(result2["string2"].id, "string2")
        self.assertTrue(result2["string2"].name_alternate, "string2")
        
        self.logger.info('test_data_layers_get: helper, success by set')
 
        got_exception = False

        try:
            result3 = catalog.get_data_layers(data_set_id = 999)
        except Exception as ex:
            got_exception = True
            
        self.assertFalse(got_exception)
        
        self.assertEqual(result3["string"].id, "string")
        self.assertEqual(result3["string"].name, "string")
        self.assertEqual(result3["string"].dataset.id, "999")
        self.assertEqual(result3["string2"].id, "string2")
        self.assertEqual(result3["string2"].name, "string2")
        self.assertEqual(result3["string2"].dataset.id, "999")
        
    # mocked_data_layers_requests_post
    @mock.patch('ibmpairs.client.Client.get', 
                side_effect=mocked_data_layers_requests_get
               )
    @mock.patch('ibmpairs.client.Client.post', 
                side_effect=mocked_data_layer_requests_post
               )
    def test_data_layers_create(self, mock_post, mock_get):
        
        self.logger.info('test_data_layers_create: success')
        
        got_exception = False

        dls = None

        try:
            data_layers_create = catalog.data_layers_from_dict(data_layers_create_get_dict)
            data_layers_create.create(data_set_id       = 998,
                                      data_layer_type  = 'vectorpoint',
                                      data_layer_group = 'groupname'
                                     )
        except Exception as ex:
            self.logger.info(ex)        
            got_exception = True


        self.assertFalse(got_exception)
        self.assertEqual(data_layers_create.data_layer_response.data_layer_ids[0], "P001C0001")
        self.assertEqual(data_layers_create.data_layer_response.data_layer_ids[1], "P001C0002")
        self.assertEqual(data_layers_create.data_layers[0].id, "P001C0001")
        self.assertEqual(data_layers_create.data_layers[1].id, "P001C0002")
        self.assertEqual(data_layers_create.group, "groupname")
        self.assertEqual(data_layers_create.group_id, "001")
        self.assertEqual(data_layers_create.layer_type, "vectorpoint")

        self.logger.info('test_data_layers_create: helper, success')
        
        got_exception2 = False

        helper = None

        try:
            data_layers_create2 = catalog.data_layers_from_dict(data_layers_create_get_dict)
            helper = catalog.create_data_layers(data_layers      = data_layers_create2,
                                                data_set_id      = 998,
                                                data_layer_type  = 'vectorpoint',
                                                data_layer_group = 'groupname'
                                               )
        except Exception as ex:
            self.logger.info(ex)        
            got_exception2 = True
            
        self.assertFalse(got_exception2)
        self.assertEqual(helper.data_layer_response.data_layer_ids[0], "P001C0001")
        self.assertEqual(helper.data_layer_response.data_layer_ids[1], "P001C0002")
        self.assertEqual(helper.data_layers[0].id, "P001C0001")
        self.assertEqual(helper.data_layers[1].id, "P001C0002")
        self.assertEqual(helper.group, "groupname")
        self.assertEqual(helper.group_id, "001")
        self.assertEqual(helper.layer_type, "vectorpoint")
        
        self.logger.info('test_data_layers_create: fail no type')
        
        got_exception3 = False

        try:
            data_layers_create3 = catalog.data_layers_from_dict(data_layers_create_get_dict)
            data_layers_create3.create(data_set_id       = 998,
                                       data_layer_group = 'groupname'
                                      )
        except Exception as ex:
            self.logger.info(ex)   
            self.assertEqual(str(ex), "The DataLayers object has no data layer type set.")   
            got_exception3 = True

        self.assertTrue(got_exception3)
        
        self.logger.info('test_data_layers_create: fail no set id')
        
        got_exception4 = False

        try:
            data_layers_create4 = catalog.data_layers_from_dict(data_layers_create_get_dict)
            data_layers_create4.create(data_layer_type  = 'vectorpoint',
                                       data_layer_group = 'groupname'
                                      )
        except Exception as ex:
            self.logger.info(ex)   
            self.assertEqual(str(ex), "The DataLayers object has no Data Set ID set and none was provided.")   
            got_exception4 = True

        self.assertTrue(got_exception4)
        
        self.logger.info('test_data_layers_create: vector no group name')
        
        got_exception5 = False

        try:
            data_layers_create5 = catalog.data_layers_from_dict(data_layers_create_get_dict)
            data_layers_create5.create(data_set_id      = 998,
                                       data_layer_type  = 'vectorpoint'
                                      )
        except Exception as ex:
            self.logger.info(ex)   
            self.assertEqual(str(ex), "The DataLayers.create method requires a group name to be set in the group attribute, please provide this into the method call as create(data_layer_group = '<data_layer_group_name>') or add to the object data_layers_object.group = '<data_layer_group_name>'.")   
            got_exception5 = True

        self.assertTrue(got_exception5)
